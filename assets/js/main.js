(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 2.0.2, Thu Mar 01 2018
 *
 * http://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */

(function (global, factory) {
    (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Dexie = factory();
})(undefined, function () {
    'use strict';

    var keys = Object.keys;
    var isArray = Array.isArray;
    var _global = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;
    function extend(obj, extension) {
        if ((typeof extension === 'undefined' ? 'undefined' : _typeof(extension)) !== 'object') return obj;
        keys(extension).forEach(function (key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function') extension = extension(getProto(proto));
        keys(extension).forEach(function (key) {
            setProp(proto, key, extension[key]);
        });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
        return {
            from: function from(Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop),
            proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    var _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b) throw new Error("Assertion Failed");
    }
    function asap(fn) {
        if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);
    }

    /** Generate an object (hash map) based on given array.
     * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to
     *        instert on the resulting object for each item in the array. If this function returns a falsy value, the
     *        current item wont affect the resulting object.
     */
    function arrayToObject(array, extractor) {
        return array.reduce(function (result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }
    function trycatcher(fn, reject) {
        return function () {
            try {
                fn.apply(this, arguments);
            } catch (e) {
                reject(e);
            }
        };
    }
    function tryCatch(fn, onerror, args) {
        try {
            fn.apply(null, args);
        } catch (ex) {
            onerror && onerror(ex);
        }
    }
    function getByKeyPath(obj, keyPath) {
        // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path
        if (hasOwn(obj, keyPath)) return obj[keyPath]; // This line is moved from last to first for optimization purpose.
        if (!keyPath) return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined) return;
        if ('isFrozen' in Object && Object.isFrozen(obj)) return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        } else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "") {
                    if (value === undefined) delete obj[currentKeyPath];else obj[currentKeyPath] = value;
                } else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj) innerObj = obj[currentKeyPath] = {};
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            } else {
                if (value === undefined) delete obj[keyPath];else obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {
            setByKeyPath(obj, kp, undefined);
        });
    }
    function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
            if (hasOwn(obj, m)) rv[m] = obj[m];
        }
        return rv;
    }
    var concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    //https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    var intrinsicTypes = "Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set".split(',').concat(flatten([8, 16, 32, 64].map(function (num) {
        return ["Int", "Uint", "Float"].map(function (t) {
            return t + num + "Array";
        });
    }))).filter(function (t) {
        return _global[t];
    }).map(function (t) {
        return _global[t];
    });
    function deepClone(any) {
        if (!any || (typeof any === 'undefined' ? 'undefined' : _typeof(any)) !== 'object') return any;
        var rv;
        if (isArray(any)) {
            rv = [];
            for (var i = 0, l = any.length; i < l; ++i) {
                rv.push(deepClone(any[i]));
            }
        } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
            rv = any;
        } else {
            rv = any.constructor ? Object.create(any.constructor.prototype) : {};
            for (var prop in any) {
                if (hasOwn(any, prop)) {
                    rv[prop] = deepClone(any[prop]);
                }
            }
        }
        return rv;
    }
    function getObjectDiff(a, b, rv, prfx) {
        // Compares objects a and b and produces a diff object.
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach(function (prop) {
            if (!hasOwn(b, prop)) rv[prfx + prop] = undefined; // Property removed
            else {
                    var ap = a[prop],
                        bp = b[prop];
                    if ((typeof ap === 'undefined' ? 'undefined' : _typeof(ap)) === 'object' && (typeof bp === 'undefined' ? 'undefined' : _typeof(bp)) === 'object' && ap && bp &&
                    // Now compare constructors are same (not equal because wont work in Safari)
                    '' + ap.constructor === '' + bp.constructor)
                        // Same type of object but its properties may have changed
                        getObjectDiff(ap, bp, rv, prfx + prop + ".");else if (ap !== bp) rv[prfx + prop] = b[prop]; // Primitive value changed
                }
        });
        keys(b).forEach(function (prop) {
            if (!hasOwn(a, prop)) {
                rv[prfx + prop] = b[prop]; // Property added
            }
        });
        return rv;
    }
    // If first argument is iterable or array-like, return it as an array
    var iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;
    var getIteratorOf = iteratorSymbol ? function (x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function () {
        return null;
    };
    var NO_CHAR_ARRAY = {};
    // Takes one or several arguments and returns an array based on the following criteras:
    // * If several arguments provided, return arguments converted to an array in a way that
    //   still allows javascript engine to optimize the code.
    // * If single argument is an array, return a clone of it.
    // * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special
    //   case to the two bullets below.
    // * If single argument is an iterable, convert it to an array and return the resulting array.
    // * If single argument is array-like (has length of type number), convert it to an array.
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray(arrayLike)) return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];
            if (it = getIteratorOf(arrayLike)) {
                a = [];
                while (x = it.next(), !x.done) {
                    a.push(x.value);
                }return a;
            }
            if (arrayLike == null) return [arrayLike];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while (i--) {
                    a[i] = arrayLike[i];
                }return a;
            }
            return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--) {
            a[i] = arguments[i];
        }return a;
    }

    // By default, debug will be true only if platform is a web platform and its page is served from localhost.
    // When debug = true, error's stacks will contain asyncronic long stacks.
    var debug = typeof location !== 'undefined' &&
    // By default, use debug mode if served from localhost.
    /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
        libraryFilter = filter;
    }
    var libraryFilter = function libraryFilter() {
        return true;
    };
    var NEEDS_THROW_FOR_STACK = !new Error("").stack;
    function getErrorWithStack() {
        "use strict";

        if (NEEDS_THROW_FOR_STACK) try {
            // Doing something naughty in strict mode here to trigger a specific error
            // that can be explicitely ignored in debugger's exception settings.
            // If we'd just throw new Error() here, IE's debugger's exception settings
            // will just consider it as "exception thrown by javascript code" which is
            // something you wouldn't want it to ignore.
            getErrorWithStack.arguments;
            throw new Error(); // Fallback if above line don't throw.
        } catch (e) {
            return e;
        }
        return new Error();
    }
    function prettyStack(exception, numIgnoredFrames) {
        var stack = exception.stack;
        if (!stack) return "";
        numIgnoredFrames = numIgnoredFrames || 0;
        if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\n').length;
        return stack.split('\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {
            return "\n" + frame;
        }).join('');
    }
    function deprecated(what, fn) {
        return function () {
            console.warn(what + " is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. " + prettyStack(getErrorWithStack(), 1));
            return fn.apply(this, arguments);
        };
    }

    var dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];
    var idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed"
    };
    //
    // DexieError - base class of all out exceptions.
    //
    function DexieError(name, msg) {
        // Reason we don't use ES6 classes is because:
        // 1. It bloats transpiled code and increases size of minified code.
        // 2. It doesn't give us much in this case.
        // 3. It would require sub classes to call super(), which
        //    is not needed when deriving from Error.
        this._e = getErrorWithStack();
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        stack: {
            get: function get() {
                return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
            }
        },
        toString: function toString() {
            return this.name + ": " + this.message;
        }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + failures.map(function (f) {
            return f.toString();
        }).filter(function (v, i, s) {
            return s.indexOf(v) === i;
        }) // Only unique error strings
        .join('\n');
    }
    //
    // ModifyError - thrown in Collection.modify()
    // Specific constructor because it contains members failures and failedKeys.
    //
    function ModifyError(msg, failures, successCount, failedKeys) {
        this._e = getErrorWithStack();
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this._e = getErrorWithStack();
        this.name = "BulkError";
        this.failures = failures;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(BulkError).from(DexieError);
    //
    //
    // Dynamically generate error names and exception classes based
    // on the names in errorList.
    //
    //
    // Map of {ErrorName -> ErrorName + "Error"}
    var errnames = errorList.reduce(function (obj, name) {
        return obj[name] = name + "Error", obj;
    }, {});
    // Need an alias for DexieError because we're gonna create subclasses with the same name.
    var BaseException = DexieError;
    // Map of {ErrorName -> exception constructor}
    var exceptions = errorList.reduce(function (obj, name) {
        // Let the name be "DexieError" because this name may
        // be shown in call stack and when debugging. DexieError is
        // the most true name because it derives from DexieError,
        // and we cannot change Function.name programatically without
        // dynamically create a Function object, which would be considered
        // 'eval-evil'.
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this._e = getErrorWithStack();
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            } else if (typeof msgOrInner === 'string') {
                this.message = msgOrInner;
                this.inner = inner || null;
            } else if ((typeof msgOrInner === 'undefined' ? 'undefined' : _typeof(msgOrInner)) === 'object') {
                this.message = msgOrInner.name + " " + msgOrInner.message;
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    // Use ECMASCRIPT standard exceptions where applicable:
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            // Derive stack from inner exception if it has a stack
            setProp(rv, "stack", { get: function get() {
                    return this.inner.stack;
                } });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce(function (obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;

    function nop() {}
    function mirror(val) {
        return val;
    }
    function pureFunctionChain(f1, f2) {
        // Enables chained events that takes ONE argument and returns it to the next function in chain.
        // This pattern is used in the hook("reading") event.
        if (f1 == null || f1 === mirror) return f2;
        return function (val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function () {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.
        // This pattern is used in the hook("creating") event.
        if (f1 === nop) return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res !== undefined) arguments[0] = res;
            var onsuccess = this.onsuccess,
                // In case event listener has set this.onsuccess
            onerror = this.onerror; // In case event listener has set this.onerror
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop) return f2;
        return function () {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess,
                // In case event listener has set this.onsuccess
            onerror = this.onerror; // In case event listener has set this.onerror
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop) return f2;
        return function (modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.
            var onsuccess = this.onsuccess,
                // In case event listener has set this.onsuccess
            onerror = this.onerror; // In case event listener has set this.onerror
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop) return f2;
        return function () {
            if (f2.apply(this, arguments) === false) return false;
            return f1.apply(this, arguments);
        };
    }

    function promisableChain(f1, f2) {
        if (f1 === nop) return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this,
                    i = arguments.length,
                    args = new Array(i);
                while (i--) {
                    args[i] = arguments[i];
                }return res.then(function () {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }

    /*
     * Copyright (c) 2014-2017 David Fahlander
     * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0
     */
    //
    // Promise and Zone (PSD) for Dexie library
    //
    // I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by
    // https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.
    //
    // In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another
    // tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use
    // another strategy now that simplifies everything a lot: to always execute callbacks in a new micro-task, but have an own micro-task
    // engine that is indexedDB compliant across all browsers.
    // Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.
    // Also with inspiration from bluebird, asyncronic stacks in debug mode.
    //
    // Specific non-standard features of this Promise class:
    // * Custom zone support (a.k.a. PSD) with ability to keep zones also when using native promises as well as
    //   native async / await.
    // * Promise.follow() method built upon the custom zone engine, that allows user to track all promises created from current stack frame
    //   and below + all promises that those promises creates or awaits.
    // * Detect any unhandled promise in a PSD-scope (PSD.onunhandled). 
    //
    // David Fahlander, https://github.com/dfahlander
    //
    // Just a pointer that only this module knows about.
    // Used in Promise constructor to emulate a private constructor.
    var INTERNAL = {};
    // Async stacks (long stacks) must not grow infinitely.
    var LONG_STACKS_CLIP_LIMIT = 100;
    var MAX_LONG_STACKS = 20;
    var ZONE_ECHO_LIMIT = 7;
    var nativePromiseInstanceAndProto = function () {
        try {
            // Be able to patch native async functions
            return new Function("let F=async ()=>{},p=F();return [p,Object.getPrototypeOf(p),Promise.resolve(),F.constructor];")();
        } catch (e) {
            var P = _global.Promise;
            return P ? [P.resolve(), P.prototype, P.resolve()] : [];
        }
    }();
    var resolvedNativePromise = nativePromiseInstanceAndProto[0];
    var nativePromiseProto = nativePromiseInstanceAndProto[1];
    var resolvedGlobalPromise = nativePromiseInstanceAndProto[2];
    var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var AsyncFunction = nativePromiseInstanceAndProto[3];
    var patchGlobalPromise = !!resolvedGlobalPromise;
    var stack_being_generated = false;
    /* The default function used only for the very first promise in a promise chain.
       As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks
       emulated in this module. For indexedDB compatibility, this means that every method needs to
       execute at least one promise before doing an indexedDB operation. Dexie will always call
       db.ready().then() for every operation to make sure the indexedDB event is started in an
       indexedDB-compatible emulated micro task loop.
    */
    var schedulePhysicalTick = resolvedGlobalPromise ? function () {
        resolvedGlobalPromise.then(physicalTick);
    } : _global.setImmediate ?
    // setImmediate supported. Those modern platforms also supports Function.bind().
    setImmediate.bind(null, physicalTick) : _global.MutationObserver ?
    // MutationObserver supported
    function () {
        var hiddenDiv = document.createElement("div");
        new MutationObserver(function () {
            physicalTick();
            hiddenDiv = null;
        }).observe(hiddenDiv, { attributes: true });
        hiddenDiv.setAttribute('i', '1');
    } :
    // No support for setImmediate or MutationObserver. No worry, setTimeout is only called
    // once time. Every tick that follows will be our emulated micro tick.
    // Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug 
    function () {
        setTimeout(physicalTick, 0);
    };
    // Configurable through Promise.scheduler.
    // Don't export because it would be unsafe to let unknown
    // code call it unless they do try..catch within their callback.
    // This function can be retrieved through getter of Promise.scheduler though,
    // but users must not do Promise.scheduler = myFuncThatThrowsException
    var asap$1 = function asap$1(callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true;
    var needsNewPhysicalTick = true;
    var unhandledErrors = [];
    var rejectingErrors = [];
    var currentFulfiller = null;
    var rejectionMapper = mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: globalError,
        pgp: false,
        env: {},
        finalize: function finalize() {
            this.unhandleds.forEach(function (uh) {
                try {
                    globalError(uh[0], uh[1]);
                } catch (e) {}
            });
        }
    };
    var PSD = globalPSD;
    var microtickQueue = []; // Callbacks to call in this or next physical tick.
    var numScheduledCalls = 0; // Number of listener-calls left to do in this physical tick.
    var tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.
    function Promise(fn) {
        if (_typeof(this) !== 'object') throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this.onuncatched = nop; // Deprecate in next major. Not needed. Better to use global error handler.
        // A library may set `promise._lib = true;` after promise is created to make resolve() or reject()
        // execute the microtask engine implicitely within the call to resolve() or reject().
        // To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack
        // only contains library code when calling resolve() or reject().
        // RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving/rejecting directly from
        // global scope (event handler, timer etc)!
        this._lib = false;
        // Current async scope
        var psd = this._PSD = PSD;
        if (debug) {
            this._stackHolder = getErrorWithStack();
            this._prev = null;
            this._numPrev = 0; // Number of previous promises (for long stacks)
        }
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL) throw new TypeError('Not a function');
            // Private constructor (INTERNAL, state, value).
            // Used internally by Promise.resolve() and Promise.reject().
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false) handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().
            return;
        }
        this._state = null; // null (=pending), false (=rejected) or true (=resolved)
        this._value = null; // error or result
        ++psd.ref; // Refcounting current scope
        executePromiseTask(this, fn);
    }
    // Prepare a property descriptor to put onto Promise.prototype.then
    var thenProp = {
        get: function get() {
            var psd = PSD,
                microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var _this = this;
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                if (possibleAwait) decrementExpectedAwaits();
                var rv = new Promise(function (resolve, reject) {
                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait), resolve, reject, psd));
                });
                debug && linkToPreviousPromise(rv, this);
                return rv;
            }
            then.prototype = INTERNAL; // For idempotense, see setter below.
            return then;
        },
        // Be idempotent and allow another framework (such as zone.js or another instance of a Dexie.Promise module) to replace Promise.prototype.then
        // and when that framework wants to restore the original property, we must identify that and restore the original property descriptor.
        set: function set(value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : // Restore to original property descriptor.
            {
                get: function get() {
                    return value; // Getter returning provided value (behaves like value is just changed)
                },
                set: thenProp.set // Keep a setter that is prepared to restore original.
            });
        }
    };
    props(Promise.prototype, {
        then: thenProp,
        _then: function _then(onFulfilled, onRejected) {
            // A little tinier version of then() that don't have to create a resulting promise.
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function _catch(onRejected) {
            if (arguments.length === 1) return this.then(null, onRejected);
            // First argument is the Error type to catch
            var type = arguments[0],
                handler = arguments[1];
            return typeof type === 'function' ? this.then(null, function (err) {
                // Catching errors by its constructor type (similar to java / c++ / c#)
                // Sample: promise.catch(TypeError, function (e) { ... });
                return err instanceof type ? handler(err) : PromiseReject(err);
            }) : this.then(null, function (err) {
                // Catching errors by the error.name property. Makes sense for indexedDB where error type
                // is always DOMError but where e.name tells the actual error type.
                // Sample: promise.catch('ConstraintError', function (e) { ... });
                return err && err.name === type ? handler(err) : PromiseReject(err);
            });
        },
        finally: function _finally(onFinally) {
            return this.then(function (value) {
                onFinally();
                return value;
            }, function (err) {
                onFinally();
                return PromiseReject(err);
            });
        },
        stack: {
            get: function get() {
                if (this._stack) return this._stack;
                try {
                    stack_being_generated = true;
                    var stacks = getStack(this, [], MAX_LONG_STACKS);
                    var stack = stacks.join("\nFrom previous: ");
                    if (this._state !== null) this._stack = stack; // Stack may be updated on reject.
                    return stack;
                } finally {
                    stack_being_generated = false;
                }
            }
        },
        timeout: function timeout(ms, msg) {
            var _this = this;
            return ms < Infinity ? new Promise(function (resolve, reject) {
                var handle = setTimeout(function () {
                    return reject(new exceptions.Timeout(msg));
                }, ms);
                _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
            }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(Promise.prototype, Symbol.toStringTag, 'Promise');
    // Now that Promise.prototype is defined, we have all it takes to set globalPSD.env.
    // Environment globals snapshotted on leaving global zone
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    // Promise Static Properties
    props(Promise, {
        all: function all() {
            var values = getArrayOf.apply(null, arguments) // Supports iterables, implicit arguments and array-like.
            .map(onPossibleParallellAsync); // Handle parallell async/awaits 
            return new Promise(function (resolve, reject) {
                if (values.length === 0) resolve([]);
                var remaining = values.length;
                values.forEach(function (a, i) {
                    return Promise.resolve(a).then(function (x) {
                        values[i] = x;
                        if (! --remaining) resolve(values);
                    }, reject);
                });
            });
        },
        resolve: function resolve(value) {
            if (value instanceof Promise) return value;
            if (value && typeof value.then === 'function') return new Promise(function (resolve, reject) {
                value.then(resolve, reject);
            });
            var rv = new Promise(INTERNAL, true, value);
            linkToPreviousPromise(rv, currentFulfiller);
            return rv;
        },
        reject: PromiseReject,
        race: function race() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new Promise(function (resolve, reject) {
                values.map(function (value) {
                    return Promise.resolve(value).then(resolve, reject);
                });
            });
        },
        PSD: {
            get: function get() {
                return PSD;
            },
            set: function set(value) {
                return PSD = value;
            }
        },
        //totalEchoes: {get: ()=>totalEchoes},
        //task: {get: ()=>task},
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: function get() {
                return asap$1;
            },
            set: function set(value) {
                asap$1 = value;
            }
        },
        rejectionMapper: {
            get: function get() {
                return rejectionMapper;
            },
            set: function set(value) {
                rejectionMapper = value;
            } // Map reject failures
        },
        follow: function follow(fn, zoneProps) {
            return new Promise(function (resolve, reject) {
                return newScope(function (resolve, reject) {
                    var psd = PSD;
                    psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()
                    psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.
                    psd.finalize = callBoth(function () {
                        var _this = this;
                        // Unhandled standard or 3rd part promises are put in PSD.unhandleds and
                        // examined upon scope completion while unhandled rejections in this Promise
                        // will trigger directly through psd.onunhandled
                        run_at_end_of_this_or_next_physical_tick(function () {
                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    /**
    * Take a potentially misbehaving resolver function and make sure
    * onFulfilled and onRejected are only called once.
    *
    * Makes no guarantees about asynchrony.
    */
    function executePromiseTask(promise, fn) {
        // Promise Resolution Procedure:
        // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
        try {
            fn(function (value) {
                if (promise._state !== null) return; // Already settled
                if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, function (resolve, reject) {
                        value instanceof Promise ? value._then(resolve, reject) : value.then(resolve, reject);
                    });
                } else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick) endMicroTickScope();
            }, handleRejection.bind(null, promise)); // If Function.bind is not supported. Exception is handled in catch below
        } catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null) return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        debug && reason !== null && (typeof reason === 'undefined' ? 'undefined' : _typeof(reason)) === 'object' && !reason._promise && tryCatch(function () {
            var origProp = getPropertyDescriptor(reason, "stack");
            reason._promise = promise;
            setProp(reason, "stack", {
                get: function get() {
                    return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;
                }
            });
        });
        // Add the failure to a list of possibly uncaught errors
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick) endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        //debug && linkToPreviousPromise(promise);
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();
        if (numScheduledCalls === 0) {
            // If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,
            // and that no deferreds where listening to this rejection or success.
            // Since there is a risk that our stack can contain application code that may
            // do stuff after this code is finished that may generate new calls, we cannot
            // call finalizers here.
            ++numScheduledCalls;
            asap$1(function () {
                if (--numScheduledCalls === 0) finalizePhysicalTick(); // Will detect unhandled errors
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap$1(callListener, [cb, promise, listener]);
    }
    function callListener(cb, promise, listener) {
        try {
            // Set static variable currentFulfiller to the promise that is being fullfilled,
            // so that we connect the chain of promises (for long stacks support)
            currentFulfiller = promise;
            // Call callback and resolve our listener with it's return value.
            var ret,
                value = promise._value;
            if (promise._state) {
                // cb is onResolved
                ret = cb(value);
            } else {
                // cb is onRejected
                if (rejectingErrors.length) rejectingErrors = [];
                ret = cb(value);
                if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.
            }
            listener.resolve(ret);
        } catch (e) {
            // Exception thrown in callback. Reject our listener.
            listener.reject(e);
        } finally {
            // Restore env and currentFulfiller.
            currentFulfiller = null;
            if (--numScheduledCalls === 0) finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function getStack(promise, stacks, limit) {
        if (stacks.length === limit) return stacks;
        var stack = "";
        if (promise._state === false) {
            var failure = promise._value,
                errorName,
                message;
            if (failure != null) {
                errorName = failure.name || "Error";
                message = failure.message || failure;
                stack = prettyStack(failure, 0);
            } else {
                errorName = failure; // If error is undefined or null, show that.
                message = "";
            }
            stacks.push(errorName + (message ? ": " + message : "") + stack);
        }
        if (debug) {
            stack = prettyStack(promise._stackHolder, 2);
            if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);
            if (promise._prev) getStack(promise._prev, stacks, limit);
        }
        return stacks;
    }
    function linkToPreviousPromise(promise, prev) {
        // Support long stacks by linking to previous completed promise.
        var numPrev = prev ? prev._numPrev + 1 : 0;
        if (numPrev < LONG_STACKS_CLIP_LIMIT) {
            promise._prev = prev;
            promise._numPrev = numPrev;
        }
    }
    /* The callback to schedule with setImmediate() or setTimeout().
       It runs a virtual microtick and executes any callback registered in microtickQueue.
     */
    function physicalTick() {
        beginMicroTickScope() && endMicroTickScope();
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    /* Executes micro-ticks without doing try..catch.
       This can be possible because we only use this internally and
       the registered functions are exception-safe (they do try..catch
       internally before calling any external method). If registering
       functions in the microtickQueue that are not exception-safe, this
       would destroy the framework and make it instable. So we don't export
       our asap method.
    */
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while (microtickQueue.length > 0) {
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for (i = 0; i < l; ++i) {
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function (p) {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.
        var i = finalizers.length;
        while (i) {
            finalizers[--i]();
        }
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap$1(function () {
            if (--numScheduledCalls === 0) finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        // Only add to unhandledErrors if not already there. The first one to add to this list
        // will be upon the first rejection so that the root cause (first promise in the
        // rejection chain) is the one listed.
        if (!unhandledErrors.some(function (p) {
            return p._value === promise._value;
        })) unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        // Called when a reject handled is actually being called.
        // Search in unhandledErrors for any promise whos _value is this promise_value (list
        // contains only rejected promises, and only one item per error)
        var i = unhandledErrors.length;
        while (i) {
            if (unhandledErrors[--i]._value === promise._value) {
                // Found a promise that failed with this same error object pointer,
                // Remove that since there is a listener that actually takes care of it.
                unhandledErrors.splice(i, 1);
                return;
            }
        }
    }
    function PromiseReject(reason) {
        return new Promise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function () {
            var wasRootExec = beginMicroTickScope(),
                outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            } catch (e) {
                errorCatcher && errorCatcher(e);
            } finally {
                switchToZone(outerScope, false);
                if (wasRootExec) endMicroTickScope();
            }
        };
    }
    //
    // variables used for native await support
    //
    var task = { awaits: 0, echoes: 0, id: 0 }; // The ongoing macro-task when using zone-echoing.
    var taskCounter = 0; // ID counter for macro tasks.
    var zoneStack = []; // Stack of left zones to restore asynchronically.
    var zoneEchoes = 0; // zoneEchoes is a must in order to persist zones between native await expressions.
    var totalEchoes = 0; // ID counter for micro-tasks. Used to detect possible native await in our Promise.prototype.then.
    var zone_id_counter = 0;
    function newScope(fn, props$$1, a1, a2) {
        var parent = PSD,
            psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        // Prepare for promise patching (done in usePSD):
        var globalEnv = globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: Promise,
            PromiseProp: { value: Promise, configurable: true, writable: true },
            all: Promise.all,
            race: Promise.race,
            resolve: Promise.resolve,
            reject: Promise.reject,
            nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
            gthen: getPatchedPromiseThen(globalEnv.gthen, psd) // global then
        } : {};
        if (props$$1) extend(psd, props$$1);
        // unhandleds and onunhandled should not be specifically set here.
        // Leave them on parent prototype.
        // unhandleds.push(err) will push to parent's prototype
        // onunhandled() will call parents onunhandled (with this scope's this-pointer though!)
        ++parent.ref;
        psd.finalize = function () {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0) psd.finalize();
        return rv;
    }
    // Function to call if scopeFunc returns NativePromise
    // Also for each NativePromise in the arguments to Promise.all()
    function incrementExpectedAwaits() {
        if (!task.id) task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    // Function to call when 'then' calls back on a native promise where onAwaitExpected() had been called.
    // Also call this when a native await calls then method on a promise. In that case, don't supply
    // sourceTaskId because we already know it refers to current task.
    function decrementExpectedAwaits(sourceTaskId) {
        if (!task.awaits || sourceTaskId && sourceTaskId !== task.id) return;
        if (--task.awaits === 0) task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT; // Will reset echoes to 0 if awaits is 0.
    }
    // Call from Promise.all() and Promise.race()
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function (x) {
                decrementExpectedAwaits();
                return x;
            }, function (e) {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.id = 0; // Cancel zone echoing.
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {
            // Enter or leave zone asynchronically as well, so that tasks initiated during current tick
            // will be surrounded by the zone when they are invoked.
            enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD) return;
        PSD = targetZone; // The actual zone switch occurs at this line.
        // Snapshot on every leave from global zone.
        if (currentZone === globalPSD) globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            // Let's patch the global and native Promises (may be same or may be different)
            var GlobalPromise = globalPSD.env.Promise;
            // Swich environments (may be PSD-zone or the global zone. Both apply.)
            var targetEnv = targetZone.env;
            // Change Promise.prototype.then for native and global Promise (they MAY differ on polyfilled environments, but both can be accessed)
            // Must be done on each zone change because the patched method contains targetZone in its closure.
            nativePromiseProto.then = targetEnv.nthen;
            GlobalPromise.prototype.then = targetEnv.gthen;
            if (currentZone.global || targetZone.global) {
                // Leaving or entering global zone. It's time to patch / restore global Promise.
                // Set this Promise to window.Promise so that transiled async functions will work on Firefox, Safari and IE, as well as with Zonejs and angular.
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                // Support Promise.all() etc to work indexedDB-safe also when people are including es6-promise as a module (they might
                // not be accessing global.Promise but a local reference to it)
                GlobalPromise.all = targetEnv.all;
                GlobalPromise.race = targetEnv.race;
                GlobalPromise.resolve = targetEnv.resolve;
                GlobalPromise.reject = targetEnv.reject;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject,
            nthen: nativePromiseProto.then,
            gthen: GlobalPromise.prototype.then
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        } finally {
            switchToZone(outerScope, false);
        }
    }
    function enqueueNativeMicroTask(job) {
        //
        // Precondition: nativePromiseThen !== undefined
        //
        nativePromiseThen.call(resolvedNativePromise, job);
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait) {
        return typeof fn !== 'function' ? fn : function () {
            var outerZone = PSD;
            if (possibleAwait) incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            } finally {
                switchToZone(outerZone, false);
            }
        };
    }
    function getPatchedPromiseThen(origThen, zone) {
        return function (onResolved, onRejected) {
            return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone, false), nativeAwaitCompatibleWrap(onRejected, zone, false));
        };
    }
    var UNHANDLEDREJECTION = "unhandledrejection";
    function globalError(err, promise) {
        var rv;
        try {
            rv = promise.onuncatched(err);
        } catch (e) {}
        if (rv !== false) try {
            var event,
                eventData = { promise: promise, reason: err };
            if (_global.document && document.createEvent) {
                event = document.createEvent('Event');
                event.initEvent(UNHANDLEDREJECTION, true, true);
                extend(event, eventData);
            } else if (_global.CustomEvent) {
                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
                extend(event, eventData);
            }
            if (event && _global.dispatchEvent) {
                dispatchEvent(event);
                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
                    // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.
                    try {
                        _global.onunhandledrejection(event);
                    } catch (_) {}
            }
            if (!event.defaultPrevented) {
                console.warn("Unhandled rejection: " + (err.stack || err));
            }
        } catch (e) {}
    }
    var rejection = Promise.reject;

    function Events(ctx) {
        var evs = {};
        var rv = function rv(eventName, subscriber) {
            if (subscriber) {
                // Subscribe. If additional arguments than just the subscriber was provided, forward them as well.
                var i = arguments.length,
                    args = new Array(i - 1);
                while (--i) {
                    args[i - 1] = arguments[i];
                }evs[eventName].subscribe.apply(null, args);
                return ctx;
            } else if (typeof eventName === 'string') {
                // Return interface allowing to fire or unsubscribe from event
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
            add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
            if ((typeof eventName === 'undefined' ? 'undefined' : _typeof(eventName)) === 'object') return addConfiguredEvents(eventName);
            if (!chainFunction) chainFunction = reverseStoppableEventChain;
            if (!defaultFunction) defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function subscribe(cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function unsubscribe(cb) {
                    context.subscribers = context.subscribers.filter(function (fn) {
                        return fn !== cb;
                    });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            // events(this, {reading: [functionChain, nop]});
            keys(cfg).forEach(function (eventName) {
                var args = cfg[eventName];
                if (isArray(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                } else if (args === 'asap') {
                    // Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack
                    // enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.
                    var context = add(eventName, mirror, function fire() {
                        // Optimazation-safe cloning of arguments into args.
                        var i = arguments.length,
                            args = new Array(i);
                        while (i--) {
                            args[i] = arguments[i];
                        } // All each subscriber:
                        context.subscribers.forEach(function (fn) {
                            asap(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                } else throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }

    /*
     * Dexie.js - a minimalistic wrapper for IndexedDB
     * ===============================================
     *
     * Copyright (c) 2014-2017 David Fahlander
     *
     * Version 2.0.2, Thu Mar 01 2018
     *
     * http://dexie.org
     *
     * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0
     *
     */
    var DEXIE_VERSION = '2.0.2';
    var maxString = String.fromCharCode(65535);
    var maxKey = function () {
        try {
            IDBKeyRange.only([[]]);
            return [[]];
        } catch (e) {
            return maxString;
        }
    }();
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
    var hasIEDeleteObjectStoreBug = isIEOrEdge;
    var hangsOnDeleteLargeKeyRange = isIEOrEdge;
    var dexieStackFrameFilter = function dexieStackFrameFilter(frame) {
        return !/(dexie\.js|dexie\.min\.js)/.test(frame);
    };
    var dbNamesDB; // Global database for backing Dexie.getDatabaseNames() on browser without indexedDB.webkitGetDatabaseNames() 
    // Init debug
    setDebug(debug, dexieStackFrameFilter);
    function Dexie(dbName, options) {
        /// <param name="options" type="Object" optional="true">Specify only if you wich to control which addons that should run on this instance</param>
        var deps = Dexie.dependencies;
        var opts = extend({
            // Default Options
            addons: Dexie.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange // Backend IDBKeyRange api. Default to browser env.
        }, options);
        var addons = opts.addons,
            autoOpen = opts.autoOpen,
            indexedDB = opts.indexedDB,
            IDBKeyRange = opts.IDBKeyRange;
        var globalSchema = this._dbSchema = {};
        var versions = [];
        var dbStoreNames = [];
        var allTables = {};
        ///<var type="IDBDatabase" />
        var idbdb = null; // Instance of IDBDatabase
        var dbOpenError = null;
        var isBeingOpened = false;
        var onReadyBeingFired = null;
        var openComplete = false;
        var READONLY = "readonly",
            READWRITE = "readwrite";
        var db = this;
        var dbReadyResolve,
            dbReadyPromise = new Promise(function (resolve) {
            dbReadyResolve = resolve;
        }),
            cancelOpen,
            openCanceller = new Promise(function (_, reject) {
            cancelOpen = reject;
        });
        var autoSchema = true;
        var hasNativeGetDatabaseNames = !!getNativeGetDatabaseNamesFn(indexedDB),
            hasGetAll;
        function init() {
            // Default subscribers to "versionchange" and "blocked".
            // Can be overridden by custom handlers. If custom handlers return false, these default
            // behaviours will be prevented.
            db.on("versionchange", function (ev) {
                // Default behavior for versionchange event is to close database connection.
                // Caller can override this behavior by doing db.on("versionchange", function(){ return false; });
                // Let's not block the other window from making it's delete() or open() call.
                // NOTE! This event is never fired in IE,Edge or Safari.
                if (ev.newVersion > 0) console.warn("Another connection wants to upgrade database '" + db.name + "'. Closing db now to resume the upgrade.");else console.warn("Another connection wants to delete database '" + db.name + "'. Closing db now to resume the delete request.");
                db.close();
                // In many web applications, it would be recommended to force window.reload()
                // when this event occurs. To do that, subscribe to the versionchange event
                // and call window.location.reload(true) if ev.newVersion > 0 (not a deletion)
                // The reason for this is that your current web app obviously has old schema code that needs
                // to be updated. Another window got a newer version of the app and needs to upgrade DB but
                // your window is blocking it unless we close it here.
            });
            db.on("blocked", function (ev) {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn("Dexie.delete('" + db.name + "') was blocked");else console.warn("Upgrade '" + db.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
            });
        }
        //
        //
        //
        // ------------------------- Versioning Framework---------------------------
        //
        //
        //
        this.version = function (versionNumber) {
            /// <param name="versionNumber" type="Number"></param>
            /// <returns type="Version"></returns>
            if (idbdb || isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versionInstance = versions.filter(function (v) {
                return v._cfg.version === versionNumber;
            })[0];
            if (versionInstance) return versionInstance;
            versionInstance = new Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            // Disable autoschema mode, as at least one version is specified.
            autoSchema = false;
            return versionInstance;
        };
        function Version(versionNumber) {
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
            this.stores({}); // Derive earlier schemas by default.
        }
        extend(Version.prototype, {
            stores: function stores(_stores) {
                /// <summary>
                ///   Defines the schema for a particular version
                /// </summary>
                /// <param name="stores" type="Object">
                /// Example: <br/>
                ///   {users: "id++,first,last,&amp;username,*email", <br/>
                ///   passwords: "id++,&amp;username"}<br/>
                /// <br/>
                /// Syntax: {Table: "[primaryKey][++],[&amp;][*]index1,[&amp;][*]index2,..."}<br/><br/>
                /// Special characters:<br/>
                ///  "&amp;"  means unique key, <br/>
                ///  "*"  means value is multiEntry, <br/>
                ///  "++" means auto-increment and only applicable for primary key <br/>
                /// </param>
                this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, _stores) : _stores;
                // Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.
                var storesSpec = {};
                versions.forEach(function (version) {
                    extend(storesSpec, version._cfg.storesSource);
                });
                var dbschema = this._cfg.dbschema = {};
                this._parseStoresSpec(storesSpec, dbschema);
                // Update the latest schema to this version
                // Update API
                globalSchema = db._dbSchema = dbschema;
                removeTablesApi([allTables, db, Transaction.prototype]); // Keep Transaction.prototype even though it should be depr.
                setApiOnPlace([allTables, db, Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
                dbStoreNames = keys(dbschema);
                return this;
            },
            upgrade: function upgrade(upgradeFunction) {
                /// <param name="upgradeFunction" optional="true">Function that performs upgrading actions.</param>
                var self = this;
                this._cfg.contentUpgrade = upgradeFunction;
                return this;
            },
            _parseStoresSpec: function _parseStoresSpec(stores, outSchema) {
                keys(stores).forEach(function (tableName) {
                    if (stores[tableName] !== null) {
                        var instanceTemplate = {};
                        var indexes = parseIndexSyntax(stores[tableName]);
                        var primKey = indexes.shift();
                        if (primKey.multi) throw new exceptions.Schema("Primary key cannot be multi-valued");
                        if (primKey.keyPath) setByKeyPath(instanceTemplate, primKey.keyPath, primKey.auto ? 0 : primKey.keyPath);
                        indexes.forEach(function (idx) {
                            if (idx.auto) throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                            if (!idx.keyPath) throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                            setByKeyPath(instanceTemplate, idx.keyPath, idx.compound ? idx.keyPath.map(function () {
                                return "";
                            }) : "");
                        });
                        outSchema[tableName] = new TableSchema(tableName, primKey, indexes, instanceTemplate);
                    }
                });
            }
        });
        function runUpgraders(oldVersion, idbtrans, reject) {
            var trans = db._createTransaction(READWRITE, dbStoreNames, globalSchema);
            trans.create(idbtrans);
            trans._completion.catch(reject);
            var rejectTransaction = trans._reject.bind(trans);
            newScope(function () {
                PSD.trans = trans;
                if (oldVersion === 0) {
                    // Create tables:
                    keys(globalSchema).forEach(function (tableName) {
                        createTable(idbtrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                    });
                    Promise.follow(function () {
                        return db.on.populate.fire(trans);
                    }).catch(rejectTransaction);
                } else updateTablesAndIndexes(oldVersion, trans, idbtrans).catch(rejectTransaction);
            });
        }
        function updateTablesAndIndexes(oldVersion, trans, idbtrans) {
            // Upgrade version to version, step-by-step from oldest to newest version.
            // Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)
            var queue = [];
            var oldVersionStruct = versions.filter(function (version) {
                return version._cfg.version === oldVersion;
            })[0];
            if (!oldVersionStruct) throw new exceptions.Upgrade("Dexie specification of currently installed DB version is missing");
            globalSchema = db._dbSchema = oldVersionStruct._cfg.dbschema;
            var anyContentUpgraderHasRun = false;
            var versToRun = versions.filter(function (v) {
                return v._cfg.version > oldVersion;
            });
            versToRun.forEach(function (version) {
                /// <param name="version" type="Version"></param>
                queue.push(function () {
                    var oldSchema = globalSchema;
                    var newSchema = version._cfg.dbschema;
                    adjustToExistingIndexNames(oldSchema, idbtrans);
                    adjustToExistingIndexNames(newSchema, idbtrans);
                    globalSchema = db._dbSchema = newSchema;
                    var diff = getSchemaDiff(oldSchema, newSchema);
                    // Add tables           
                    diff.add.forEach(function (tuple) {
                        createTable(idbtrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                    });
                    // Change tables
                    diff.change.forEach(function (change) {
                        if (change.recreate) {
                            throw new exceptions.Upgrade("Not yet support for changing primary key");
                        } else {
                            var store = idbtrans.objectStore(change.name);
                            // Add indexes
                            change.add.forEach(function (idx) {
                                addIndex(store, idx);
                            });
                            // Update indexes
                            change.change.forEach(function (idx) {
                                store.deleteIndex(idx.name);
                                addIndex(store, idx);
                            });
                            // Delete indexes
                            change.del.forEach(function (idxName) {
                                store.deleteIndex(idxName);
                            });
                        }
                    });
                    if (version._cfg.contentUpgrade) {
                        anyContentUpgraderHasRun = true;
                        return Promise.follow(function () {
                            version._cfg.contentUpgrade(trans);
                        });
                    }
                });
                queue.push(function (idbtrans) {
                    if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                        var newSchema = version._cfg.dbschema;
                        // Delete old tables
                        deleteRemovedTables(newSchema, idbtrans);
                    }
                });
            });
            // Now, create a queue execution engine
            function runQueue() {
                return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : Promise.resolve();
            }
            return runQueue().then(function () {
                createMissingTables(globalSchema, idbtrans); // At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)
            });
        }
        function getSchemaDiff(oldSchema, newSchema) {
            var diff = {
                del: [],
                add: [],
                change: [] // Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}
            };
            for (var table in oldSchema) {
                if (!newSchema[table]) diff.del.push(table);
            }
            for (table in newSchema) {
                var oldDef = oldSchema[table],
                    newDef = newSchema[table];
                if (!oldDef) {
                    diff.add.push([table, newDef]);
                } else {
                    var change = {
                        name: table,
                        def: newDef,
                        recreate: false,
                        del: [],
                        add: [],
                        change: []
                    };
                    if (oldDef.primKey.src !== newDef.primKey.src) {
                        // Primary key has changed. Remove and re-add table.
                        change.recreate = true;
                        diff.change.push(change);
                    } else {
                        // Same primary key. Just find out what differs:
                        var oldIndexes = oldDef.idxByName;
                        var newIndexes = newDef.idxByName;
                        for (var idxName in oldIndexes) {
                            if (!newIndexes[idxName]) change.del.push(idxName);
                        }
                        for (idxName in newIndexes) {
                            var oldIdx = oldIndexes[idxName],
                                newIdx = newIndexes[idxName];
                            if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
                        }
                        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                            diff.change.push(change);
                        }
                    }
                }
            }
            return diff;
        }
        function createTable(idbtrans, tableName, primKey, indexes) {
            /// <param name="idbtrans" type="IDBTransaction"></param>
            var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
            indexes.forEach(function (idx) {
                addIndex(store, idx);
            });
            return store;
        }
        function createMissingTables(newSchema, idbtrans) {
            keys(newSchema).forEach(function (tableName) {
                if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                    createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
                }
            });
        }
        function deleteRemovedTables(newSchema, idbtrans) {
            for (var i = 0; i < idbtrans.db.objectStoreNames.length; ++i) {
                var storeName = idbtrans.db.objectStoreNames[i];
                if (newSchema[storeName] == null) {
                    idbtrans.db.deleteObjectStore(storeName);
                }
            }
        }
        function addIndex(store, idx) {
            store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
        }
        //
        //
        //      Dexie Protected API
        //
        //
        this._allTables = allTables;
        this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {
            return new Transaction(mode, storeNames, dbschema, parentTransaction);
        };
        /* Generate a temporary transaction when db operations are done outside a transaction scope.
        */
        function tempTransaction(mode, storeNames, fn) {
            if (!openComplete && !PSD.letThrough) {
                if (!isBeingOpened) {
                    if (!autoOpen) return rejection(new exceptions.DatabaseClosed());
                    db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.
                }
                return dbReadyPromise.then(function () {
                    return tempTransaction(mode, storeNames, fn);
                });
            } else {
                var trans = db._createTransaction(mode, storeNames, globalSchema);
                try {
                    trans.create();
                } catch (ex) {
                    return rejection(ex);
                }
                return trans._promise(mode, function (resolve, reject) {
                    return newScope(function () {
                        PSD.trans = trans;
                        return fn(resolve, reject, trans);
                    });
                }).then(function (result) {
                    // Instead of resolving value directly, wait with resolving it until transaction has completed.
                    // Otherwise the data would not be in the DB if requesting it in the then() operation.
                    // Specifically, to ensure that the following expression will work:
                    //
                    //   db.friends.put({name: "Arne"}).then(function () {
                    //       db.friends.where("name").equals("Arne").count(function(count) {
                    //           assert (count === 1);
                    //       });
                    //   });
                    //
                    return trans._completion.then(function () {
                        return result;
                    });
                }); /*.catch(err => { // Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.
                    trans._reject(err);
                    return rejection(err);
                    });*/
            }
        }
        this._whenReady = function (fn) {
            return openComplete || PSD.letThrough ? fn() : new Promise(function (resolve, reject) {
                if (!isBeingOpened) {
                    if (!autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.
                }
                dbReadyPromise.then(resolve, reject);
            }).then(fn);
        };
        //
        //
        //
        //
        //      Dexie API
        //
        //
        //
        this.verno = 0;
        this.open = function () {
            if (isBeingOpened || idbdb) return dbReadyPromise.then(function () {
                return dbOpenError ? rejection(dbOpenError) : db;
            });
            debug && (openCanceller._stackHolder = getErrorWithStack()); // Let stacks point to when open() was called rather than where new Dexie() was called.
            isBeingOpened = true;
            dbOpenError = null;
            openComplete = false;
            // Function pointers to call when the core opening process completes.
            var resolveDbReady = dbReadyResolve,

            // upgradeTransaction to abort on failure.
            upgradeTransaction = null;
            return Promise.race([openCanceller, new Promise(function (resolve, reject) {
                // Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:
                // IE fails when deleting objectStore after reading from it.
                // A future version of Dexie.js will stopover an intermediate version to workaround this.
                // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.
                // If no API, throw!
                if (!indexedDB) throw new exceptions.MissingAPI("indexedDB API not found. If using IE10+, make sure to run your code on a server URL " + "(not locally). If using old Safari versions, make sure to include indexedDB polyfill.");
                var req = autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));
                if (!req) throw new exceptions.MissingAPI("IndexedDB API not available"); // May happen in Safari private mode, see https://github.com/dfahlander/Dexie.js/issues/134
                req.onerror = eventRejectHandler(reject);
                req.onblocked = wrap(fireOnBlocked);
                req.onupgradeneeded = wrap(function (e) {
                    upgradeTransaction = req.transaction;
                    if (autoSchema && !db._allowEmptyDB) {
                        // Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.
                        // If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we
                        // do not create a new database by accident here.
                        req.onerror = preventDefault; // Prohibit onabort error from firing before we're done!
                        upgradeTransaction.abort(); // Abort transaction (would hope that this would make DB disappear but it doesnt.)
                        // Close database and delete it.
                        req.result.close();
                        var delreq = indexedDB.deleteDatabase(dbName); // The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!
                        delreq.onsuccess = delreq.onerror = wrap(function () {
                            reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
                        });
                    } else {
                        upgradeTransaction.onerror = eventRejectHandler(reject);
                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion; // Safari 8 fix.
                        runUpgraders(oldVer / 10, upgradeTransaction, reject, req);
                    }
                }, reject);
                req.onsuccess = wrap(function () {
                    // Core opening procedure complete. Now let's just record some stuff.
                    upgradeTransaction = null;
                    idbdb = req.result;
                    connections.push(db); // Used for emulating versionchange event on IE/Edge/Safari.
                    if (autoSchema) readGlobalSchema();else if (idbdb.objectStoreNames.length > 0) {
                        try {
                            adjustToExistingIndexNames(globalSchema, idbdb.transaction(safariMultiStoreFix(idbdb.objectStoreNames), READONLY));
                        } catch (e) {
                            // Safari may bail out if > 1 store names. However, this shouldnt be a showstopper. Issue #120.
                        }
                    }
                    idbdb.onversionchange = wrap(function (ev) {
                        db._vcFired = true; // detect implementations that not support versionchange (IE/Edge/Safari)
                        db.on("versionchange").fire(ev);
                    });
                    if (!hasNativeGetDatabaseNames && dbName !== '__dbnames') {
                        dbNamesDB.dbnames.put({ name: dbName }).catch(nop);
                    }
                    resolve();
                }, reject);
            })]).then(function () {
                // Before finally resolving the dbReadyPromise and this promise,
                // call and await all on('ready') subscribers:
                // Dexie.vip() makes subscribers able to use the database while being opened.
                // This is a must since these subscribers take part of the opening procedure.
                onReadyBeingFired = [];
                return Promise.resolve(Dexie.vip(db.on.ready.fire)).then(function fireRemainders() {
                    if (onReadyBeingFired.length > 0) {
                        // In case additional subscribers to db.on('ready') were added during the time db.on.ready.fire was executed.
                        var remainders = onReadyBeingFired.reduce(promisableChain, nop);
                        onReadyBeingFired = [];
                        return Promise.resolve(Dexie.vip(remainders)).then(fireRemainders);
                    }
                });
            }).finally(function () {
                onReadyBeingFired = null;
            }).then(function () {
                // Resolve the db.open() with the db instance.
                isBeingOpened = false;
                return db;
            }).catch(function (err) {
                try {
                    // Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.
                    upgradeTransaction && upgradeTransaction.abort();
                } catch (e) {}
                isBeingOpened = false; // Set before calling db.close() so that it doesnt reject openCanceller again (leads to unhandled rejection event).
                db.close(); // Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.
                // A call to db.close() may have made on-ready subscribers fail. Use dbOpenError if set, since err could be a follow-up error on that.
                dbOpenError = err; // Record the error. It will be used to reject further promises of db operations.
                return rejection(dbOpenError);
            }).finally(function () {
                openComplete = true;
                resolveDbReady(); // dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.
            });
        };
        this.close = function () {
            var idx = connections.indexOf(db);
            if (idx >= 0) connections.splice(idx, 1);
            if (idbdb) {
                try {
                    idbdb.close();
                } catch (e) {}
                idbdb = null;
            }
            autoOpen = false;
            dbOpenError = new exceptions.DatabaseClosed();
            if (isBeingOpened) cancelOpen(dbOpenError);
            // Reset dbReadyPromise promise:
            dbReadyPromise = new Promise(function (resolve) {
                dbReadyResolve = resolve;
            });
            openCanceller = new Promise(function (_, reject) {
                cancelOpen = reject;
            });
        };
        this.delete = function () {
            var hasArguments = arguments.length > 0;
            return new Promise(function (resolve, reject) {
                if (hasArguments) throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
                if (isBeingOpened) {
                    dbReadyPromise.then(doDelete);
                } else {
                    doDelete();
                }
                function doDelete() {
                    db.close();
                    var req = indexedDB.deleteDatabase(dbName);
                    req.onsuccess = wrap(function () {
                        if (!hasNativeGetDatabaseNames) {
                            dbNamesDB.dbnames.delete(dbName).catch(nop);
                        }
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = fireOnBlocked;
                }
            });
        };
        this.backendDB = function () {
            return idbdb;
        };
        this.isOpen = function () {
            return idbdb !== null;
        };
        this.hasBeenClosed = function () {
            return dbOpenError && dbOpenError instanceof exceptions.DatabaseClosed;
        };
        this.hasFailed = function () {
            return dbOpenError !== null;
        };
        this.dynamicallyOpened = function () {
            return autoSchema;
        };
        //
        // Properties
        //
        this.name = dbName;
        // db.tables - an array of all Table instances.
        props(this, {
            tables: {
                get: function get() {
                    /// <returns type="Array" elementType="Table" />
                    return keys(allTables).map(function (name) {
                        return allTables[name];
                    });
                }
            }
        });
        //
        // Events
        //
        this.on = Events(this, "populate", "blocked", "versionchange", { ready: [promisableChain, nop] });
        this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
            return function (subscriber, bSticky) {
                Dexie.vip(function () {
                    if (openComplete) {
                        // Database already open. Call subscriber asap.
                        if (!dbOpenError) Promise.resolve().then(subscriber);
                        // bSticky: Also subscribe to future open sucesses (after close / reopen) 
                        if (bSticky) subscribe(subscriber);
                    } else if (onReadyBeingFired) {
                        // db.on('ready') subscribers are currently being executed and have not yet resolved or rejected
                        onReadyBeingFired.push(subscriber);
                        if (bSticky) subscribe(subscriber);
                    } else {
                        // Database not yet open. Subscribe to it.
                        subscribe(subscriber);
                        // If bSticky is falsy, make sure to unsubscribe subscriber when fired once.
                        if (!bSticky) subscribe(function unsubscribe() {
                            db.on.ready.unsubscribe(subscriber);
                            db.on.ready.unsubscribe(unsubscribe);
                        });
                    }
                });
            };
        });
        this.transaction = function () {
            /// <summary>
            ///
            /// </summary>
            /// <param name="mode" type="String">"r" for readonly, or "rw" for readwrite</param>
            /// <param name="tableInstances">Table instance, Array of Table instances, String or String Array of object stores to include in the transaction</param>
            /// <param name="scopeFunc" type="Function">Function to execute with transaction</param>
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        };
        function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
            // Let table arguments be all arguments between mode and last argument.
            var i = arguments.length;
            if (i < 2) throw new exceptions.InvalidArgument("Too few arguments");
            // Prevent optimzation killer (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments)
            // and clone arguments except the first one into local var 'args'.
            var args = new Array(i - 1);
            while (--i) {
                args[i - 1] = arguments[i];
            } // Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.
            scopeFunc = args.pop();
            var tables = flatten(args); // Support using array as middle argument, or a mix of arrays and non-arrays.
            return [mode, tables, scopeFunc];
        }
        this._transaction = function (mode, tables, scopeFunc) {
            var parentTransaction = PSD.trans;
            // Check if parent transactions is bound to this db instance, and if caller wants to reuse it
            if (!parentTransaction || parentTransaction.db !== db || mode.indexOf('!') !== -1) parentTransaction = null;
            var onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', ''); // Ok. Will change arguments[0] as well but we wont touch arguments henceforth.
            try {
                //
                // Get storeNames from arguments. Either through given table instances, or through given table names.
                //
                var storeNames = tables.map(function (table) {
                    var storeName = table instanceof Table ? table.name : table;
                    if (typeof storeName !== 'string') throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                //
                // Resolve mode. Allow shortcuts "r" and "rw".
                //
                if (mode == "r" || mode == READONLY) mode = READONLY;else if (mode == "rw" || mode == READWRITE) mode = READWRITE;else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    // Basic checks
                    if (parentTransaction.mode === READONLY && mode === READWRITE) {
                        if (onlyIfCompatible) {
                            // Spawn new transaction instead.
                            parentTransaction = null;
                        } else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(function (storeName) {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    // Spawn new transaction instead.
                                    parentTransaction = null;
                                } else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        // '?' mode should not keep using an inactive transaction.
                        parentTransaction = null;
                    }
                }
            } catch (e) {
                return parentTransaction ? parentTransaction._promise(null, function (_, reject) {
                    reject(e);
                }) : rejection(e);
            }
            // If this is a sub-transaction, lock the parent and then launch the sub-transaction.
            return parentTransaction ? parentTransaction._promise(mode, enterTransactionScope, "lock") : PSD.trans ?
            // no parent transaction despite PSD.trans exists. Make sure also
            // that the zone we create is not a sub-zone of current, because
            // Promise.follow() should not wait for it if so.
            usePSD(PSD.transless, function () {
                return db._whenReady(enterTransactionScope);
            }) : db._whenReady(enterTransactionScope);
            function enterTransactionScope() {
                return Promise.resolve().then(function () {
                    // Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().
                    var transless = PSD.transless || PSD;
                    // Our transaction.
                    //return new Promise((resolve, reject) => {
                    var trans = db._createTransaction(mode, storeNames, globalSchema, parentTransaction);
                    // Let the transaction instance be part of a Promise-specific data (PSD) value.
                    var zoneProps = {
                        trans: trans,
                        transless: transless
                    };
                    if (parentTransaction) {
                        // Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)
                        trans.idbtrans = parentTransaction.idbtrans;
                    } else {
                        trans.create(); // Create the backend transaction so that complete() or error() will trigger even if no operation is made upon it.
                    }
                    // Support for native async await.
                    if (scopeFunc.constructor === AsyncFunction) {
                        incrementExpectedAwaits();
                    }
                    var returnValue;
                    var promiseFollowed = Promise.follow(function () {
                        // Finally, call the scope function with our table and transaction arguments.
                        returnValue = scopeFunc.call(trans, trans);
                        if (returnValue) {
                            if (returnValue.constructor === NativePromise) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue.then(decrementor, decrementor);
                            } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                                // scopeFunc returned an iterator with throw-support. Handle yield as await.
                                returnValue = awaitIterator(returnValue);
                            }
                        }
                    }, zoneProps);
                    return (returnValue && typeof returnValue.then === 'function' ?
                    // Promise returned. User uses promise-style transactions.
                    Promise.resolve(returnValue).then(function (x) {
                        return trans.active ? x // Transaction still active. Continue.
                        : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
                    })
                    // No promise returned. Wait for all outstanding promises before continuing. 
                    : promiseFollowed.then(function () {
                        return returnValue;
                    })).then(function (x) {
                        // sub transactions don't react to idbtrans.oncomplete. We must trigger a completion:
                        if (parentTransaction) trans._resolve();
                        // wait for trans._completion
                        // (if root transaction, this means 'complete' event. If sub-transaction, we've just fired it ourselves)
                        return trans._completion.then(function () {
                            return x;
                        });
                    }).catch(function (e) {
                        trans._reject(e); // Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!
                        return rejection(e);
                    });
                });
            }
        };
        this.table = function (tableName) {
            /// <returns type="Table"></returns>
            if (!hasOwn(allTables, tableName)) {
                throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
            }
            return allTables[tableName];
        };
        //
        //
        //
        // Table Class
        //
        //
        //
        function Table(name, tableSchema, optionalTrans) {
            /// <param name="name" type="String"></param>
            this.name = name;
            this.schema = tableSchema;
            this._tx = optionalTrans;
            this.hook = allTables[name] ? allTables[name].hook : Events(null, {
                "creating": [hookCreatingChain, nop],
                "reading": [pureFunctionChain, mirror],
                "updating": [hookUpdatingChain, nop],
                "deleting": [hookDeletingChain, nop]
            });
        }
        function BulkErrorHandlerCatchAll(errorList, done, supportHooks) {
            return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(function (e) {
                errorList.push(e);
                done && done();
            });
        }
        function _bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook) {
            // If hasDeleteHook, keysOrTuples must be an array of tuples: [[key1, value2],[key2,value2],...],
            // else keysOrTuples must be just an array of keys: [key1, key2, ...].
            return new Promise(function (resolve, reject) {
                var len = keysOrTuples.length,
                    lastItem = len - 1;
                if (len === 0) return resolve();
                if (!hasDeleteHook) {
                    for (var i = 0; i < len; ++i) {
                        var req = idbstore.delete(keysOrTuples[i]);
                        req.onerror = eventRejectHandler(reject);
                        if (i === lastItem) req.onsuccess = wrap(function () {
                            return resolve();
                        });
                    }
                } else {
                    var hookCtx,
                        errorHandler = hookedEventRejectHandler(reject),
                        successHandler = hookedEventSuccessHandler(null);
                    tryCatch(function () {
                        for (var i = 0; i < len; ++i) {
                            hookCtx = { onsuccess: null, onerror: null };
                            var tuple = keysOrTuples[i];
                            deletingHook.call(hookCtx, tuple[0], tuple[1], trans);
                            var req = idbstore.delete(tuple[0]);
                            req._hookCtx = hookCtx;
                            req.onerror = errorHandler;
                            if (i === lastItem) req.onsuccess = hookedEventSuccessHandler(resolve);else req.onsuccess = successHandler;
                        }
                    }, function (err) {
                        hookCtx.onerror && hookCtx.onerror(err);
                        throw err;
                    });
                }
            });
        }
        props(Table.prototype, {
            //
            // Table Protected Methods
            //
            _trans: function getTransaction(mode, fn, writeLocked) {
                var trans = this._tx || PSD.trans;
                return trans && trans.db === db ? trans === PSD.trans ? trans._promise(mode, fn, writeLocked) : newScope(function () {
                    return trans._promise(mode, fn, writeLocked);
                }, { trans: trans, transless: PSD.transless || PSD }) : tempTransaction(mode, [this.name], fn);
            },
            _idbstore: function getIDBObjectStore(mode, fn, writeLocked) {
                var tableName = this.name;
                function supplyIdbStore(resolve, reject, trans) {
                    if (trans.storeNames.indexOf(tableName) === -1) throw new exceptions.NotFound("Table" + tableName + " not part of transaction");
                    return fn(resolve, reject, trans.idbtrans.objectStore(tableName), trans);
                }
                return this._trans(mode, supplyIdbStore, writeLocked);
            },
            //
            // Table Public Methods
            //
            get: function get(keyOrCrit, cb) {
                if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);
                var self = this;
                return this._idbstore(READONLY, function (resolve, reject, idbstore) {
                    var req = idbstore.get(keyOrCrit);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(function () {
                        resolve(self.hook.reading.fire(req.result));
                    }, reject);
                }).then(cb);
            },
            where: function where(indexOrCrit) {
                if (typeof indexOrCrit === 'string') return new WhereClause(this, indexOrCrit);
                if (isArray(indexOrCrit)) return new WhereClause(this, "[" + indexOrCrit.join('+') + "]");
                // indexOrCrit is an object map of {[keyPath]:value} 
                var keyPaths = keys(indexOrCrit);
                if (keyPaths.length === 1)
                    // Only one critera. This was the easy case:
                    return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
                // Multiple criterias.
                // Let's try finding a compound index that matches all keyPaths in
                // arbritary order:
                var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
                    return ix.compound && keyPaths.every(function (keyPath) {
                        return ix.keyPath.indexOf(keyPath) >= 0;
                    }) && ix.keyPath.every(function (keyPath) {
                        return keyPaths.indexOf(keyPath) >= 0;
                    });
                })[0];
                if (compoundIndex && maxKey !== maxString)
                    // Cool! We found such compound index
                    // and this browser supports compound indexes (maxKey !== maxString)!
                    return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function (kp) {
                        return indexOrCrit[kp];
                    }));
                if (!compoundIndex) console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " + ("compound index [" + keyPaths.join('+') + "]"));
                // Ok, now let's fallback to finding at least one matching index
                // and filter the rest.
                var idxByName = this.schema.idxByName;
                var simpleIndex = keyPaths.reduce(function (r, keyPath) {
                    return [r[0] || idxByName[keyPath], r[0] || !idxByName[keyPath] ? combine(r[1], function (x) {
                        return '' + getByKeyPath(x, keyPath) == '' + indexOrCrit[keyPath];
                    }) : r[1]];
                }, [null, null]);
                var idx = simpleIndex[0];
                return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(simpleIndex[1]) : compoundIndex ? this.filter(simpleIndex[1]) : // Has compound but browser bad. Allow filter.
                this.where(keyPaths).equals(''); // No index at all. Fail lazily.
            },
            count: function count(cb) {
                return this.toCollection().count(cb);
            },
            offset: function offset(_offset) {
                return this.toCollection().offset(_offset);
            },
            limit: function limit(numRows) {
                return this.toCollection().limit(numRows);
            },
            reverse: function reverse() {
                return this.toCollection().reverse();
            },
            filter: function filter(filterFunction) {
                return this.toCollection().and(filterFunction);
            },
            each: function each(fn) {
                return this.toCollection().each(fn);
            },
            toArray: function toArray(cb) {
                return this.toCollection().toArray(cb);
            },
            orderBy: function orderBy(index) {
                return new Collection(new WhereClause(this, isArray(index) ? "[" + index.join('+') + "]" : index));
            },
            toCollection: function toCollection() {
                return new Collection(new WhereClause(this));
            },
            mapToClass: function mapToClass(constructor, structure) {
                /// <summary>
                ///     Map table to a javascript constructor function. Objects returned from the database will be instances of this class, making
                ///     it possible to the instanceOf operator as well as extending the class using constructor.prototype.method = function(){...}.
                /// </summary>
                /// <param name="constructor">Constructor function representing the class.</param>
                /// <param name="structure" optional="true">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
                /// know what type each member has. Example: {name: String, emailAddresses: [String], password}</param>
                this.schema.mappedClass = constructor;
                var instanceTemplate = Object.create(constructor.prototype);
                if (structure) {
                    // structure and instanceTemplate is for IDE code competion only while constructor.prototype is for actual inheritance.
                    applyStructure(instanceTemplate, structure);
                }
                this.schema.instanceTemplate = instanceTemplate;
                // Now, subscribe to the when("reading") event to make all objects that come out from this table inherit from given class
                // no matter which method to use for reading (Table.get() or Table.where(...)... )
                var readHook = function readHook(obj) {
                    if (!obj) return obj; // No valid object. (Value is null). Return as is.
                    // Create a new object that derives from constructor:
                    var res = Object.create(constructor.prototype);
                    // Clone members:
                    for (var m in obj) {
                        if (hasOwn(obj, m)) try {
                            res[m] = obj[m];
                        } catch (_) {}
                    }return res;
                };
                if (this.schema.readHook) {
                    this.hook.reading.unsubscribe(this.schema.readHook);
                }
                this.schema.readHook = readHook;
                this.hook("reading", readHook);
                return constructor;
            },
            defineClass: function defineClass(structure) {
                /// <summary>
                ///     Define all members of the class that represents the table. This will help code completion of when objects are read from the database
                ///     as well as making it possible to extend the prototype of the returned constructor function.
                /// </summary>
                /// <param name="structure">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
                /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>
                return this.mapToClass(Dexie.defineClass(structure), structure);
            },
            bulkDelete: function bulkDelete(keys$$1) {
                if (this.hook.deleting.fire === nop) {
                    return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
                        resolve(_bulkDelete(idbstore, trans, keys$$1, false, nop));
                    });
                } else {
                    return this.where(':id').anyOf(keys$$1).delete().then(function () {}); // Resolve with undefined.
                }
            },
            bulkPut: function bulkPut(objects, keys$$1) {
                var _this = this;
                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                    if (!idbstore.keyPath && !_this.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument("bulkPut() with non-inbound keys requires keys array in second argument");
                    if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                    if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                    if (objects.length === 0) return resolve(); // Caller provided empty list.
                    var done = function done(result) {
                        if (errorList.length === 0) resolve(result);else reject(new BulkError(_this.name + ".bulkPut(): " + errorList.length + " of " + numObjs + " operations failed", errorList));
                    };
                    var req,
                        errorList = [],
                        errorHandler,
                        numObjs = objects.length,
                        table = _this;
                    if (_this.hook.creating.fire === nop && _this.hook.updating.fire === nop) {
                        //
                        // Standard Bulk (no 'creating' or 'updating' hooks to care about)
                        //
                        errorHandler = BulkErrorHandlerCatchAll(errorList);
                        for (var i = 0, l = objects.length; i < l; ++i) {
                            req = keys$$1 ? idbstore.put(objects[i], keys$$1[i]) : idbstore.put(objects[i]);
                            req.onerror = errorHandler;
                        }
                        // Only need to catch success or error on the last operation
                        // according to the IDB spec.
                        req.onerror = BulkErrorHandlerCatchAll(errorList, done);
                        req.onsuccess = eventSuccessHandler(done);
                    } else {
                        var effectiveKeys = keys$$1 || idbstore.keyPath && objects.map(function (o) {
                            return getByKeyPath(o, idbstore.keyPath);
                        });
                        // Generate map of {[key]: object}
                        var objectLookup = effectiveKeys && arrayToObject(effectiveKeys, function (key, i) {
                            return key != null && [key, objects[i]];
                        });
                        var promise = !effectiveKeys ?
                        // Auto-incremented key-less objects only without any keys argument.
                        table.bulkAdd(objects) :
                        // Keys provided. Either as inbound in provided objects, or as a keys argument.
                        // Begin with updating those that exists in DB:
                        table.where(':id').anyOf(effectiveKeys.filter(function (key) {
                            return key != null;
                        })).modify(function () {
                            this.value = objectLookup[this.primKey];
                            objectLookup[this.primKey] = null; // Mark as "don't add this"
                        }).catch(ModifyError, function (e) {
                            errorList = e.failures; // No need to concat here. These are the first errors added.
                        }).then(function () {
                            // Now, let's examine which items didnt exist so we can add them:
                            var objsToAdd = [],
                                keysToAdd = keys$$1 && [];
                            // Iterate backwards. Why? Because if same key was used twice, just add the last one.
                            for (var i = effectiveKeys.length - 1; i >= 0; --i) {
                                var key = effectiveKeys[i];
                                if (key == null || objectLookup[key]) {
                                    objsToAdd.push(objects[i]);
                                    keys$$1 && keysToAdd.push(key);
                                    if (key != null) objectLookup[key] = null; // Mark as "dont add again"
                                }
                            }
                            // The items are in reverse order so reverse them before adding.
                            // Could be important in order to get auto-incremented keys the way the caller
                            // would expect. Could have used unshift instead of push()/reverse(),
                            // but: http://jsperf.com/unshift-vs-reverse
                            objsToAdd.reverse();
                            keys$$1 && keysToAdd.reverse();
                            return table.bulkAdd(objsToAdd, keysToAdd);
                        }).then(function (lastAddedKey) {
                            // Resolve with key of the last object in given arguments to bulkPut():
                            var lastEffectiveKey = effectiveKeys[effectiveKeys.length - 1]; // Key was provided.
                            return lastEffectiveKey != null ? lastEffectiveKey : lastAddedKey;
                        });
                        promise.then(done).catch(BulkError, function (e) {
                            // Concat failure from ModifyError and reject using our 'done' method.
                            errorList = errorList.concat(e.failures);
                            done();
                        }).catch(reject);
                    }
                }, "locked"); // If called from transaction scope, lock transaction til all steps are done.
            },
            bulkAdd: function bulkAdd(objects, keys$$1) {
                var self = this,
                    creatingHook = this.hook.creating.fire;
                return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
                    if (!idbstore.keyPath && !self.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument("bulkAdd() with non-inbound keys requires keys array in second argument");
                    if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                    if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                    if (objects.length === 0) return resolve(); // Caller provided empty list.
                    function done(result) {
                        if (errorList.length === 0) resolve(result);else reject(new BulkError(self.name + ".bulkAdd(): " + errorList.length + " of " + numObjs + " operations failed", errorList));
                    }
                    var req,
                        errorList = [],
                        errorHandler,
                        successHandler,
                        numObjs = objects.length;
                    if (creatingHook !== nop) {
                        //
                        // There are subscribers to hook('creating')
                        // Must behave as documented.
                        //
                        var keyPath = idbstore.keyPath,
                            hookCtx;
                        errorHandler = BulkErrorHandlerCatchAll(errorList, null, true);
                        successHandler = hookedEventSuccessHandler(null);
                        tryCatch(function () {
                            for (var i = 0, l = objects.length; i < l; ++i) {
                                hookCtx = { onerror: null, onsuccess: null };
                                var key = keys$$1 && keys$$1[i];
                                var obj = objects[i],
                                    effectiveKey = keys$$1 ? key : keyPath ? getByKeyPath(obj, keyPath) : undefined,
                                    keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans);
                                if (effectiveKey == null && keyToUse != null) {
                                    if (keyPath) {
                                        obj = deepClone(obj);
                                        setByKeyPath(obj, keyPath, keyToUse);
                                    } else {
                                        key = keyToUse;
                                    }
                                }
                                req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);
                                req._hookCtx = hookCtx;
                                if (i < l - 1) {
                                    req.onerror = errorHandler;
                                    if (hookCtx.onsuccess) req.onsuccess = successHandler;
                                }
                            }
                        }, function (err) {
                            hookCtx.onerror && hookCtx.onerror(err);
                            throw err;
                        });
                        req.onerror = BulkErrorHandlerCatchAll(errorList, done, true);
                        req.onsuccess = hookedEventSuccessHandler(done);
                    } else {
                        //
                        // Standard Bulk (no 'creating' hook to care about)
                        //
                        errorHandler = BulkErrorHandlerCatchAll(errorList);
                        for (var i = 0, l = objects.length; i < l; ++i) {
                            req = keys$$1 ? idbstore.add(objects[i], keys$$1[i]) : idbstore.add(objects[i]);
                            req.onerror = errorHandler;
                        }
                        // Only need to catch success or error on the last operation
                        // according to the IDB spec.
                        req.onerror = BulkErrorHandlerCatchAll(errorList, done);
                        req.onsuccess = eventSuccessHandler(done);
                    }
                });
            },
            add: function add(obj, key) {
                /// <summary>
                ///   Add an object to the database. In case an object with same primary key already exists, the object will not be added.
                /// </summary>
                /// <param name="obj" type="Object">A javascript object to insert</param>
                /// <param name="key" optional="true">Primary key</param>
                var creatingHook = this.hook.creating.fire;
                return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
                    var hookCtx = { onsuccess: null, onerror: null };
                    if (creatingHook !== nop) {
                        var effectiveKey = key != null ? key : idbstore.keyPath ? getByKeyPath(obj, idbstore.keyPath) : undefined;
                        var keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans); // Allow subscribers to when("creating") to generate the key.
                        if (effectiveKey == null && keyToUse != null) {
                            if (idbstore.keyPath) setByKeyPath(obj, idbstore.keyPath, keyToUse);else key = keyToUse;
                        }
                    }
                    try {
                        var req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);
                        req._hookCtx = hookCtx;
                        req.onerror = hookedEventRejectHandler(reject);
                        req.onsuccess = hookedEventSuccessHandler(function (result) {
                            // TODO: Remove these two lines in next major release (2.0?)
                            // It's no good practice to have side effects on provided parameters
                            var keyPath = idbstore.keyPath;
                            if (keyPath) setByKeyPath(obj, keyPath, result);
                            resolve(result);
                        });
                    } catch (e) {
                        if (hookCtx.onerror) hookCtx.onerror(e);
                        throw e;
                    }
                });
            },
            put: function put(obj, key) {
                var _this = this;
                /// <summary>
                ///   Add an object to the database but in case an object with same primary key alread exists, the existing one will get updated.
                /// </summary>
                /// <param name="obj" type="Object">A javascript object to insert or update</param>
                /// <param name="key" optional="true">Primary key</param>
                var creatingHook = this.hook.creating.fire,
                    updatingHook = this.hook.updating.fire;
                if (creatingHook !== nop || updatingHook !== nop) {
                    //
                    // People listens to when("creating") or when("updating") events!
                    // We must know whether the put operation results in an CREATE or UPDATE.
                    //
                    var keyPath = this.schema.primKey.keyPath;
                    var effectiveKey = key !== undefined ? key : keyPath && getByKeyPath(obj, keyPath);
                    if (effectiveKey == null) return this.add(obj);
                    // Since key is optional, make sure we get it from obj if not provided
                    // Primary key exist. Lock transaction and try modifying existing. If nothing modified, call add().
                    // clone obj before this async call. If caller modifies obj the line after put(), the IDB spec requires that it should not affect operation.
                    obj = deepClone(obj);
                    return this._trans(READWRITE, function () {
                        return _this.where(":id").equals(effectiveKey).modify(function () {
                            // Replace extisting value with our object
                            // CRUD event firing handled in Collection.modify()
                            this.value = obj;
                        }).then(function (count) {
                            return count === 0 ? _this.add(obj, key) : effectiveKey;
                        });
                    }, "locked"); // Lock needed because operation is splitted into modify() and add().
                } else {
                    // Use the standard IDB put() method.
                    return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                        var req = key !== undefined ? idbstore.put(obj, key) : idbstore.put(obj);
                        req.onerror = eventRejectHandler(reject);
                        req.onsuccess = wrap(function (ev) {
                            var keyPath = idbstore.keyPath;
                            if (keyPath) setByKeyPath(obj, keyPath, ev.target.result);
                            resolve(req.result);
                        });
                    });
                }
            },
            'delete': function _delete(key) {
                /// <param name="key">Primary key of the object to delete</param>
                if (this.hook.deleting.subscribers.length) {
                    // People listens to when("deleting") event. Must implement delete using Collection.delete() that will
                    // call the CRUD event. Only Collection.delete() will know whether an object was actually deleted.
                    return this.where(":id").equals(key).delete();
                } else {
                    // No one listens. Use standard IDB delete() method.
                    return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                        var req = idbstore.delete(key);
                        req.onerror = eventRejectHandler(reject);
                        req.onsuccess = wrap(function () {
                            resolve(req.result);
                        });
                    });
                }
            },
            clear: function clear() {
                if (this.hook.deleting.subscribers.length) {
                    // People listens to when("deleting") event. Must implement delete using Collection.delete() that will
                    // call the CRUD event. Only Collection.delete() will knows which objects that are actually deleted.
                    return this.toCollection().delete();
                } else {
                    return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                        var req = idbstore.clear();
                        req.onerror = eventRejectHandler(reject);
                        req.onsuccess = wrap(function () {
                            resolve(req.result);
                        });
                    });
                }
            },
            update: function update(keyOrObject, modifications) {
                if ((typeof modifications === 'undefined' ? 'undefined' : _typeof(modifications)) !== 'object' || isArray(modifications)) throw new exceptions.InvalidArgument("Modifications must be an object.");
                if ((typeof keyOrObject === 'undefined' ? 'undefined' : _typeof(keyOrObject)) === 'object' && !isArray(keyOrObject)) {
                    // object to modify. Also modify given object with the modifications:
                    keys(modifications).forEach(function (keyPath) {
                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                    });
                    var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                    if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                    return this.where(":id").equals(key).modify(modifications);
                } else {
                    // key to modify
                    return this.where(":id").equals(keyOrObject).modify(modifications);
                }
            }
        });
        //
        //
        //
        // Transaction Class
        //
        //
        //
        function Transaction(mode, storeNames, dbschema, parent) {
            var _this = this;
            /// <summary>
            ///    Transaction class. Represents a database transaction. All operations on db goes through a Transaction.
            /// </summary>
            /// <param name="mode" type="String">Any of "readwrite" or "readonly"</param>
            /// <param name="storeNames" type="Array">Array of table names to operate on</param>
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0; // Just for debugging waitFor()
            this._completion = new Promise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
            });
            this._completion.then(function () {
                _this.active = false;
                _this.on.complete.fire();
            }, function (e) {
                var wasActive = _this.active;
                _this.active = false;
                _this.on.error.fire(e);
                _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
                return rejection(e); // Indicate we actually DO NOT catch this error.
            });
        }
        props(Transaction.prototype, {
            //
            // Transaction Protected Methods (not required by API users, but needed internally and eventually by dexie extensions)
            //
            _lock: function _lock() {
                assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.
                // Temporary set all requests into a pending queue if they are called before database is ready.
                ++this._reculock; // Recursive read/write lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)
                if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
                return this;
            },
            _unlock: function _unlock() {
                assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.
                if (--this._reculock === 0) {
                    if (!PSD.global) PSD.lockOwnerFor = null;
                    while (this._blockedFuncs.length > 0 && !this._locked()) {
                        var fnAndPSD = this._blockedFuncs.shift();
                        try {
                            usePSD(fnAndPSD[1], fnAndPSD[0]);
                        } catch (e) {}
                    }
                }
                return this;
            },
            _locked: function _locked() {
                // Checks if any write-lock is applied on this transaction.
                // To simplify the Dexie API for extension implementations, we support recursive locks.
                // This is accomplished by using "Promise Specific Data" (PSD).
                // PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).
                // PSD is local to code executing on top of the call stacks of any of any code executed by Promise():
                //         * callback given to the Promise() constructor  (function (resolve, reject){...})
                //         * callbacks given to then()/catch()/finally() methods (function (value){...})
                // If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.
                // Derivation is done so that the inner PSD __proto__ points to the outer PSD.
                // PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.
                return this._reculock && PSD.lockOwnerFor !== this;
            },
            create: function create(idbtrans) {
                var _this = this;
                if (!this.mode) return this;
                assert(!this.idbtrans);
                if (!idbtrans && !idbdb) {
                    switch (dbOpenError && dbOpenError.name) {
                        case "DatabaseClosedError":
                            // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()
                            throw new exceptions.DatabaseClosed(dbOpenError);
                        case "MissingAPIError":
                            // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()
                            throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                        default:
                            // Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!
                            throw new exceptions.OpenFailed(dbOpenError);
                    }
                }
                if (!this.active) throw new exceptions.TransactionInactive();
                assert(this._completion._state === null);
                idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);
                idbtrans.onerror = wrap(function (ev) {
                    preventDefault(ev); // Prohibit default bubbling to window.error
                    _this._reject(idbtrans.error);
                });
                idbtrans.onabort = wrap(function (ev) {
                    preventDefault(ev);
                    _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                    _this.active = false;
                    _this.on("abort").fire(ev);
                });
                idbtrans.oncomplete = wrap(function () {
                    _this.active = false;
                    _this._resolve();
                });
                return this;
            },
            _promise: function _promise(mode, fn, bWriteLock) {
                var _this = this;
                if (mode === READWRITE && this.mode !== READWRITE) return rejection(new exceptions.ReadOnly("Transaction is readonly"));
                if (!this.active) return rejection(new exceptions.TransactionInactive());
                if (this._locked()) {
                    return new Promise(function (resolve, reject) {
                        _this._blockedFuncs.push([function () {
                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        }, PSD]);
                    });
                } else if (bWriteLock) {
                    return newScope(function () {
                        var p = new Promise(function (resolve, reject) {
                            _this._lock();
                            var rv = fn(resolve, reject, _this);
                            if (rv && rv.then) rv.then(resolve, reject);
                        });
                        p.finally(function () {
                            return _this._unlock();
                        });
                        p._lib = true;
                        return p;
                    });
                } else {
                    var p = new Promise(function (resolve, reject) {
                        var rv = fn(resolve, reject, _this);
                        if (rv && rv.then) rv.then(resolve, reject);
                    });
                    p._lib = true;
                    return p;
                }
            },
            _root: function _root() {
                return this.parent ? this.parent._root() : this;
            },
            waitFor: function waitFor(promise) {
                // Always operate on the root transaction (in case this is a sub stransaction)
                var root = this._root();
                // For stability reasons, convert parameter to promise no matter what type is passed to waitFor().
                // (We must be able to call .then() on it.)
                promise = Promise.resolve(promise);
                if (root._waitingFor) {
                    // Already called waitFor(). Wait for both to complete.
                    root._waitingFor = root._waitingFor.then(function () {
                        return promise;
                    });
                } else {
                    // We're not in waiting state. Start waiting state.
                    root._waitingFor = promise;
                    root._waitingQueue = [];
                    // Start interacting with indexedDB until promise completes:
                    var store = root.idbtrans.objectStore(root.storeNames[0]);
                    (function spin() {
                        ++root._spinCount; // For debugging only
                        while (root._waitingQueue.length) {
                            root._waitingQueue.shift()();
                        }if (root._waitingFor) store.get(-Infinity).onsuccess = spin;
                    })();
                }
                var currentWaitPromise = root._waitingFor;
                return new Promise(function (resolve, reject) {
                    promise.then(function (res) {
                        return root._waitingQueue.push(wrap(resolve.bind(null, res)));
                    }, function (err) {
                        return root._waitingQueue.push(wrap(reject.bind(null, err)));
                    }).finally(function () {
                        if (root._waitingFor === currentWaitPromise) {
                            // No one added a wait after us. Safe to stop the spinning.
                            root._waitingFor = null;
                        }
                    });
                });
            },
            //
            // Transaction Public Properties and Methods
            //
            abort: function abort() {
                this.active && this._reject(new exceptions.Abort());
                this.active = false;
            },
            tables: {
                get: deprecated("Transaction.tables", function () {
                    return allTables;
                })
            },
            table: function table(name) {
                var table = db.table(name); // Don't check that table is part of transaction. It must fail lazily!
                return new Table(name, table.schema, this);
            }
        });
        //
        //
        //
        // WhereClause
        //
        //
        //
        function WhereClause(table, index, orCollection) {
            /// <param name="table" type="Table"></param>
            /// <param name="index" type="String" optional="true"></param>
            /// <param name="orCollection" type="Collection" optional="true"></param>
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
        }
        props(WhereClause.prototype, function () {
            // WhereClause private methods
            function fail(collectionOrWhereClause, err, T) {
                var collection = collectionOrWhereClause instanceof WhereClause ? new Collection(collectionOrWhereClause) : collectionOrWhereClause;
                collection._ctx.error = T ? new T(err) : new TypeError(err);
                return collection;
            }
            function emptyCollection(whereClause) {
                return new Collection(whereClause, function () {
                    return IDBKeyRange.only("");
                }).limit(0);
            }
            function upperFactory(dir) {
                return dir === "next" ? function (s) {
                    return s.toUpperCase();
                } : function (s) {
                    return s.toLowerCase();
                };
            }
            function lowerFactory(dir) {
                return dir === "next" ? function (s) {
                    return s.toLowerCase();
                } : function (s) {
                    return s.toUpperCase();
                };
            }
            function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
                var length = Math.min(key.length, lowerNeedle.length);
                var llp = -1;
                for (var i = 0; i < length; ++i) {
                    var lwrKeyChar = lowerKey[i];
                    if (lwrKeyChar !== lowerNeedle[i]) {
                        if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                        if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                        if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                        return null;
                    }
                    if (cmp(key[i], lwrKeyChar) < 0) llp = i;
                }
                if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
                if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
                return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
            }
            function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
                /// <param name="needles" type="Array" elementType="String"></param>
                var upper,
                    lower,
                    compare,
                    upperNeedles,
                    lowerNeedles,
                    direction,
                    nextKeySuffix,
                    needlesLen = needles.length;
                if (!needles.every(function (s) {
                    return typeof s === 'string';
                })) {
                    return fail(whereClause, STRING_EXPECTED);
                }
                function initDirection(dir) {
                    upper = upperFactory(dir);
                    lower = lowerFactory(dir);
                    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
                    var needleBounds = needles.map(function (needle) {
                        return { lower: lower(needle), upper: upper(needle) };
                    }).sort(function (a, b) {
                        return compare(a.lower, b.lower);
                    });
                    upperNeedles = needleBounds.map(function (nb) {
                        return nb.upper;
                    });
                    lowerNeedles = needleBounds.map(function (nb) {
                        return nb.lower;
                    });
                    direction = dir;
                    nextKeySuffix = dir === "next" ? "" : suffix;
                }
                initDirection("next");
                var c = new Collection(whereClause, function () {
                    return IDBKeyRange.bound(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
                });
                c._ondirectionchange = function (direction) {
                    // This event onlys occur before filter is called the first time.
                    initDirection(direction);
                };
                var firstPossibleNeedle = 0;
                c._addAlgorithm(function (cursor, advance, resolve) {
                    /// <param name="cursor" type="IDBCursor"></param>
                    /// <param name="advance" type="Function"></param>
                    /// <param name="resolve" type="Function"></param>
                    var key = cursor.key;
                    if (typeof key !== 'string') return false;
                    var lowerKey = lower(key);
                    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                        return true;
                    } else {
                        var lowestPossibleCasing = null;
                        for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                            var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                            if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                                lowestPossibleCasing = casing;
                            }
                        }
                        if (lowestPossibleCasing !== null) {
                            advance(function () {
                                cursor.continue(lowestPossibleCasing + nextKeySuffix);
                            });
                        } else {
                            advance(resolve);
                        }
                        return false;
                    }
                });
                return c;
            }
            //
            // WhereClause public methods
            //
            return {
                between: function between(lower, upper, includeLower, includeUpper) {
                    /// <summary>
                    ///     Filter out records whose where-field lays between given lower and upper values. Applies to Strings, Numbers and Dates.
                    /// </summary>
                    /// <param name="lower"></param>
                    /// <param name="upper"></param>
                    /// <param name="includeLower" optional="true">Whether items that equals lower should be included. Default true.</param>
                    /// <param name="includeUpper" optional="true">Whether items that equals upper should be included. Default false.</param>
                    /// <returns type="Collection"></returns>
                    includeLower = includeLower !== false; // Default to true
                    includeUpper = includeUpper === true; // Default to false
                    try {
                        if (cmp(lower, upper) > 0 || cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this); // Workaround for idiotic W3C Specification that DataError must be thrown if lower > upper. The natural result would be to return an empty collection.
                        return new Collection(this, function () {
                            return IDBKeyRange.bound(lower, upper, !includeLower, !includeUpper);
                        });
                    } catch (e) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                },
                equals: function equals(value) {
                    return new Collection(this, function () {
                        return IDBKeyRange.only(value);
                    });
                },
                above: function above(value) {
                    return new Collection(this, function () {
                        return IDBKeyRange.lowerBound(value, true);
                    });
                },
                aboveOrEqual: function aboveOrEqual(value) {
                    return new Collection(this, function () {
                        return IDBKeyRange.lowerBound(value);
                    });
                },
                below: function below(value) {
                    return new Collection(this, function () {
                        return IDBKeyRange.upperBound(value, true);
                    });
                },
                belowOrEqual: function belowOrEqual(value) {
                    return new Collection(this, function () {
                        return IDBKeyRange.upperBound(value);
                    });
                },
                startsWith: function startsWith(str) {
                    /// <param name="str" type="String"></param>
                    if (typeof str !== 'string') return fail(this, STRING_EXPECTED);
                    return this.between(str, str + maxString, true, true);
                },
                startsWithIgnoreCase: function startsWithIgnoreCase(str) {
                    /// <param name="str" type="String"></param>
                    if (str === "") return this.startsWith(str);
                    return addIgnoreCaseAlgorithm(this, function (x, a) {
                        return x.indexOf(a[0]) === 0;
                    }, [str], maxString);
                },
                equalsIgnoreCase: function equalsIgnoreCase(str) {
                    /// <param name="str" type="String"></param>
                    return addIgnoreCaseAlgorithm(this, function (x, a) {
                        return x === a[0];
                    }, [str], "");
                },
                anyOfIgnoreCase: function anyOfIgnoreCase() {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (set.length === 0) return emptyCollection(this);
                    return addIgnoreCaseAlgorithm(this, function (x, a) {
                        return a.indexOf(x) !== -1;
                    }, set, "");
                },
                startsWithAnyOfIgnoreCase: function startsWithAnyOfIgnoreCase() {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (set.length === 0) return emptyCollection(this);
                    return addIgnoreCaseAlgorithm(this, function (x, a) {
                        return a.some(function (n) {
                            return x.indexOf(n) === 0;
                        });
                    }, set, maxString);
                },
                anyOf: function anyOf() {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    var compare = ascending;
                    try {
                        set.sort(compare);
                    } catch (e) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                    if (set.length === 0) return emptyCollection(this);
                    var c = new Collection(this, function () {
                        return IDBKeyRange.bound(set[0], set[set.length - 1]);
                    });
                    c._ondirectionchange = function (direction) {
                        compare = direction === "next" ? ascending : descending;
                        set.sort(compare);
                    };
                    var i = 0;
                    c._addAlgorithm(function (cursor, advance, resolve) {
                        var key = cursor.key;
                        while (compare(key, set[i]) > 0) {
                            // The cursor has passed beyond this key. Check next.
                            ++i;
                            if (i === set.length) {
                                // There is no next. Stop searching.
                                advance(resolve);
                                return false;
                            }
                        }
                        if (compare(key, set[i]) === 0) {
                            // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.
                            return true;
                        } else {
                            // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
                            advance(function () {
                                cursor.continue(set[i]);
                            });
                            return false;
                        }
                    });
                    return c;
                },
                notEqual: function notEqual(value) {
                    return this.inAnyRange([[minKey, value], [value, maxKey]], { includeLowers: false, includeUppers: false });
                },
                noneOf: function noneOf() {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (set.length === 0) return new Collection(this); // Return entire collection.
                    try {
                        set.sort(ascending);
                    } catch (e) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                    // Transform ["a","b","c"] to a set of ranges for between/above/below: [[minKey,"a"], ["a","b"], ["b","c"], ["c",maxKey]]
                    var ranges = set.reduce(function (res, val) {
                        return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
                    }, null);
                    ranges.push([set[set.length - 1], maxKey]);
                    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
                },
                /** Filter out values withing given set of ranges.
                * Example, give children and elders a rebate of 50%:
                *
                *   db.friends.where('age').inAnyRange([[0,18],[65,Infinity]]).modify({Rebate: 1/2});
                *
                * @param {(string|number|Date|Array)[][]} ranges
                * @param {{includeLowers: boolean, includeUppers: boolean}} options
                */
                inAnyRange: function inAnyRange(ranges, options) {
                    if (ranges.length === 0) return emptyCollection(this);
                    if (!ranges.every(function (range) {
                        return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;
                    })) {
                        return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
                    }
                    var includeLowers = !options || options.includeLowers !== false; // Default to true
                    var includeUppers = options && options.includeUppers === true; // Default to false
                    function addRange(ranges, newRange) {
                        for (var i = 0, l = ranges.length; i < l; ++i) {
                            var range = ranges[i];
                            if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                                range[0] = min(range[0], newRange[0]);
                                range[1] = max(range[1], newRange[1]);
                                break;
                            }
                        }
                        if (i === l) ranges.push(newRange);
                        return ranges;
                    }
                    var sortDirection = ascending;
                    function rangeSorter(a, b) {
                        return sortDirection(a[0], b[0]);
                    }
                    // Join overlapping ranges
                    var set;
                    try {
                        set = ranges.reduce(addRange, []);
                        set.sort(rangeSorter);
                    } catch (ex) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                    var i = 0;
                    var keyIsBeyondCurrentEntry = includeUppers ? function (key) {
                        return ascending(key, set[i][1]) > 0;
                    } : function (key) {
                        return ascending(key, set[i][1]) >= 0;
                    };
                    var keyIsBeforeCurrentEntry = includeLowers ? function (key) {
                        return descending(key, set[i][0]) > 0;
                    } : function (key) {
                        return descending(key, set[i][0]) >= 0;
                    };
                    function keyWithinCurrentRange(key) {
                        return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
                    }
                    var checkKey = keyIsBeyondCurrentEntry;
                    var c = new Collection(this, function () {
                        return IDBKeyRange.bound(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
                    });
                    c._ondirectionchange = function (direction) {
                        if (direction === "next") {
                            checkKey = keyIsBeyondCurrentEntry;
                            sortDirection = ascending;
                        } else {
                            checkKey = keyIsBeforeCurrentEntry;
                            sortDirection = descending;
                        }
                        set.sort(rangeSorter);
                    };
                    c._addAlgorithm(function (cursor, advance, resolve) {
                        var key = cursor.key;
                        while (checkKey(key)) {
                            // The cursor has passed beyond this key. Check next.
                            ++i;
                            if (i === set.length) {
                                // There is no next. Stop searching.
                                advance(resolve);
                                return false;
                            }
                        }
                        if (keyWithinCurrentRange(key)) {
                            // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.
                            return true;
                        } else if (cmp(key, set[i][1]) === 0 || cmp(key, set[i][0]) === 0) {
                            // includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.
                            // Continue to next key but don't include this one.
                            return false;
                        } else {
                            // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
                            advance(function () {
                                if (sortDirection === ascending) cursor.continue(set[i][0]);else cursor.continue(set[i][1]);
                            });
                            return false;
                        }
                    });
                    return c;
                },
                startsWithAnyOf: function startsWithAnyOf() {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (!set.every(function (s) {
                        return typeof s === 'string';
                    })) {
                        return fail(this, "startsWithAnyOf() only works with strings");
                    }
                    if (set.length === 0) return emptyCollection(this);
                    return this.inAnyRange(set.map(function (str) {
                        return [str, str + maxString];
                    }));
                }
            };
        });
        //
        //
        //
        // Collection Class
        //
        //
        //
        function Collection(whereClause, keyRangeGenerator) {
            /// <summary>
            ///
            /// </summary>
            /// <param name="whereClause" type="WhereClause">Where clause instance</param>
            /// <param name="keyRangeGenerator" value="function(){ return IDBKeyRange.bound(0,1);}" optional="true"></param>
            var keyRange = null,
                error = null;
            if (keyRangeGenerator) try {
                keyRange = keyRangeGenerator();
            } catch (ex) {
                error = ex;
            }
            var whereCtx = whereClause._ctx,
                table = whereCtx.table;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: table.hook.reading.fire
            };
        }
        function isPlainKeyRange(ctx, ignoreLimitFilter) {
            return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
        }
        props(Collection.prototype, function () {
            //
            // Collection Private Functions
            //
            function addFilter(ctx, fn) {
                ctx.filter = combine(ctx.filter, fn);
            }
            function addReplayFilter(ctx, factory, isLimitFilter) {
                var curr = ctx.replayFilter;
                ctx.replayFilter = curr ? function () {
                    return combine(curr(), factory());
                } : factory;
                ctx.justLimit = isLimitFilter && !curr;
            }
            function addMatchFilter(ctx, fn) {
                ctx.isMatch = combine(ctx.isMatch, fn);
            }
            /** @param ctx {
             *      isPrimKey: boolean,
             *      table: Table,
             *      index: string
             * }
             * @param store IDBObjectStore
             **/
            function getIndexOrStore(ctx, store) {
                if (ctx.isPrimKey) return store;
                var indexSpec = ctx.table.schema.idxByName[ctx.index];
                if (!indexSpec) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + store.name + " is not indexed");
                return store.index(indexSpec.name);
            }
            /** @param ctx {
             *      isPrimKey: boolean,
             *      table: Table,
             *      index: string,
             *      keysOnly: boolean,
             *      range?: IDBKeyRange,
             *      dir: "next" | "prev"
             * }
             */
            function openCursor(ctx, store) {
                var idxOrStore = getIndexOrStore(ctx, store);
                return ctx.keysOnly && 'openKeyCursor' in idxOrStore ? idxOrStore.openKeyCursor(ctx.range || null, ctx.dir + ctx.unique) : idxOrStore.openCursor(ctx.range || null, ctx.dir + ctx.unique);
            }
            function iter(ctx, fn, resolve, reject, idbstore) {
                var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
                if (!ctx.or) {
                    iterate(openCursor(ctx, idbstore), combine(ctx.algorithm, filter), fn, resolve, reject, !ctx.keysOnly && ctx.valueMapper);
                } else (function () {
                    var set = {};
                    var resolved = 0;
                    function resolveboth() {
                        if (++resolved === 2) resolve(); // Seems like we just support or btwn max 2 expressions, but there are no limit because we do recursion.
                    }
                    function union(item, cursor, advance) {
                        if (!filter || filter(cursor, advance, resolveboth, reject)) {
                            var primaryKey = cursor.primaryKey;
                            var key = '' + primaryKey;
                            if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);
                            if (!hasOwn(set, key)) {
                                set[key] = true;
                                fn(item, cursor, advance);
                            }
                        }
                    }
                    ctx.or._iterate(union, resolveboth, reject, idbstore);
                    iterate(openCursor(ctx, idbstore), ctx.algorithm, union, resolveboth, reject, !ctx.keysOnly && ctx.valueMapper);
                })();
            }
            return {
                //
                // Collection Protected Functions
                //
                _read: function _read(fn, cb) {
                    var ctx = this._ctx;
                    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._idbstore(READONLY, fn).then(cb);
                },
                _write: function _write(fn) {
                    var ctx = this._ctx;
                    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._idbstore(READWRITE, fn, "locked"); // When doing write operations on collections, always lock the operation so that upcoming operations gets queued.
                },
                _addAlgorithm: function _addAlgorithm(fn) {
                    var ctx = this._ctx;
                    ctx.algorithm = combine(ctx.algorithm, fn);
                },
                _iterate: function _iterate(fn, resolve, reject, idbstore) {
                    return iter(this._ctx, fn, resolve, reject, idbstore);
                },
                clone: function clone(props$$1) {
                    var rv = Object.create(this.constructor.prototype),
                        ctx = Object.create(this._ctx);
                    if (props$$1) extend(ctx, props$$1);
                    rv._ctx = ctx;
                    return rv;
                },
                raw: function raw() {
                    this._ctx.valueMapper = null;
                    return this;
                },
                //
                // Collection Public methods
                //
                each: function each(fn) {
                    var ctx = this._ctx;
                    return this._read(function (resolve, reject, idbstore) {
                        iter(ctx, fn, resolve, reject, idbstore);
                    });
                },
                count: function count(cb) {
                    var ctx = this._ctx;
                    if (isPlainKeyRange(ctx, true)) {
                        // This is a plain key range. We can use the count() method if the index.
                        return this._read(function (resolve, reject, idbstore) {
                            var idx = getIndexOrStore(ctx, idbstore);
                            var req = ctx.range ? idx.count(ctx.range) : idx.count();
                            req.onerror = eventRejectHandler(reject);
                            req.onsuccess = function (e) {
                                resolve(Math.min(e.target.result, ctx.limit));
                            };
                        }, cb);
                    } else {
                        // Algorithms, filters or expressions are applied. Need to count manually.
                        var count = 0;
                        return this._read(function (resolve, reject, idbstore) {
                            iter(ctx, function () {
                                ++count;return false;
                            }, function () {
                                resolve(count);
                            }, reject, idbstore);
                        }, cb);
                    }
                },
                sortBy: function sortBy(keyPath, cb) {
                    /// <param name="keyPath" type="String"></param>
                    var parts = keyPath.split('.').reverse(),
                        lastPart = parts[0],
                        lastIndex = parts.length - 1;
                    function getval(obj, i) {
                        if (i) return getval(obj[parts[i]], i - 1);
                        return obj[lastPart];
                    }
                    var order = this._ctx.dir === "next" ? 1 : -1;
                    function sorter(a, b) {
                        var aVal = getval(a, lastIndex),
                            bVal = getval(b, lastIndex);
                        return aVal < bVal ? -order : aVal > bVal ? order : 0;
                    }
                    return this.toArray(function (a) {
                        return a.sort(sorter);
                    }).then(cb);
                },
                toArray: function toArray(cb) {
                    var ctx = this._ctx;
                    return this._read(function (resolve, reject, idbstore) {
                        if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                            // Special optimation if we could use IDBObjectStore.getAll() or
                            // IDBKeyRange.getAll():
                            var readingHook = ctx.table.hook.reading.fire;
                            var idxOrStore = getIndexOrStore(ctx, idbstore);
                            var req = ctx.limit < Infinity ? idxOrStore.getAll(ctx.range, ctx.limit) : idxOrStore.getAll(ctx.range);
                            req.onerror = eventRejectHandler(reject);
                            req.onsuccess = readingHook === mirror ? eventSuccessHandler(resolve) : eventSuccessHandler(function (res) {
                                try {
                                    resolve(res.map(readingHook));
                                } catch (e) {
                                    reject(e);
                                }
                            });
                        } else {
                            // Getting array through a cursor.
                            var a = [];
                            iter(ctx, function (item) {
                                a.push(item);
                            }, function arrayComplete() {
                                resolve(a);
                            }, reject, idbstore);
                        }
                    }, cb);
                },
                offset: function offset(_offset2) {
                    var ctx = this._ctx;
                    if (_offset2 <= 0) return this;
                    ctx.offset += _offset2; // For count()
                    if (isPlainKeyRange(ctx)) {
                        addReplayFilter(ctx, function () {
                            var offsetLeft = _offset2;
                            return function (cursor, advance) {
                                if (offsetLeft === 0) return true;
                                if (offsetLeft === 1) {
                                    --offsetLeft;
                                    return false;
                                }
                                advance(function () {
                                    cursor.advance(offsetLeft);
                                    offsetLeft = 0;
                                });
                                return false;
                            };
                        });
                    } else {
                        addReplayFilter(ctx, function () {
                            var offsetLeft = _offset2;
                            return function () {
                                return --offsetLeft < 0;
                            };
                        });
                    }
                    return this;
                },
                limit: function limit(numRows) {
                    this._ctx.limit = Math.min(this._ctx.limit, numRows); // For count()
                    addReplayFilter(this._ctx, function () {
                        var rowsLeft = numRows;
                        return function (cursor, advance, resolve) {
                            if (--rowsLeft <= 0) advance(resolve); // Stop after this item has been included
                            return rowsLeft >= 0; // If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.
                        };
                    }, true);
                    return this;
                },
                until: function until(filterFunction, bIncludeStopEntry) {
                    var ctx = this._ctx;
                    addFilter(this._ctx, function (cursor, advance, resolve) {
                        if (filterFunction(cursor.value)) {
                            advance(resolve);
                            return bIncludeStopEntry;
                        } else {
                            return true;
                        }
                    });
                    return this;
                },
                first: function first(cb) {
                    return this.limit(1).toArray(function (a) {
                        return a[0];
                    }).then(cb);
                },
                last: function last(cb) {
                    return this.reverse().first(cb);
                },
                filter: function filter(filterFunction) {
                    /// <param name="jsFunctionFilter" type="Function">function(val){return true/false}</param>
                    addFilter(this._ctx, function (cursor) {
                        return filterFunction(cursor.value);
                    });
                    // match filters not used in Dexie.js but can be used by 3rd part libraries to test a
                    // collection for a match without querying DB. Used by Dexie.Observable.
                    addMatchFilter(this._ctx, filterFunction);
                    return this;
                },
                and: function and(filterFunction) {
                    return this.filter(filterFunction);
                },
                or: function or(indexName) {
                    return new WhereClause(this._ctx.table, indexName, this);
                },
                reverse: function reverse() {
                    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
                    if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
                    return this;
                },
                desc: function desc() {
                    return this.reverse();
                },
                eachKey: function eachKey(cb) {
                    var ctx = this._ctx;
                    ctx.keysOnly = !ctx.isMatch;
                    return this.each(function (val, cursor) {
                        cb(cursor.key, cursor);
                    });
                },
                eachUniqueKey: function eachUniqueKey(cb) {
                    this._ctx.unique = "unique";
                    return this.eachKey(cb);
                },
                eachPrimaryKey: function eachPrimaryKey(cb) {
                    var ctx = this._ctx;
                    ctx.keysOnly = !ctx.isMatch;
                    return this.each(function (val, cursor) {
                        cb(cursor.primaryKey, cursor);
                    });
                },
                keys: function keys(cb) {
                    var ctx = this._ctx;
                    ctx.keysOnly = !ctx.isMatch;
                    var a = [];
                    return this.each(function (item, cursor) {
                        a.push(cursor.key);
                    }).then(function () {
                        return a;
                    }).then(cb);
                },
                primaryKeys: function primaryKeys(cb) {
                    var ctx = this._ctx;
                    if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                        // Special optimation if we could use IDBObjectStore.getAllKeys() or
                        // IDBKeyRange.getAllKeys():
                        return this._read(function (resolve, reject, idbstore) {
                            var idxOrStore = getIndexOrStore(ctx, idbstore);
                            var req = ctx.limit < Infinity ? idxOrStore.getAllKeys(ctx.range, ctx.limit) : idxOrStore.getAllKeys(ctx.range);
                            req.onerror = eventRejectHandler(reject);
                            req.onsuccess = eventSuccessHandler(resolve);
                        }).then(cb);
                    }
                    ctx.keysOnly = !ctx.isMatch;
                    var a = [];
                    return this.each(function (item, cursor) {
                        a.push(cursor.primaryKey);
                    }).then(function () {
                        return a;
                    }).then(cb);
                },
                uniqueKeys: function uniqueKeys(cb) {
                    this._ctx.unique = "unique";
                    return this.keys(cb);
                },
                firstKey: function firstKey(cb) {
                    return this.limit(1).keys(function (a) {
                        return a[0];
                    }).then(cb);
                },
                lastKey: function lastKey(cb) {
                    return this.reverse().firstKey(cb);
                },
                distinct: function distinct() {
                    var ctx = this._ctx,
                        idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
                    if (!idx || !idx.multi) return this; // distinct() only makes differencies on multiEntry indexes.
                    var set = {};
                    addFilter(this._ctx, function (cursor) {
                        var strKey = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string
                        var found = hasOwn(set, strKey);
                        set[strKey] = true;
                        return !found;
                    });
                    return this;
                },
                //
                // Methods that mutate storage
                //
                modify: function modify(changes) {
                    var self = this,
                        ctx = this._ctx,
                        hook = ctx.table.hook,
                        updatingHook = hook.updating.fire,
                        deletingHook = hook.deleting.fire;
                    return this._write(function (resolve, reject, idbstore, trans) {
                        var modifyer;
                        if (typeof changes === 'function') {
                            // Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)
                            if (updatingHook === nop && deletingHook === nop) {
                                // Noone cares about what is being changed. Just let the modifier function be the given argument as is.
                                modifyer = changes;
                            } else {
                                // People want to know exactly what is being modified or deleted.
                                // Let modifyer be a proxy function that finds out what changes the caller is actually doing
                                // and call the hooks accordingly!
                                modifyer = function modifyer(item) {
                                    var origItem = deepClone(item); // Clone the item first so we can compare laters.
                                    if (changes.call(this, item, this) === false) return false; // Call the real modifyer function (If it returns false explicitely, it means it dont want to modify anyting on this object)
                                    if (!hasOwn(this, "value")) {
                                        // The real modifyer function requests a deletion of the object. Inform the deletingHook that a deletion is taking place.
                                        deletingHook.call(this, this.primKey, item, trans);
                                    } else {
                                        // No deletion. Check what was changed
                                        var objectDiff = getObjectDiff(origItem, this.value);
                                        var additionalChanges = updatingHook.call(this, objectDiff, this.primKey, origItem, trans);
                                        if (additionalChanges) {
                                            // Hook want to apply additional modifications. Make sure to fullfill the will of the hook.
                                            item = this.value;
                                            keys(additionalChanges).forEach(function (keyPath) {
                                                setByKeyPath(item, keyPath, additionalChanges[keyPath]); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath
                                            });
                                        }
                                    }
                                };
                            }
                        } else if (updatingHook === nop) {
                            // changes is a set of {keyPath: value} and no one is listening to the updating hook.
                            var keyPaths = keys(changes);
                            var numKeys = keyPaths.length;
                            modifyer = function modifyer(item) {
                                var anythingModified = false;
                                for (var i = 0; i < numKeys; ++i) {
                                    var keyPath = keyPaths[i],
                                        val = changes[keyPath];
                                    if (getByKeyPath(item, keyPath) !== val) {
                                        setByKeyPath(item, keyPath, val); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath
                                        anythingModified = true;
                                    }
                                }
                                return anythingModified;
                            };
                        } else {
                            // changes is a set of {keyPath: value} and people are listening to the updating hook so we need to call it and
                            // allow it to add additional modifications to make.
                            var origChanges = changes;
                            changes = shallowClone(origChanges); // Let's work with a clone of the changes keyPath/value set so that we can restore it in case a hook extends it.
                            modifyer = function modifyer(item) {
                                var anythingModified = false;
                                var additionalChanges = updatingHook.call(this, changes, this.primKey, deepClone(item), trans);
                                if (additionalChanges) extend(changes, additionalChanges);
                                keys(changes).forEach(function (keyPath) {
                                    var val = changes[keyPath];
                                    if (getByKeyPath(item, keyPath) !== val) {
                                        setByKeyPath(item, keyPath, val);
                                        anythingModified = true;
                                    }
                                });
                                if (additionalChanges) changes = shallowClone(origChanges); // Restore original changes for next iteration
                                return anythingModified;
                            };
                        }
                        var count = 0;
                        var successCount = 0;
                        var iterationComplete = false;
                        var failures = [];
                        var failKeys = [];
                        var currentKey = null;
                        function modifyItem(item, cursor) {
                            currentKey = cursor.primaryKey;
                            var thisContext = {
                                primKey: cursor.primaryKey,
                                value: item,
                                onsuccess: null,
                                onerror: null
                            };
                            function onerror(e) {
                                failures.push(e);
                                failKeys.push(thisContext.primKey);
                                checkFinished();
                                return true; // Catch these errors and let a final rejection decide whether or not to abort entire transaction
                            }
                            if (modifyer.call(thisContext, item, thisContext) !== false) {
                                var bDelete = !hasOwn(thisContext, "value");
                                ++count;
                                tryCatch(function () {
                                    var req = bDelete ? cursor.delete() : cursor.update(thisContext.value);
                                    req._hookCtx = thisContext;
                                    req.onerror = hookedEventRejectHandler(onerror);
                                    req.onsuccess = hookedEventSuccessHandler(function () {
                                        ++successCount;
                                        checkFinished();
                                    });
                                }, onerror);
                            } else if (thisContext.onsuccess) {
                                // Hook will expect either onerror or onsuccess to always be called!
                                thisContext.onsuccess(thisContext.value);
                            }
                        }
                        function doReject(e) {
                            if (e) {
                                failures.push(e);
                                failKeys.push(currentKey);
                            }
                            return reject(new ModifyError("Error modifying one or more objects", failures, successCount, failKeys));
                        }
                        function checkFinished() {
                            if (iterationComplete && successCount + failures.length === count) {
                                if (failures.length > 0) doReject();else resolve(successCount);
                            }
                        }
                        self.clone().raw()._iterate(modifyItem, function () {
                            iterationComplete = true;
                            checkFinished();
                        }, doReject, idbstore);
                    });
                },
                'delete': function _delete() {
                    var _this = this;
                    var ctx = this._ctx,
                        range = ctx.range,
                        deletingHook = ctx.table.hook.deleting.fire,
                        hasDeleteHook = deletingHook !== nop;
                    if (!hasDeleteHook && isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || !range)) {
                        // May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)
                        // For chromium, this is the way most optimized version.
                        // For IE/Edge, this could hang the indexedDB engine and make operating system instable
                        // (https://gist.github.com/dfahlander/5a39328f029de18222cf2125d56c38f7)
                        return this._write(function (resolve, reject, idbstore) {
                            // Our API contract is to return a count of deleted items, so we have to count() before delete().
                            var onerror = eventRejectHandler(reject),
                                countReq = range ? idbstore.count(range) : idbstore.count();
                            countReq.onerror = onerror;
                            countReq.onsuccess = function () {
                                var count = countReq.result;
                                tryCatch(function () {
                                    var delReq = range ? idbstore.delete(range) : idbstore.clear();
                                    delReq.onerror = onerror;
                                    delReq.onsuccess = function () {
                                        return resolve(count);
                                    };
                                }, function (err) {
                                    return reject(err);
                                });
                            };
                        });
                    }
                    // Default version to use when collection is not a vanilla IDBKeyRange on the primary key.
                    // Divide into chunks to not starve RAM.
                    // If has delete hook, we will have to collect not just keys but also objects, so it will use
                    // more memory and need lower chunk size.
                    var CHUNKSIZE = hasDeleteHook ? 2000 : 10000;
                    return this._write(function (resolve, reject, idbstore, trans) {
                        var totalCount = 0;
                        // Clone collection and change its table and set a limit of CHUNKSIZE on the cloned Collection instance.
                        var collection = _this.clone({
                            keysOnly: !ctx.isMatch && !hasDeleteHook
                        }) // load just keys (unless filter() or and() or deleteHook has subscribers)
                        .distinct() // In case multiEntry is used, never delete same key twice because resulting count
                        .limit(CHUNKSIZE).raw(); // Don't filter through reading-hooks (like mapped classes etc)
                        var keysOrTuples = [];
                        // We're gonna do things on as many chunks that are needed.
                        // Use recursion of nextChunk function:
                        var nextChunk = function nextChunk() {
                            return collection.each(hasDeleteHook ? function (val, cursor) {
                                // Somebody subscribes to hook('deleting'). Collect all primary keys and their values,
                                // so that the hook can be called with its values in bulkDelete().
                                keysOrTuples.push([cursor.primaryKey, cursor.value]);
                            } : function (val, cursor) {
                                // No one subscribes to hook('deleting'). Collect only primary keys:
                                keysOrTuples.push(cursor.primaryKey);
                            }).then(function () {
                                // Chromium deletes faster when doing it in sort order.
                                hasDeleteHook ? keysOrTuples.sort(function (a, b) {
                                    return ascending(a[0], b[0]);
                                }) : keysOrTuples.sort(ascending);
                                return _bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook);
                            }).then(function () {
                                var count = keysOrTuples.length;
                                totalCount += count;
                                keysOrTuples = [];
                                return count < CHUNKSIZE ? totalCount : nextChunk();
                            });
                        };
                        resolve(nextChunk());
                    });
                }
            };
        });
        //
        //
        //
        // ------------------------- Help functions ---------------------------
        //
        //
        //
        function lowerVersionFirst(a, b) {
            return a._cfg.version - b._cfg.version;
        }
        function setApiOnPlace(objs, tableNames, dbschema) {
            tableNames.forEach(function (tableName) {
                var schema = dbschema[tableName];
                objs.forEach(function (obj) {
                    if (!(tableName in obj)) {
                        if (obj === Transaction.prototype || obj instanceof Transaction) {
                            // obj is a Transaction prototype (or prototype of a subclass to Transaction)
                            // Make the API a getter that returns this.table(tableName)
                            setProp(obj, tableName, { get: function get() {
                                    return this.table(tableName);
                                } });
                        } else {
                            // Table will not be bound to a transaction (will use Dexie.currentTransaction)
                            obj[tableName] = new Table(tableName, schema);
                        }
                    }
                });
            });
        }
        function removeTablesApi(objs) {
            objs.forEach(function (obj) {
                for (var key in obj) {
                    if (obj[key] instanceof Table) delete obj[key];
                }
            });
        }
        function iterate(req, filter, fn, resolve, reject, valueMapper) {
            // Apply valueMapper (hook('reading') or mappped class)
            var mappedFn = valueMapper ? function (x, c, a) {
                return fn(valueMapper(x), c, a);
            } : fn;
            // Wrap fn with PSD and microtick stuff from Promise.
            var wrappedFn = wrap(mappedFn, reject);
            if (!req.onerror) req.onerror = eventRejectHandler(reject);
            if (filter) {
                req.onsuccess = trycatcher(function filter_record() {
                    var cursor = req.result;
                    if (cursor) {
                        var c = function c() {
                            cursor.continue();
                        };
                        if (filter(cursor, function (advancer) {
                            c = advancer;
                        }, resolve, reject)) wrappedFn(cursor.value, cursor, function (advancer) {
                            c = advancer;
                        });
                        c();
                    } else {
                        resolve();
                    }
                }, reject);
            } else {
                req.onsuccess = trycatcher(function filter_record() {
                    var cursor = req.result;
                    if (cursor) {
                        var c = function c() {
                            cursor.continue();
                        };
                        wrappedFn(cursor.value, cursor, function (advancer) {
                            c = advancer;
                        });
                        c();
                    } else {
                        resolve();
                    }
                }, reject);
            }
        }
        function parseIndexSyntax(indexes) {
            /// <param name="indexes" type="String"></param>
            /// <returns type="Array" elementType="IndexSpec"></returns>
            var rv = [];
            indexes.split(',').forEach(function (index) {
                index = index.trim();
                var name = index.replace(/([&*]|\+\+)/g, ""); // Remove "&", "++" and "*"
                // Let keyPath of "[a+b]" be ["a","b"]:
                var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
                rv.push(new IndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), /\./.test(index)));
            });
            return rv;
        }
        function cmp(key1, key2) {
            return indexedDB.cmp(key1, key2);
        }
        function min(a, b) {
            return cmp(a, b) < 0 ? a : b;
        }
        function max(a, b) {
            return cmp(a, b) > 0 ? a : b;
        }
        function ascending(a, b) {
            return indexedDB.cmp(a, b);
        }
        function descending(a, b) {
            return indexedDB.cmp(b, a);
        }
        function simpleCompare(a, b) {
            return a < b ? -1 : a === b ? 0 : 1;
        }
        function simpleCompareReverse(a, b) {
            return a > b ? -1 : a === b ? 0 : 1;
        }
        function combine(filter1, filter2) {
            return filter1 ? filter2 ? function () {
                return filter1.apply(this, arguments) && filter2.apply(this, arguments);
            } : filter1 : filter2;
        }
        function readGlobalSchema() {
            db.verno = idbdb.version / 10;
            db._dbSchema = globalSchema = {};
            dbStoreNames = slice(idbdb.objectStoreNames, 0);
            if (dbStoreNames.length === 0) return; // Database contains no stores.
            var trans = idbdb.transaction(safariMultiStoreFix(dbStoreNames), 'readonly');
            dbStoreNames.forEach(function (storeName) {
                var store = trans.objectStore(storeName),
                    keyPath = store.keyPath,
                    dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;
                var primKey = new IndexSpec(keyPath, keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== 'string', dotted);
                var indexes = [];
                for (var j = 0; j < store.indexNames.length; ++j) {
                    var idbindex = store.index(store.indexNames[j]);
                    keyPath = idbindex.keyPath;
                    dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;
                    var index = new IndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== 'string', dotted);
                    indexes.push(index);
                }
                globalSchema[storeName] = new TableSchema(storeName, primKey, indexes, {});
            });
            setApiOnPlace([allTables], keys(globalSchema), globalSchema);
        }
        function adjustToExistingIndexNames(schema, idbtrans) {
            /// <summary>
            /// Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db
            /// </summary>
            /// <param name="schema" type="Object">Map between name and TableSchema</param>
            /// <param name="idbtrans" type="IDBTransaction"></param>
            var storeNames = idbtrans.db.objectStoreNames;
            for (var i = 0; i < storeNames.length; ++i) {
                var storeName = storeNames[i];
                var store = idbtrans.objectStore(storeName);
                hasGetAll = 'getAll' in store;
                for (var j = 0; j < store.indexNames.length; ++j) {
                    var indexName = store.indexNames[j];
                    var keyPath = store.index(indexName).keyPath;
                    var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                    if (schema[storeName]) {
                        var indexSpec = schema[storeName].idxByName[dexieName];
                        if (indexSpec) indexSpec.name = indexName;
                    }
                }
            }
            // Bug with getAll() on Safari ver<604 on Workers only, see discussion following PR #579
            if (/Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
                hasGetAll = false;
            }
        }
        function fireOnBlocked(ev) {
            db.on("blocked").fire(ev);
            // Workaround (not fully*) for missing "versionchange" event in IE,Edge and Safari:
            connections.filter(function (c) {
                return c.name === db.name && c !== db && !c._vcFired;
            }).map(function (c) {
                return c.on("versionchange").fire(ev);
            });
        }
        extend(this, {
            Collection: Collection,
            Table: Table,
            Transaction: Transaction,
            Version: Version,
            WhereClause: WhereClause
        });
        init();
        addons.forEach(function (fn) {
            fn(db);
        });
    }
    function parseType(type) {
        if (typeof type === 'function') {
            return new type();
        } else if (isArray(type)) {
            return [parseType(type[0])];
        } else if (type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {
            var rv = {};
            applyStructure(rv, type);
            return rv;
        } else {
            return type;
        }
    }
    function applyStructure(obj, structure) {
        keys(structure).forEach(function (member) {
            var value = parseType(structure[member]);
            obj[member] = value;
        });
        return obj;
    }
    function hookedEventSuccessHandler(resolve) {
        // wrap() is needed when calling hooks because the rare scenario of:
        //  * hook does a db operation that fails immediately (IDB throws exception)
        //    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.
        //    wrap() will also execute in a virtual tick.
        //  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.
        //  * If this was the last event in the bulk, the promise will resolve after a physical tick
        //    and the transaction will have committed already.
        // If no hook, the virtual tick will be executed in the reject()/resolve of the final promise,
        // because it is always marked with _lib = true when created using Transaction._promise().
        return wrap(function (event) {
            var req = event.target,
                ctx = req._hookCtx,
                // Contains the hook error handler. Put here instead of closure to boost performance.
            result = ctx.value || req.result,
                // Pass the object value on updates. The result from IDB is the primary key.
            hookSuccessHandler = ctx && ctx.onsuccess;
            hookSuccessHandler && hookSuccessHandler(result);
            resolve && resolve(result);
        }, resolve);
    }
    function eventRejectHandler(reject) {
        return wrap(function (event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }
    function eventSuccessHandler(resolve) {
        return wrap(function (event) {
            resolve(event.target.result);
        });
    }
    function hookedEventRejectHandler(reject) {
        return wrap(function (event) {
            // See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.
            var req = event.target,
                err = req.error,
                ctx = req._hookCtx,
                // Contains the hook error handler. Put here instead of closure to boost performance.
            hookErrorHandler = ctx && ctx.onerror;
            hookErrorHandler && hookErrorHandler(err);
            preventDefault(event);
            reject(err);
            return false;
        });
    }
    function preventDefault(event) {
        if (event.stopPropagation) event.stopPropagation();
        if (event.preventDefault) event.preventDefault();
    }
    function awaitIterator(iterator) {
        var callNext = function callNext(result) {
            return iterator.next(result);
        },
            doThrow = function doThrow(error) {
            return iterator.throw(error);
        },
            onSuccess = step(callNext),
            onError = step(doThrow);
        function step(getNext) {
            return function (val) {
                var next = getNext(val),
                    value = next.value;
                return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
            };
        }
        return step(callNext)();
    }
    //
    // IndexSpec struct
    //
    function IndexSpec(name, keyPath, unique, multi, auto, compound, dotted) {
        /// <param name="name" type="String"></param>
        /// <param name="keyPath" type="String"></param>
        /// <param name="unique" type="Boolean"></param>
        /// <param name="multi" type="Boolean"></param>
        /// <param name="auto" type="Boolean"></param>
        /// <param name="compound" type="Boolean"></param>
        /// <param name="dotted" type="Boolean"></param>
        this.name = name;
        this.keyPath = keyPath;
        this.unique = unique;
        this.multi = multi;
        this.auto = auto;
        this.compound = compound;
        this.dotted = dotted;
        var keyPathSrc = typeof keyPath === 'string' ? keyPath : keyPath && '[' + [].join.call(keyPath, '+') + ']';
        this.src = (unique ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + keyPathSrc;
    }
    //
    // TableSchema struct
    //
    function TableSchema(name, primKey, indexes, instanceTemplate) {
        /// <param name="name" type="String"></param>
        /// <param name="primKey" type="IndexSpec"></param>
        /// <param name="indexes" type="Array" elementType="IndexSpec"></param>
        /// <param name="instanceTemplate" type="Object"></param>
        this.name = name;
        this.primKey = primKey || new IndexSpec();
        this.indexes = indexes || [new IndexSpec()];
        this.instanceTemplate = instanceTemplate;
        this.mappedClass = null;
        this.idxByName = arrayToObject(indexes, function (index) {
            return [index.name, index];
        });
    }
    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    function getNativeGetDatabaseNamesFn(indexedDB) {
        var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);
        return fn && fn.bind(indexedDB);
    }
    // Export Error classes
    props(Dexie, fullNameExceptions); // Dexie.XXXError = class XXXError {...};
    //
    // Static methods and properties
    // 
    props(Dexie, {
        //
        // Static delete() method.
        //
        delete: function _delete(databaseName) {
            var db = new Dexie(databaseName),
                promise = db.delete();
            promise.onblocked = function (fn) {
                db.on("blocked", fn);
                return this;
            };
            return promise;
        },
        //
        // Static exists() method.
        //
        exists: function exists(name) {
            return new Dexie(name).open().then(function (db) {
                db.close();
                return true;
            }).catch(Dexie.NoSuchDatabaseError, function () {
                return false;
            });
        },
        //
        // Static method for retrieving a list of all existing databases at current host.
        //
        getDatabaseNames: function getDatabaseNames(cb) {
            var getDatabaseNames = getNativeGetDatabaseNamesFn(Dexie.dependencies.indexedDB);
            return getDatabaseNames ? new Promise(function (resolve, reject) {
                var req = getDatabaseNames();
                req.onsuccess = function (event) {
                    resolve(slice(event.target.result, 0)); // Converst DOMStringList to Array<String>
                };
                req.onerror = eventRejectHandler(reject);
            }).then(cb) : dbNamesDB.dbnames.toCollection().primaryKeys(cb);
        },
        defineClass: function defineClass(structure) {
            /// <summary>
            ///     Create a javascript constructor based on given template for which properties to expect in the class.
            ///     Any property that is a constructor function will act as a type. So {name: String} will be equal to {name: new String()}.
            /// </summary>
            /// <param name="structure">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
            /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>
            // Default constructor able to copy given properties into this object.
            function Class(properties) {
                /// <param name="properties" type="Object" optional="true">Properties to initialize object with.
                /// </param>
                if (properties) extend(this, properties);
            }
            return Class;
        },
        applyStructure: applyStructure,
        ignoreTransaction: function ignoreTransaction(scopeFunc) {
            // In case caller is within a transaction but needs to create a separate transaction.
            // Example of usage:
            //
            // Let's say we have a logger function in our app. Other application-logic should be unaware of the
            // logger function and not need to include the 'logentries' table in all transaction it performs.
            // The logging should always be done in a separate transaction and not be dependant on the current
            // running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.
            //
            //     Dexie.ignoreTransaction(function() {
            //         db.logentries.add(newLogEntry);
            //     });
            //
            // Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction
            // in current Promise-scope.
            //
            // An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an
            // API for this because
            //  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().
            //  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().
            //  3) setImmediate() is not supported in the ES standard.
            //  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.
            return PSD.trans ? usePSD(PSD.transless, scopeFunc) : // Use the closest parent that was non-transactional.
            scopeFunc(); // No need to change scope because there is no ongoing transaction.
        },
        vip: function vip(fn) {
            // To be used by subscribers to the on('ready') event.
            // This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.
            // This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD
            // from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since
            // the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.
            // Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()
            // the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by
            // the caller will not resolve until database is opened.
            return newScope(function () {
                PSD.letThrough = true; // Make sure we are let through if still blocking db due to onready is firing.
                return fn();
            });
        },
        async: function async(generatorFn) {
            return function () {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);
                    return rv;
                } catch (e) {
                    return rejection(e);
                }
            };
        },
        spawn: function spawn(generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);
                return rv;
            } catch (e) {
                return rejection(e);
            }
        },
        // Dexie.currentTransaction property
        currentTransaction: {
            get: function get() {
                return PSD.trans || null;
            }
        },
        waitFor: function waitFor(promiseOrFunction, optionalTimeout) {
            // If a function is provided, invoke it and pass the returning value to Transaction.waitFor()
            var promise = Promise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000); // Default the timeout to one minute. Caller may specify Infinity if required.       
            // Run given promise on current transaction. If no current transaction, just return a Dexie promise based
            // on given value.
            return PSD.trans ? PSD.trans.waitFor(promise) : promise;
        },
        // Export our Promise implementation since it can be handy as a standalone Promise implementation
        Promise: Promise,
        // Dexie.debug proptery:
        // Dexie.debug = false
        // Dexie.debug = true
        // Dexie.debug = "dexie" - don't hide dexie's stack frames.
        debug: {
            get: function get() {
                return debug;
            },
            set: function set(value) {
                setDebug(value, value === 'dexie' ? function () {
                    return true;
                } : dexieStackFrameFilter);
            }
        },
        // Export our derive/extend/override methodology
        derive: derive,
        extend: extend,
        props: props,
        override: override,
        // Export our Events() function - can be handy as a toolkit
        Events: Events,
        // Utilities
        getByKeyPath: getByKeyPath,
        setByKeyPath: setByKeyPath,
        delByKeyPath: delByKeyPath,
        shallowClone: shallowClone,
        deepClone: deepClone,
        getObjectDiff: getObjectDiff,
        asap: asap,
        maxKey: maxKey,
        minKey: minKey,
        // Addon registry
        addons: [],
        // Global DB connection list
        connections: connections,
        MultiModifyError: exceptions.Modify,
        errnames: errnames,
        // Export other static classes
        IndexSpec: IndexSpec,
        TableSchema: TableSchema,
        //
        // Dependencies
        //
        // These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.
        //
        // In node.js, however, these properties must be set "manually" before instansiating a new Dexie().
        // For node.js, you need to require indexeddb-js or similar and then set these deps.
        //
        dependencies: {
            // Required:
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        },
        // API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split('.').map(function (n) {
            return parseInt(n);
        }).reduce(function (p, c, i) {
            return p + c / Math.pow(10, i * 2);
        }),
        // https://github.com/dfahlander/Dexie.js/issues/186
        // typescript compiler tsc in mode ts-->es5 & commonJS, will expect require() to return
        // x.default. Workaround: Set Dexie.default = Dexie.
        default: Dexie,
        // Make it possible to import {Dexie} (non-default import)
        // Reason 1: May switch to that in future.
        // Reason 2: We declare it both default and named exported in d.ts to make it possible
        // to let addons extend the Dexie interface with Typescript 2.1 (works only when explicitely
        // exporting the symbol, not just default exporting)
        Dexie: Dexie
    });
    // Map DOMErrors and DOMExceptions to corresponding Dexie errors. May change in Dexie v2.0.
    Promise.rejectionMapper = mapError;
    // Initialize dbNamesDB (won't ever be opened on chromium browsers')
    dbNamesDB = new Dexie('__dbnames');
    dbNamesDB.version(1).stores({ dbnames: 'name' });
    (function () {
        // Migrate from Dexie 1.x database names stored in localStorage:
        var DBNAMES = 'Dexie.DatabaseNames';
        if ((typeof localStorage === 'undefined' ? 'undefined' : _typeof(localStorage)) !== undefined && _global.document !== undefined) try {
            // Have localStorage and is not executing in a worker. Lets migrate from Dexie 1.x.
            JSON.parse(localStorage.getItem(DBNAMES) || "[]").forEach(function (name) {
                return dbNamesDB.dbnames.put({ name: name }).catch(nop);
            });
            localStorage.removeItem(DBNAMES);
        } catch (_e) {}
    })();

    return Dexie;
});
//# sourceMappingURL=dexie.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRleGllLmpzIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiRGV4aWUiLCJrZXlzIiwiT2JqZWN0IiwiaXNBcnJheSIsIkFycmF5IiwiX2dsb2JhbCIsInNlbGYiLCJ3aW5kb3ciLCJleHRlbmQiLCJvYmoiLCJleHRlbnNpb24iLCJmb3JFYWNoIiwia2V5IiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIl9oYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsInByb3AiLCJjYWxsIiwicHJvcHMiLCJwcm90byIsInNldFByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsImZ1bmN0aW9uT3JHZXRTZXQiLCJvcHRpb25zIiwiZ2V0Iiwic2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlcml2ZSIsIkNoaWxkIiwiZnJvbSIsIlBhcmVudCIsInByb3RvdHlwZSIsImNyZWF0ZSIsImJpbmQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRQcm9wZXJ0eURlc2NyaXB0b3IiLCJwZCIsIl9zbGljZSIsInNsaWNlIiwiYXJncyIsInN0YXJ0IiwiZW5kIiwib3ZlcnJpZGUiLCJvcmlnRnVuYyIsIm92ZXJyaWRlZEZhY3RvcnkiLCJhc3NlcnQiLCJiIiwiRXJyb3IiLCJhc2FwIiwiZm4iLCJzZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwiYXJyYXlUb09iamVjdCIsImFycmF5IiwiZXh0cmFjdG9yIiwicmVkdWNlIiwicmVzdWx0IiwiaXRlbSIsImkiLCJuYW1lQW5kVmFsdWUiLCJ0cnljYXRjaGVyIiwicmVqZWN0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJlIiwidHJ5Q2F0Y2giLCJvbmVycm9yIiwiZXgiLCJnZXRCeUtleVBhdGgiLCJrZXlQYXRoIiwicnYiLCJsIiwibGVuZ3RoIiwidmFsIiwicHVzaCIsInBlcmlvZCIsImluZGV4T2YiLCJpbm5lck9iaiIsInN1YnN0ciIsInVuZGVmaW5lZCIsInNldEJ5S2V5UGF0aCIsImlzRnJvemVuIiwiY3VycmVudEtleVBhdGgiLCJyZW1haW5pbmdLZXlQYXRoIiwiZGVsQnlLZXlQYXRoIiwibWFwIiwia3AiLCJzaGFsbG93Q2xvbmUiLCJtIiwiY29uY2F0IiwiZmxhdHRlbiIsImEiLCJpbnRyaW5zaWNUeXBlcyIsInNwbGl0IiwibnVtIiwidCIsImZpbHRlciIsImRlZXBDbG9uZSIsImFueSIsImNvbnN0cnVjdG9yIiwiZ2V0T2JqZWN0RGlmZiIsInByZngiLCJhcCIsImJwIiwiaXRlcmF0b3JTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvciIsImdldEl0ZXJhdG9yT2YiLCJ4IiwiTk9fQ0hBUl9BUlJBWSIsImdldEFycmF5T2YiLCJhcnJheUxpa2UiLCJpdCIsIm5leHQiLCJkb25lIiwiZGVidWciLCJsb2NhdGlvbiIsInRlc3QiLCJocmVmIiwic2V0RGVidWciLCJsaWJyYXJ5RmlsdGVyIiwiTkVFRFNfVEhST1dfRk9SX1NUQUNLIiwic3RhY2siLCJnZXRFcnJvcldpdGhTdGFjayIsInByZXR0eVN0YWNrIiwiZXhjZXB0aW9uIiwibnVtSWdub3JlZEZyYW1lcyIsIm5hbWUiLCJtZXNzYWdlIiwiZnJhbWUiLCJqb2luIiwiZGVwcmVjYXRlZCIsIndoYXQiLCJjb25zb2xlIiwid2FybiIsImRleGllRXJyb3JOYW1lcyIsImlkYkRvbUVycm9yTmFtZXMiLCJlcnJvckxpc3QiLCJkZWZhdWx0VGV4dHMiLCJWZXJzaW9uQ2hhbmdlZCIsIkRhdGFiYXNlQ2xvc2VkIiwiQWJvcnQiLCJUcmFuc2FjdGlvbkluYWN0aXZlIiwiRGV4aWVFcnJvciIsIm1zZyIsIl9lIiwiX3N0YWNrIiwidG9TdHJpbmciLCJnZXRNdWx0aUVycm9yTWVzc2FnZSIsImZhaWx1cmVzIiwiZiIsInYiLCJzIiwiTW9kaWZ5RXJyb3IiLCJzdWNjZXNzQ291bnQiLCJmYWlsZWRLZXlzIiwiQnVsa0Vycm9yIiwiZXJybmFtZXMiLCJCYXNlRXhjZXB0aW9uIiwiZXhjZXB0aW9ucyIsImZ1bGxOYW1lIiwibXNnT3JJbm5lciIsImlubmVyIiwiU3ludGF4IiwiU3ludGF4RXJyb3IiLCJUeXBlIiwiVHlwZUVycm9yIiwiUmFuZ2UiLCJSYW5nZUVycm9yIiwiZXhjZXB0aW9uTWFwIiwibWFwRXJyb3IiLCJkb21FcnJvciIsImZ1bGxOYW1lRXhjZXB0aW9ucyIsIm5vcCIsIm1pcnJvciIsInB1cmVGdW5jdGlvbkNoYWluIiwiZjEiLCJmMiIsImNhbGxCb3RoIiwib24xIiwib24yIiwiaG9va0NyZWF0aW5nQ2hhaW4iLCJyZXMiLCJvbnN1Y2Nlc3MiLCJyZXMyIiwiaG9va0RlbGV0aW5nQ2hhaW4iLCJob29rVXBkYXRpbmdDaGFpbiIsIm1vZGlmaWNhdGlvbnMiLCJyZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbiIsInByb21pc2FibGVDaGFpbiIsInRoZW4iLCJ0aGl6IiwiSU5URVJOQUwiLCJMT05HX1NUQUNLU19DTElQX0xJTUlUIiwiTUFYX0xPTkdfU1RBQ0tTIiwiWk9ORV9FQ0hPX0xJTUlUIiwibmF0aXZlUHJvbWlzZUluc3RhbmNlQW5kUHJvdG8iLCJGdW5jdGlvbiIsIlAiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVkTmF0aXZlUHJvbWlzZSIsIm5hdGl2ZVByb21pc2VQcm90byIsInJlc29sdmVkR2xvYmFsUHJvbWlzZSIsIm5hdGl2ZVByb21pc2VUaGVuIiwiTmF0aXZlUHJvbWlzZSIsIkFzeW5jRnVuY3Rpb24iLCJwYXRjaEdsb2JhbFByb21pc2UiLCJzdGFja19iZWluZ19nZW5lcmF0ZWQiLCJzY2hlZHVsZVBoeXNpY2FsVGljayIsInBoeXNpY2FsVGljayIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJoaWRkZW5EaXYiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImFzYXAkMSIsImNhbGxiYWNrIiwibWljcm90aWNrUXVldWUiLCJuZWVkc05ld1BoeXNpY2FsVGljayIsImlzT3V0c2lkZU1pY3JvVGljayIsInVuaGFuZGxlZEVycm9ycyIsInJlamVjdGluZ0Vycm9ycyIsImN1cnJlbnRGdWxmaWxsZXIiLCJyZWplY3Rpb25NYXBwZXIiLCJnbG9iYWxQU0QiLCJpZCIsInJlZiIsInVuaGFuZGxlZHMiLCJvbnVuaGFuZGxlZCIsImdsb2JhbEVycm9yIiwicGdwIiwiZW52IiwiZmluYWxpemUiLCJ1aCIsIlBTRCIsIm51bVNjaGVkdWxlZENhbGxzIiwidGlja0ZpbmFsaXplcnMiLCJfbGlzdGVuZXJzIiwib251bmNhdGNoZWQiLCJfbGliIiwicHNkIiwiX1BTRCIsIl9zdGFja0hvbGRlciIsIl9wcmV2IiwiX251bVByZXYiLCJfc3RhdGUiLCJfdmFsdWUiLCJoYW5kbGVSZWplY3Rpb24iLCJleGVjdXRlUHJvbWlzZVRhc2siLCJ0aGVuUHJvcCIsIm1pY3JvVGFza0lkIiwidG90YWxFY2hvZXMiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJfdGhpcyIsInBvc3NpYmxlQXdhaXQiLCJkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyIsInByb3BhZ2F0ZVRvTGlzdGVuZXIiLCJMaXN0ZW5lciIsIm5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAiLCJsaW5rVG9QcmV2aW91c1Byb21pc2UiLCJfdGhlbiIsImNhdGNoIiwidHlwZSIsImhhbmRsZXIiLCJlcnIiLCJQcm9taXNlUmVqZWN0IiwiZmluYWxseSIsIm9uRmluYWxseSIsInN0YWNrcyIsImdldFN0YWNrIiwidGltZW91dCIsIm1zIiwiSW5maW5pdHkiLCJoYW5kbGUiLCJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidG9TdHJpbmdUYWciLCJzbmFwU2hvdCIsInpvbmUiLCJhbGwiLCJ2YWx1ZXMiLCJvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMiLCJyZW1haW5pbmciLCJyYWNlIiwibmV3UFNEIiwibmV3U2NvcGUiLCJ1c2VQU0QiLCJzY2hlZHVsZXIiLCJmb2xsb3ciLCJ6b25lUHJvcHMiLCJydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrIiwicHJvbWlzZSIsInNob3VsZEV4ZWN1dGVUaWNrIiwiYmVnaW5NaWNyb1RpY2tTY29wZSIsInByb3BhZ2F0ZUFsbExpc3RlbmVycyIsImVuZE1pY3JvVGlja1Njb3BlIiwicmVhc29uIiwiX3Byb21pc2UiLCJvcmlnUHJvcCIsImFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IiLCJsaXN0ZW5lcnMiLCJsZW4iLCJmaW5hbGl6ZVBoeXNpY2FsVGljayIsImxpc3RlbmVyIiwiY2IiLCJjYWxsTGlzdGVuZXIiLCJyZXQiLCJtYXJrRXJyb3JBc0hhbmRsZWQiLCJsaW1pdCIsImZhaWx1cmUiLCJlcnJvck5hbWUiLCJwcmV2IiwibnVtUHJldiIsIndhc1Jvb3RFeGVjIiwiY2FsbGJhY2tzIiwidW5oYW5kbGVkRXJycyIsInAiLCJmaW5hbGl6ZXJzIiwiZmluYWxpemVyIiwic3BsaWNlIiwic29tZSIsIndyYXAiLCJlcnJvckNhdGNoZXIiLCJvdXRlclNjb3BlIiwic3dpdGNoVG9ab25lIiwidGFzayIsImF3YWl0cyIsImVjaG9lcyIsInRhc2tDb3VudGVyIiwiem9uZVN0YWNrIiwiem9uZUVjaG9lcyIsInpvbmVfaWRfY291bnRlciIsInByb3BzJCQxIiwiYTEiLCJhMiIsInBhcmVudCIsImdsb2JhbEVudiIsIlByb21pc2VQcm9wIiwibnRoZW4iLCJnZXRQYXRjaGVkUHJvbWlzZVRoZW4iLCJndGhlbiIsImluY3JlbWVudEV4cGVjdGVkQXdhaXRzIiwic291cmNlVGFza0lkIiwicG9zc2libGVQcm9taXNlIiwicmVqZWN0aW9uIiwiem9uZUVudGVyRWNobyIsInRhcmdldFpvbmUiLCJ6b25lTGVhdmVFY2hvIiwicG9wIiwiYkVudGVyaW5nWm9uZSIsImN1cnJlbnRab25lIiwiZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayIsIkdsb2JhbFByb21pc2UiLCJ0YXJnZXRFbnYiLCJhMyIsImpvYiIsIm91dGVyWm9uZSIsIm9yaWdUaGVuIiwib25SZXNvbHZlZCIsIlVOSEFORExFRFJFSkVDVElPTiIsImV2ZW50IiwiZXZlbnREYXRhIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImRpc3BhdGNoRXZlbnQiLCJQcm9taXNlUmVqZWN0aW9uRXZlbnQiLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsIl8iLCJkZWZhdWx0UHJldmVudGVkIiwiRXZlbnRzIiwiY3R4IiwiZXZzIiwiZXZlbnROYW1lIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsImFkZEV2ZW50VHlwZSIsImFkZCIsImNoYWluRnVuY3Rpb24iLCJkZWZhdWx0RnVuY3Rpb24iLCJhZGRDb25maWd1cmVkRXZlbnRzIiwiY29udGV4dCIsInN1YnNjcmliZXJzIiwiZmlyZSIsInVuc3Vic2NyaWJlIiwiY2ZnIiwiZmlyZUV2ZW50IiwiSW52YWxpZEFyZ3VtZW50IiwiREVYSUVfVkVSU0lPTiIsIm1heFN0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1heEtleSIsIklEQktleVJhbmdlIiwib25seSIsIm1pbktleSIsIklOVkFMSURfS0VZX0FSR1VNRU5UIiwiU1RSSU5HX0VYUEVDVEVEIiwiY29ubmVjdGlvbnMiLCJpc0lFT3JFZGdlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyIsImhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlIiwiZGV4aWVTdGFja0ZyYW1lRmlsdGVyIiwiZGJOYW1lc0RCIiwiZGJOYW1lIiwiZGVwcyIsImRlcGVuZGVuY2llcyIsIm9wdHMiLCJhZGRvbnMiLCJhdXRvT3BlbiIsImluZGV4ZWREQiIsImdsb2JhbFNjaGVtYSIsIl9kYlNjaGVtYSIsInZlcnNpb25zIiwiZGJTdG9yZU5hbWVzIiwiYWxsVGFibGVzIiwiaWRiZGIiLCJkYk9wZW5FcnJvciIsImlzQmVpbmdPcGVuZWQiLCJvblJlYWR5QmVpbmdGaXJlZCIsIm9wZW5Db21wbGV0ZSIsIlJFQURPTkxZIiwiUkVBRFdSSVRFIiwiZGIiLCJkYlJlYWR5UmVzb2x2ZSIsImRiUmVhZHlQcm9taXNlIiwiY2FuY2VsT3BlbiIsIm9wZW5DYW5jZWxsZXIiLCJhdXRvU2NoZW1hIiwiaGFzTmF0aXZlR2V0RGF0YWJhc2VOYW1lcyIsImdldE5hdGl2ZUdldERhdGFiYXNlTmFtZXNGbiIsImhhc0dldEFsbCIsImluaXQiLCJvbiIsImV2IiwibmV3VmVyc2lvbiIsImNsb3NlIiwib2xkVmVyc2lvbiIsInZlcnNpb24iLCJ2ZXJzaW9uTnVtYmVyIiwiU2NoZW1hIiwidmVybm8iLCJNYXRoIiwibWF4IiwidmVyc2lvbkluc3RhbmNlIiwiX2NmZyIsIlZlcnNpb24iLCJzb3J0IiwibG93ZXJWZXJzaW9uRmlyc3QiLCJzdG9yZXNTb3VyY2UiLCJkYnNjaGVtYSIsInRhYmxlcyIsImNvbnRlbnRVcGdyYWRlIiwic3RvcmVzIiwic3RvcmVzU3BlYyIsIl9wYXJzZVN0b3Jlc1NwZWMiLCJyZW1vdmVUYWJsZXNBcGkiLCJUcmFuc2FjdGlvbiIsInNldEFwaU9uUGxhY2UiLCJ1cGdyYWRlIiwidXBncmFkZUZ1bmN0aW9uIiwib3V0U2NoZW1hIiwidGFibGVOYW1lIiwiaW5zdGFuY2VUZW1wbGF0ZSIsImluZGV4ZXMiLCJwYXJzZUluZGV4U3ludGF4IiwicHJpbUtleSIsInNoaWZ0IiwibXVsdGkiLCJhdXRvIiwiaWR4IiwiY29tcG91bmQiLCJUYWJsZVNjaGVtYSIsInJ1blVwZ3JhZGVycyIsImlkYnRyYW5zIiwidHJhbnMiLCJfY3JlYXRlVHJhbnNhY3Rpb24iLCJfY29tcGxldGlvbiIsInJlamVjdFRyYW5zYWN0aW9uIiwiX3JlamVjdCIsImNyZWF0ZVRhYmxlIiwicG9wdWxhdGUiLCJ1cGRhdGVUYWJsZXNBbmRJbmRleGVzIiwicXVldWUiLCJvbGRWZXJzaW9uU3RydWN0IiwiVXBncmFkZSIsImFueUNvbnRlbnRVcGdyYWRlckhhc1J1biIsInZlcnNUb1J1biIsIm9sZFNjaGVtYSIsIm5ld1NjaGVtYSIsImFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzIiwiZGlmZiIsImdldFNjaGVtYURpZmYiLCJ0dXBsZSIsImNoYW5nZSIsInJlY3JlYXRlIiwic3RvcmUiLCJvYmplY3RTdG9yZSIsImFkZEluZGV4IiwiZGVsZXRlSW5kZXgiLCJkZWwiLCJpZHhOYW1lIiwiZGVsZXRlUmVtb3ZlZFRhYmxlcyIsInJ1blF1ZXVlIiwiY3JlYXRlTWlzc2luZ1RhYmxlcyIsInRhYmxlIiwib2xkRGVmIiwibmV3RGVmIiwiZGVmIiwic3JjIiwib2xkSW5kZXhlcyIsImlkeEJ5TmFtZSIsIm5ld0luZGV4ZXMiLCJvbGRJZHgiLCJuZXdJZHgiLCJjcmVhdGVPYmplY3RTdG9yZSIsImF1dG9JbmNyZW1lbnQiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJzdG9yZU5hbWUiLCJkZWxldGVPYmplY3RTdG9yZSIsImNyZWF0ZUluZGV4IiwidW5pcXVlIiwibXVsdGlFbnRyeSIsIl9hbGxUYWJsZXMiLCJtb2RlIiwic3RvcmVOYW1lcyIsInBhcmVudFRyYW5zYWN0aW9uIiwidGVtcFRyYW5zYWN0aW9uIiwibGV0VGhyb3VnaCIsIm9wZW4iLCJfd2hlblJlYWR5IiwicmVzb2x2ZURiUmVhZHkiLCJ1cGdyYWRlVHJhbnNhY3Rpb24iLCJNaXNzaW5nQVBJIiwicmVxIiwicm91bmQiLCJldmVudFJlamVjdEhhbmRsZXIiLCJvbmJsb2NrZWQiLCJmaXJlT25CbG9ja2VkIiwib251cGdyYWRlbmVlZGVkIiwidHJhbnNhY3Rpb24iLCJfYWxsb3dFbXB0eURCIiwicHJldmVudERlZmF1bHQiLCJhYm9ydCIsImRlbHJlcSIsImRlbGV0ZURhdGFiYXNlIiwiTm9TdWNoRGF0YWJhc2UiLCJvbGRWZXIiLCJwb3ciLCJyZWFkR2xvYmFsU2NoZW1hIiwic2FmYXJpTXVsdGlTdG9yZUZpeCIsIm9udmVyc2lvbmNoYW5nZSIsIl92Y0ZpcmVkIiwiZGJuYW1lcyIsInB1dCIsInZpcCIsInJlYWR5IiwiZmlyZVJlbWFpbmRlcnMiLCJyZW1haW5kZXJzIiwiZGVsZXRlIiwiaGFzQXJndW1lbnRzIiwiZG9EZWxldGUiLCJiYWNrZW5kREIiLCJpc09wZW4iLCJoYXNCZWVuQ2xvc2VkIiwiaGFzRmFpbGVkIiwiZHluYW1pY2FsbHlPcGVuZWQiLCJiU3RpY2t5IiwiZXh0cmFjdFRyYW5zYWN0aW9uQXJncyIsIl90cmFuc2FjdGlvbiIsIl90YWJsZUFyZ3NfIiwic2NvcGVGdW5jIiwib25seUlmQ29tcGF0aWJsZSIsInJlcGxhY2UiLCJUYWJsZSIsIlN1YlRyYW5zYWN0aW9uIiwiYWN0aXZlIiwiZW50ZXJUcmFuc2FjdGlvblNjb3BlIiwidHJhbnNsZXNzIiwicmV0dXJuVmFsdWUiLCJwcm9taXNlRm9sbG93ZWQiLCJkZWNyZW1lbnRvciIsInRocm93IiwiYXdhaXRJdGVyYXRvciIsIlByZW1hdHVyZUNvbW1pdCIsIl9yZXNvbHZlIiwiSW52YWxpZFRhYmxlIiwidGFibGVTY2hlbWEiLCJvcHRpb25hbFRyYW5zIiwic2NoZW1hIiwiX3R4IiwiaG9vayIsIkJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbCIsInN1cHBvcnRIb29rcyIsImhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciIsImJ1bGtEZWxldGUiLCJpZGJzdG9yZSIsImtleXNPclR1cGxlcyIsImhhc0RlbGV0ZUhvb2siLCJkZWxldGluZ0hvb2siLCJsYXN0SXRlbSIsImhvb2tDdHgiLCJlcnJvckhhbmRsZXIiLCJzdWNjZXNzSGFuZGxlciIsImhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIiLCJfaG9va0N0eCIsIl90cmFucyIsImdldFRyYW5zYWN0aW9uIiwid3JpdGVMb2NrZWQiLCJfaWRic3RvcmUiLCJnZXRJREJPYmplY3RTdG9yZSIsInN1cHBseUlkYlN0b3JlIiwiTm90Rm91bmQiLCJrZXlPckNyaXQiLCJ3aGVyZSIsImZpcnN0IiwicmVhZGluZyIsImluZGV4T3JDcml0IiwiV2hlcmVDbGF1c2UiLCJrZXlQYXRocyIsImVxdWFscyIsImNvbXBvdW5kSW5kZXgiLCJpeCIsImV2ZXJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNpbXBsZUluZGV4IiwiciIsImNvbWJpbmUiLCJjb3VudCIsInRvQ29sbGVjdGlvbiIsIm9mZnNldCIsIm51bVJvd3MiLCJyZXZlcnNlIiwiZmlsdGVyRnVuY3Rpb24iLCJhbmQiLCJlYWNoIiwidG9BcnJheSIsIm9yZGVyQnkiLCJpbmRleCIsIkNvbGxlY3Rpb24iLCJtYXBUb0NsYXNzIiwic3RydWN0dXJlIiwibWFwcGVkQ2xhc3MiLCJhcHBseVN0cnVjdHVyZSIsInJlYWRIb29rIiwiZGVmaW5lQ2xhc3MiLCJrZXlzJCQxIiwiZGVsZXRpbmciLCJhbnlPZiIsImJ1bGtQdXQiLCJvYmplY3RzIiwibnVtT2JqcyIsImNyZWF0aW5nIiwidXBkYXRpbmciLCJldmVudFN1Y2Nlc3NIYW5kbGVyIiwiZWZmZWN0aXZlS2V5cyIsIm8iLCJvYmplY3RMb29rdXAiLCJidWxrQWRkIiwibW9kaWZ5Iiwib2Jqc1RvQWRkIiwia2V5c1RvQWRkIiwibGFzdEFkZGVkS2V5IiwibGFzdEVmZmVjdGl2ZUtleSIsImNyZWF0aW5nSG9vayIsImVmZmVjdGl2ZUtleSIsImtleVRvVXNlIiwidXBkYXRpbmdIb29rIiwidGFyZ2V0IiwiY2xlYXIiLCJ1cGRhdGUiLCJrZXlPck9iamVjdCIsIl9yZWN1bG9jayIsIl9ibG9ja2VkRnVuY3MiLCJfd2FpdGluZ0ZvciIsIl93YWl0aW5nUXVldWUiLCJfc3BpbkNvdW50IiwiY29tcGxldGUiLCJ3YXNBY3RpdmUiLCJlcnJvciIsIl9sb2NrIiwibG9ja093bmVyRm9yIiwiX3VubG9jayIsIl9sb2NrZWQiLCJmbkFuZFBTRCIsIk9wZW5GYWlsZWQiLCJvbmFib3J0Iiwib25jb21wbGV0ZSIsImJXcml0ZUxvY2siLCJSZWFkT25seSIsIl9yb290Iiwid2FpdEZvciIsInJvb3QiLCJzcGluIiwiY3VycmVudFdhaXRQcm9taXNlIiwib3JDb2xsZWN0aW9uIiwiX2N0eCIsIm9yIiwiZmFpbCIsImNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIiwiVCIsImNvbGxlY3Rpb24iLCJlbXB0eUNvbGxlY3Rpb24iLCJ3aGVyZUNsYXVzZSIsInVwcGVyRmFjdG9yeSIsImRpciIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJsb3dlckZhY3RvcnkiLCJuZXh0Q2FzaW5nIiwibG93ZXJLZXkiLCJ1cHBlck5lZWRsZSIsImxvd2VyTmVlZGxlIiwiY21wIiwibWluIiwibGxwIiwibHdyS2V5Q2hhciIsImFkZElnbm9yZUNhc2VBbGdvcml0aG0iLCJtYXRjaCIsIm5lZWRsZXMiLCJzdWZmaXgiLCJ1cHBlciIsImxvd2VyIiwiY29tcGFyZSIsInVwcGVyTmVlZGxlcyIsImxvd2VyTmVlZGxlcyIsImRpcmVjdGlvbiIsIm5leHRLZXlTdWZmaXgiLCJuZWVkbGVzTGVuIiwiaW5pdERpcmVjdGlvbiIsInNpbXBsZUNvbXBhcmUiLCJzaW1wbGVDb21wYXJlUmV2ZXJzZSIsIm5lZWRsZUJvdW5kcyIsIm5lZWRsZSIsIm5iIiwiYyIsImJvdW5kIiwiX29uZGlyZWN0aW9uY2hhbmdlIiwiZmlyc3RQb3NzaWJsZU5lZWRsZSIsIl9hZGRBbGdvcml0aG0iLCJjdXJzb3IiLCJhZHZhbmNlIiwibG93ZXN0UG9zc2libGVDYXNpbmciLCJjYXNpbmciLCJjb250aW51ZSIsImJldHdlZW4iLCJpbmNsdWRlTG93ZXIiLCJpbmNsdWRlVXBwZXIiLCJhYm92ZSIsImxvd2VyQm91bmQiLCJhYm92ZU9yRXF1YWwiLCJiZWxvdyIsInVwcGVyQm91bmQiLCJiZWxvd09yRXF1YWwiLCJzdGFydHNXaXRoIiwic3RyIiwic3RhcnRzV2l0aElnbm9yZUNhc2UiLCJlcXVhbHNJZ25vcmVDYXNlIiwiYW55T2ZJZ25vcmVDYXNlIiwic3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSIsIm4iLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwibm90RXF1YWwiLCJpbkFueVJhbmdlIiwiaW5jbHVkZUxvd2VycyIsImluY2x1ZGVVcHBlcnMiLCJub25lT2YiLCJyYW5nZXMiLCJyYW5nZSIsImFkZFJhbmdlIiwibmV3UmFuZ2UiLCJzb3J0RGlyZWN0aW9uIiwicmFuZ2VTb3J0ZXIiLCJrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSIsImtleUlzQmVmb3JlQ3VycmVudEVudHJ5Iiwia2V5V2l0aGluQ3VycmVudFJhbmdlIiwiY2hlY2tLZXkiLCJzdGFydHNXaXRoQW55T2YiLCJrZXlSYW5nZUdlbmVyYXRvciIsImtleVJhbmdlIiwid2hlcmVDdHgiLCJpc1ByaW1LZXkiLCJrZXlzT25seSIsImFsZ29yaXRobSIsInJlcGxheUZpbHRlciIsImp1c3RMaW1pdCIsImlzTWF0Y2giLCJ2YWx1ZU1hcHBlciIsImlzUGxhaW5LZXlSYW5nZSIsImlnbm9yZUxpbWl0RmlsdGVyIiwiYWRkRmlsdGVyIiwiYWRkUmVwbGF5RmlsdGVyIiwiaXNMaW1pdEZpbHRlciIsImN1cnIiLCJhZGRNYXRjaEZpbHRlciIsImdldEluZGV4T3JTdG9yZSIsImluZGV4U3BlYyIsIm9wZW5DdXJzb3IiLCJpZHhPclN0b3JlIiwib3BlbktleUN1cnNvciIsIml0ZXIiLCJpdGVyYXRlIiwicmVzb2x2ZWQiLCJyZXNvbHZlYm90aCIsInVuaW9uIiwicHJpbWFyeUtleSIsIlVpbnQ4QXJyYXkiLCJfaXRlcmF0ZSIsIl9yZWFkIiwiX3dyaXRlIiwiY2xvbmUiLCJyYXciLCJzb3J0QnkiLCJwYXJ0cyIsImxhc3RQYXJ0IiwibGFzdEluZGV4IiwiZ2V0dmFsIiwib3JkZXIiLCJzb3J0ZXIiLCJhVmFsIiwiYlZhbCIsInJlYWRpbmdIb29rIiwiZ2V0QWxsIiwiYXJyYXlDb21wbGV0ZSIsIm9mZnNldExlZnQiLCJyb3dzTGVmdCIsInVudGlsIiwiYkluY2x1ZGVTdG9wRW50cnkiLCJsYXN0IiwiaW5kZXhOYW1lIiwiZGVzYyIsImVhY2hLZXkiLCJlYWNoVW5pcXVlS2V5IiwiZWFjaFByaW1hcnlLZXkiLCJwcmltYXJ5S2V5cyIsImdldEFsbEtleXMiLCJ1bmlxdWVLZXlzIiwiZmlyc3RLZXkiLCJsYXN0S2V5IiwiZGlzdGluY3QiLCJzdHJLZXkiLCJmb3VuZCIsImNoYW5nZXMiLCJtb2RpZnllciIsIm9yaWdJdGVtIiwib2JqZWN0RGlmZiIsImFkZGl0aW9uYWxDaGFuZ2VzIiwibnVtS2V5cyIsImFueXRoaW5nTW9kaWZpZWQiLCJvcmlnQ2hhbmdlcyIsIml0ZXJhdGlvbkNvbXBsZXRlIiwiZmFpbEtleXMiLCJjdXJyZW50S2V5IiwibW9kaWZ5SXRlbSIsInRoaXNDb250ZXh0IiwiY2hlY2tGaW5pc2hlZCIsImJEZWxldGUiLCJkb1JlamVjdCIsImNvdW50UmVxIiwiZGVsUmVxIiwiQ0hVTktTSVpFIiwidG90YWxDb3VudCIsIm5leHRDaHVuayIsIm9ianMiLCJ0YWJsZU5hbWVzIiwibWFwcGVkRm4iLCJ3cmFwcGVkRm4iLCJmaWx0ZXJfcmVjb3JkIiwiYWR2YW5jZXIiLCJ0cmltIiwiSW5kZXhTcGVjIiwia2V5MSIsImtleTIiLCJmaWx0ZXIxIiwiZmlsdGVyMiIsImRvdHRlZCIsImoiLCJpbmRleE5hbWVzIiwiaWRiaW5kZXgiLCJkZXhpZU5hbWUiLCJXb3JrZXJHbG9iYWxTY29wZSIsInBhcnNlVHlwZSIsIm1lbWJlciIsImhvb2tTdWNjZXNzSGFuZGxlciIsImhvb2tFcnJvckhhbmRsZXIiLCJzdG9wUHJvcGFnYXRpb24iLCJjYWxsTmV4dCIsImRvVGhyb3ciLCJvblN1Y2Nlc3MiLCJzdGVwIiwib25FcnJvciIsImdldE5leHQiLCJrZXlQYXRoU3JjIiwiZ2V0RGF0YWJhc2VOYW1lcyIsIndlYmtpdEdldERhdGFiYXNlTmFtZXMiLCJkYXRhYmFzZU5hbWUiLCJleGlzdHMiLCJOb1N1Y2hEYXRhYmFzZUVycm9yIiwiQ2xhc3MiLCJwcm9wZXJ0aWVzIiwiaWdub3JlVHJhbnNhY3Rpb24iLCJhc3luYyIsImdlbmVyYXRvckZuIiwic3Bhd24iLCJjdXJyZW50VHJhbnNhY3Rpb24iLCJwcm9taXNlT3JGdW5jdGlvbiIsIm9wdGlvbmFsVGltZW91dCIsIk11bHRpTW9kaWZ5RXJyb3IiLCJNb2RpZnkiLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsIndlYmtpdElEQktleVJhbmdlIiwic2VtVmVyIiwicGFyc2VJbnQiLCJkZWZhdWx0IiwiREJOQU1FUyIsImxvY2FsU3RvcmFnZSIsInBhcnNlIiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7OztBQWFDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLFlBQU9DLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsT0FBT0MsTUFBUCxLQUFrQixXQUFqRCxHQUErREEsT0FBT0QsT0FBUCxHQUFpQkQsU0FBaEYsR0FDQSxPQUFPRyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxPQUFPQyxHQUF2QyxHQUE2Q0QsT0FBT0gsT0FBUCxDQUE3QyxHQUNDRCxPQUFPTSxLQUFQLEdBQWVMLFNBRmhCO0FBR0EsQ0FKQSxhQUlRLFlBQVk7QUFBRTs7QUFFdkIsUUFBSU0sT0FBT0MsT0FBT0QsSUFBbEI7QUFDQSxRQUFJRSxVQUFVQyxNQUFNRCxPQUFwQjtBQUNBLFFBQUlFLFVBQVUsT0FBT0MsSUFBUCxLQUFnQixXQUFoQixHQUE4QkEsSUFBOUIsR0FDVixPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUNJYixNQUZSO0FBR0EsYUFBU2MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUJDLFNBQXJCLEVBQWdDO0FBQzVCLFlBQUksUUFBT0EsU0FBUCx5Q0FBT0EsU0FBUCxPQUFxQixRQUF6QixFQUNJLE9BQU9ELEdBQVA7QUFDSlIsYUFBS1MsU0FBTCxFQUFnQkMsT0FBaEIsQ0FBd0IsVUFBVUMsR0FBVixFQUFlO0FBQ25DSCxnQkFBSUcsR0FBSixJQUFXRixVQUFVRSxHQUFWLENBQVg7QUFDSCxTQUZEO0FBR0EsZUFBT0gsR0FBUDtBQUNIO0FBQ0QsUUFBSUksV0FBV1gsT0FBT1ksY0FBdEI7QUFDQSxRQUFJQyxVQUFVLEdBQUdDLGNBQWpCO0FBQ0EsYUFBU0MsTUFBVCxDQUFnQlIsR0FBaEIsRUFBcUJTLElBQXJCLEVBQTJCO0FBQ3ZCLGVBQU9ILFFBQVFJLElBQVIsQ0FBYVYsR0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQUEsZUFBT0E7QUFoTUUsS0FBYjtBQWtNQTtBQUNBMk0sWUFBUTJCLGVBQVIsR0FBMEJ4RCxRQUExQjtBQUNBO0FBQ0FnUCxnQkFBWSxJQUFJOVosS0FBSixDQUFVLFdBQVYsQ0FBWjtBQUNBOFosY0FBVW1DLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUJlLE1BQXJCLENBQTRCLEVBQUVxRyxTQUFTLE1BQVgsRUFBNUI7QUFDQSxLQUFDLFlBQVk7QUFDVDtBQUNBLFlBQUk2VyxVQUFVLHFCQUFkO0FBQ0EsWUFBSSxRQUFPQyxZQUFQLHlDQUFPQSxZQUFQLE9BQXdCaDFCLFNBQXhCLElBQXFDOUUsUUFBUW9OLFFBQVIsS0FBcUJ0SSxTQUE5RCxFQUNJLElBQUk7QUFDQTtBQUNBeWlCLGlCQUFLd1MsS0FBTCxDQUFXRCxhQUFhRSxPQUFiLENBQXFCSCxPQUFyQixLQUFpQyxJQUE1QyxFQUNLdjVCLE9BREwsQ0FDYSxVQUFVd0gsSUFBVixFQUFnQjtBQUFFLHVCQUFPMlIsVUFBVXVKLE9BQVYsQ0FBa0JDLEdBQWxCLENBQXNCLEVBQUVuYixNQUFNQSxJQUFSLEVBQXRCLEVBQXNDMEksS0FBdEMsQ0FBNEM1RixHQUE1QyxDQUFQO0FBQTBELGFBRHpGO0FBRUFrdkIseUJBQWFHLFVBQWIsQ0FBd0JKLE9BQXhCO0FBQ0gsU0FMRCxDQU1BLE9BQU83d0IsRUFBUCxFQUFXLENBQUc7QUFDckIsS0FYRDs7QUFhQSxXQUFPckosS0FBUDtBQUVDLENBejJJQSxDQUFEO0FBMDJJQSIsImZpbGUiOiJkZXhpZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBEZXhpZS5qcyAtIGEgbWluaW1hbGlzdGljIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCeSBEYXZpZCBGYWhsYW5kZXIsIGRhdmlkLmZhaGxhbmRlckBnbWFpbC5jb21cbiAqXG4gKiBWZXJzaW9uIDIuMC4yLCBUaHUgTWFyIDAxIDIwMThcbiAqXG4gKiBodHRwOi8vZGV4aWUub3JnXG4gKlxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuICovXG4gXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRGV4aWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgX2dsb2JhbCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICAgICAgZ2xvYmFsO1xuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9oYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG59XG5mdW5jdGlvbiBwcm9wcyhwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG4gICAgfSk7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5mdW5jdGlvbiBzZXRQcm9wKG9iaiwgcHJvcCwgZnVuY3Rpb25PckdldFNldCwgb3B0aW9ucykge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuICAgICAgICB7IHZhbHVlOiBmdW5jdGlvbk9yR2V0U2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBzZXRQcm9wKENoaWxkLnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIHZhciBwZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApLCBwcm90bztcbiAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbn1cbnZhciBfc2xpY2UgPSBbXS5zbGljZTtcbmZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJncywgc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuICAgIHJldHVybiBvdmVycmlkZWRGYWN0b3J5KG9yaWdGdW5jKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChiKSB7XG4gICAgaWYgKCFiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xufVxuZnVuY3Rpb24gYXNhcChmbikge1xuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSlcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICBlbHNlXG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG4vKiogR2VuZXJhdGUgYW4gb2JqZWN0IChoYXNoIG1hcCkgYmFzZWQgb24gZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0gZXh0cmFjdG9yIEZ1bmN0aW9uIHRha2luZyBhbiBhcnJheSBpdGVtIGFuZCBpdHMgaW5kZXggYW5kIHJldHVybmluZyBhbiBhcnJheSBvZiAyIGl0ZW1zIChba2V5LCB2YWx1ZV0pIHRvXG4gKiAgICAgICAgaW5zdGVydCBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdCBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZVxuICogICAgICAgIGN1cnJlbnQgaXRlbSB3b250IGFmZmVjdCB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnJheSwgZXh0cmFjdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtLCBpKSB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpXG4gICAgICAgICAgICByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiB0cnljYXRjaGVyKGZuLCByZWplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvbmVycm9yLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBvbmVycm9yICYmIG9uZXJyb3IoZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREIvI3N0ZXBzLWZvci1leHRyYWN0aW5nLWEta2V5LWZyb20tYS12YWx1ZS11c2luZy1hLWtleS1wYXRoXG4gICAgaWYgKGhhc093bihvYmosIGtleVBhdGgpKVxuICAgICAgICByZXR1cm4gb2JqW2tleVBhdGhdOyAvLyBUaGlzIGxpbmUgaXMgbW92ZWQgZnJvbSBsYXN0IHRvIGZpcnN0IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZS5cbiAgICBpZiAoIWtleVBhdGgpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEtleVBhdGggPSBrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0tleVBhdGggPSBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdLZXlQYXRoID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iailcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSAob2JqW2N1cnJlbnRLZXlQYXRoXSA9IHt9KTtcbiAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaW5uZXJPYmosIHJlbWFpbmluZ0tleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbiAoa3ApIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICB2YXIgcnYgPSB7fTtcbiAgICBmb3IgKHZhciBtIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICBydlttXSA9IG9ialttXTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxudmFyIGNvbmNhdCA9IFtdLmNvbmNhdDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xufVxuLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtXG52YXIgaW50cmluc2ljVHlwZXMgPSBcIkJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxBcnJheUJ1ZmZlcixEYXRhVmlldyxVaW50OENsYW1wZWRBcnJheSxJbWFnZURhdGEsTWFwLFNldFwiXG4gICAgLnNwbGl0KCcsJykuY29uY2F0KGZsYXR0ZW4oWzgsIDE2LCAzMiwgNjRdLm1hcChmdW5jdGlvbiAobnVtKSB7IHJldHVybiBbXCJJbnRcIiwgXCJVaW50XCIsIFwiRmxvYXRcIl0ubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICsgbnVtICsgXCJBcnJheVwiOyB9KTsgfSkpKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIF9nbG9iYWxbdF07IH0pLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2dsb2JhbFt0XTsgfSk7XG5mdW5jdGlvbiBkZWVwQ2xvbmUoYW55KSB7XG4gICAgaWYgKCFhbnkgfHwgdHlwZW9mIGFueSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBhbnk7XG4gICAgdmFyIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbnkubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBydi5wdXNoKGRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5pbmRleE9mKGFueS5jb25zdHJ1Y3RvcikgPj0gMCkge1xuICAgICAgICBydiA9IGFueTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ2ID0gYW55LmNvbnN0cnVjdG9yID8gT2JqZWN0LmNyZWF0ZShhbnkuY29uc3RydWN0b3IucHJvdG90eXBlKSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFueSkge1xuICAgICAgICAgICAgaWYgKGhhc093bihhbnksIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBkZWVwQ2xvbmUoYW55W3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBnZXRPYmplY3REaWZmKGEsIGIsIHJ2LCBwcmZ4KSB7XG4gICAgLy8gQ29tcGFyZXMgb2JqZWN0cyBhIGFuZCBiIGFuZCBwcm9kdWNlcyBhIGRpZmYgb2JqZWN0LlxuICAgIHJ2ID0gcnYgfHwge307XG4gICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAga2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICghaGFzT3duKGIsIHByb3ApKVxuICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkOyAvLyBQcm9wZXJ0eSByZW1vdmVkXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFwID0gYVtwcm9wXSwgYnAgPSBiW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJwID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIGFwICYmIGJwICYmXG4gICAgICAgICAgICAgICAgLy8gTm93IGNvbXBhcmUgY29uc3RydWN0b3JzIGFyZSBzYW1lIChub3QgZXF1YWwgYmVjYXVzZSB3b250IHdvcmsgaW4gU2FmYXJpKVxuICAgICAgICAgICAgICAgICgnJyArIGFwLmNvbnN0cnVjdG9yKSA9PT0gKCcnICsgYnAuY29uc3RydWN0b3IpKVxuICAgICAgICAgICAgICAgIC8vIFNhbWUgdHlwZSBvZiBvYmplY3QgYnV0IGl0cyBwcm9wZXJ0aWVzIG1heSBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBnZXRPYmplY3REaWZmKGFwLCBicCwgcnYsIHByZnggKyBwcm9wICsgXCIuXCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoYXAgIT09IGJwKVxuICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByaW1pdGl2ZSB2YWx1ZSBjaGFuZ2VkXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBrZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGFkZGVkXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnY7XG59XG4vLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBpdGVyYWJsZSBvciBhcnJheS1saWtlLCByZXR1cm4gaXQgYXMgYW4gYXJyYXlcbnZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBnZXRJdGVyYXRvck9mID0gaXRlcmF0b3JTeW1ib2wgPyBmdW5jdGlvbiAoeCkge1xuICAgIHZhciBpO1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcbn0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xudmFyIE5PX0NIQVJfQVJSQVkgPSB7fTtcbi8vIFRha2VzIG9uZSBvciBzZXZlcmFsIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBhcnJheSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGNyaXRlcmFzOlxuLy8gKiBJZiBzZXZlcmFsIGFyZ3VtZW50cyBwcm92aWRlZCwgcmV0dXJuIGFyZ3VtZW50cyBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgaW4gYSB3YXkgdGhhdFxuLy8gICBzdGlsbCBhbGxvd3MgamF2YXNjcmlwdCBlbmdpbmUgdG8gb3B0aW1pemUgdGhlIGNvZGUuXG4vLyAqIElmIHNpbmdsZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgcmV0dXJuIGEgY2xvbmUgb2YgaXQuXG4vLyAqIElmIHRoaXMtcG9pbnRlciBlcXVhbHMgTk9fQ0hBUl9BUlJBWSwgZG9uJ3QgYWNjZXB0IHN0cmluZ3MgYXMgdmFsaWQgaXRlcmFibGVzIGFzIGEgc3BlY2lhbFxuLy8gICBjYXNlIHRvIHRoZSB0d28gYnVsbGV0cyBiZWxvdy5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGl0ZXJhYmxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheS5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFycmF5LWxpa2UgKGhhcyBsZW5ndGggb2YgdHlwZSBudW1iZXIpLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5LlxuZnVuY3Rpb24gZ2V0QXJyYXlPZihhcnJheUxpa2UpIHtcbiAgICB2YXIgaSwgYSwgeCwgaXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXlMaWtlKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMgPT09IE5PX0NIQVJfQVJSQVkgJiYgdHlwZW9mIGFycmF5TGlrZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKVxuICAgICAgICAgICAgICAgIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgfVxuICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gYTtcbn1cblxuLy8gQnkgZGVmYXVsdCwgZGVidWcgd2lsbCBiZSB0cnVlIG9ubHkgaWYgcGxhdGZvcm0gaXMgYSB3ZWIgcGxhdGZvcm0gYW5kIGl0cyBwYWdlIGlzIHNlcnZlZCBmcm9tIGxvY2FsaG9zdC5cbi8vIFdoZW4gZGVidWcgPSB0cnVlLCBlcnJvcidzIHN0YWNrcyB3aWxsIGNvbnRhaW4gYXN5bmNyb25pYyBsb25nIHN0YWNrcy5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBCeSBkZWZhdWx0LCB1c2UgZGVidWcgbW9kZSBpZiBzZXJ2ZWQgZnJvbSBsb2NhbGhvc3QuXG4gICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgIGRlYnVnID0gdmFsdWU7XG4gICAgbGlicmFyeUZpbHRlciA9IGZpbHRlcjtcbn1cbnZhciBsaWJyYXJ5RmlsdGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbnZhciBORUVEU19USFJPV19GT1JfU1RBQ0sgPSAhbmV3IEVycm9yKFwiXCIpLnN0YWNrO1xuZnVuY3Rpb24gZ2V0RXJyb3JXaXRoU3RhY2soKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKE5FRURTX1RIUk9XX0ZPUl9TVEFDSylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIERvaW5nIHNvbWV0aGluZyBuYXVnaHR5IGluIHN0cmljdCBtb2RlIGhlcmUgdG8gdHJpZ2dlciBhIHNwZWNpZmljIGVycm9yXG4gICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSBleHBsaWNpdGVseSBpZ25vcmVkIGluIGRlYnVnZ2VyJ3MgZXhjZXB0aW9uIHNldHRpbmdzLlxuICAgICAgICAgICAgLy8gSWYgd2UnZCBqdXN0IHRocm93IG5ldyBFcnJvcigpIGhlcmUsIElFJ3MgZGVidWdnZXIncyBleGNlcHRpb24gc2V0dGluZ3NcbiAgICAgICAgICAgIC8vIHdpbGwganVzdCBjb25zaWRlciBpdCBhcyBcImV4Y2VwdGlvbiB0aHJvd24gYnkgamF2YXNjcmlwdCBjb2RlXCIgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyB5b3Ugd291bGRuJ3Qgd2FudCBpdCB0byBpZ25vcmUuXG4gICAgICAgICAgICBnZXRFcnJvcldpdGhTdGFjay5hcmd1bWVudHM7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gRmFsbGJhY2sgaWYgYWJvdmUgbGluZSBkb24ndCB0aHJvdy5cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiBwcmV0dHlTdGFjayhleGNlcHRpb24sIG51bUlnbm9yZWRGcmFtZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBleGNlcHRpb24uc3RhY2s7XG4gICAgaWYgKCFzdGFjaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgbnVtSWdub3JlZEZyYW1lcyA9IChudW1JZ25vcmVkRnJhbWVzIHx8IDApO1xuICAgIGlmIChzdGFjay5pbmRleE9mKGV4Y2VwdGlvbi5uYW1lKSA9PT0gMClcbiAgICAgICAgbnVtSWdub3JlZEZyYW1lcyArPSAoZXhjZXB0aW9uLm5hbWUgKyBleGNlcHRpb24ubWVzc2FnZSkuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xcbicpXG4gICAgICAgIC5zbGljZShudW1JZ25vcmVkRnJhbWVzKVxuICAgICAgICAuZmlsdGVyKGxpYnJhcnlGaWx0ZXIpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiBcIlxcblwiICsgZnJhbWU7IH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQod2hhdCwgZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLndhcm4od2hhdCArIFwiIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlci9EZXhpZS5qcy93aWtpL0RlcHJlY2F0aW9ucy4gXCIgKyBwcmV0dHlTdGFjayhnZXRFcnJvcldpdGhTdGFjaygpLCAxKSk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbnZhciBkZXhpZUVycm9yTmFtZXMgPSBbXG4gICAgJ01vZGlmeScsXG4gICAgJ0J1bGsnLFxuICAgICdPcGVuRmFpbGVkJyxcbiAgICAnVmVyc2lvbkNoYW5nZScsXG4gICAgJ1NjaGVtYScsXG4gICAgJ1VwZ3JhZGUnLFxuICAgICdJbnZhbGlkVGFibGUnLFxuICAgICdNaXNzaW5nQVBJJyxcbiAgICAnTm9TdWNoRGF0YWJhc2UnLFxuICAgICdJbnZhbGlkQXJndW1lbnQnLFxuICAgICdTdWJUcmFuc2FjdGlvbicsXG4gICAgJ1Vuc3VwcG9ydGVkJyxcbiAgICAnSW50ZXJuYWwnLFxuICAgICdEYXRhYmFzZUNsb3NlZCcsXG4gICAgJ1ByZW1hdHVyZUNvbW1pdCcsXG4gICAgJ0ZvcmVpZ25Bd2FpdCdcbl07XG52YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ0NvbnN0cmFpbnQnLFxuICAgICdEYXRhJyxcbiAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG4gICAgJ1JlYWRPbmx5JyxcbiAgICAnVmVyc2lvbicsXG4gICAgJ05vdEZvdW5kJyxcbiAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAnSW52YWxpZEFjY2VzcycsXG4gICAgJ0Fib3J0JyxcbiAgICAnVGltZW91dCcsXG4gICAgJ1F1b3RhRXhjZWVkZWQnLFxuICAgICdTeW50YXgnLFxuICAgICdEYXRhQ2xvbmUnXG5dO1xudmFyIGVycm9yTGlzdCA9IGRleGllRXJyb3JOYW1lcy5jb25jYXQoaWRiRG9tRXJyb3JOYW1lcyk7XG52YXIgZGVmYXVsdFRleHRzID0ge1xuICAgIFZlcnNpb25DaGFuZ2VkOiBcIkRhdGFiYXNlIHZlcnNpb24gY2hhbmdlZCBieSBvdGhlciBkYXRhYmFzZSBjb25uZWN0aW9uXCIsXG4gICAgRGF0YWJhc2VDbG9zZWQ6IFwiRGF0YWJhc2UgaGFzIGJlZW4gY2xvc2VkXCIsXG4gICAgQWJvcnQ6IFwiVHJhbnNhY3Rpb24gYWJvcnRlZFwiLFxuICAgIFRyYW5zYWN0aW9uSW5hY3RpdmU6IFwiVHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgY29tcGxldGVkIG9yIGZhaWxlZFwiXG59O1xuLy9cbi8vIERleGllRXJyb3IgLSBiYXNlIGNsYXNzIG9mIGFsbCBvdXQgZXhjZXB0aW9ucy5cbi8vXG5mdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuICAgIC8vIFJlYXNvbiB3ZSBkb24ndCB1c2UgRVM2IGNsYXNzZXMgaXMgYmVjYXVzZTpcbiAgICAvLyAxLiBJdCBibG9hdHMgdHJhbnNwaWxlZCBjb2RlIGFuZCBpbmNyZWFzZXMgc2l6ZSBvZiBtaW5pZmllZCBjb2RlLlxuICAgIC8vIDIuIEl0IGRvZXNuJ3QgZ2l2ZSB1cyBtdWNoIGluIHRoaXMgY2FzZS5cbiAgICAvLyAzLiBJdCB3b3VsZCByZXF1aXJlIHN1YiBjbGFzc2VzIHRvIGNhbGwgc3VwZXIoKSwgd2hpY2hcbiAgICAvLyAgICBpcyBub3QgbmVlZGVkIHdoZW4gZGVyaXZpbmcgZnJvbSBFcnJvci5cbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbn1cbmRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEVycm9yKS5leHRlbmQoe1xuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX3N0YWNrID0gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgcHJldHR5U3RhY2sodGhpcy5fZSwgMikpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9XG59KTtcbmZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gbXNnICsgXCIuIEVycm9yczogXCIgKyBmYWlsdXJlc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIHMpIHsgcmV0dXJuIHMuaW5kZXhPZih2KSA9PT0gaTsgfSkgLy8gT25seSB1bmlxdWUgZXJyb3Igc3RyaW5nc1xuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vL1xuLy8gTW9kaWZ5RXJyb3IgLSB0aHJvd24gaW4gQ29sbGVjdGlvbi5tb2RpZnkoKVxuLy8gU3BlY2lmaWMgY29uc3RydWN0b3IgYmVjYXVzZSBpdCBjb250YWlucyBtZW1iZXJzIGZhaWx1cmVzIGFuZCBmYWlsZWRLZXlzLlxuLy9cbmZ1bmN0aW9uIE1vZGlmeUVycm9yKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xufVxuZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuZnVuY3Rpb24gQnVsa0Vycm9yKG1zZywgZmFpbHVyZXMpIHtcbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBcIkJ1bGtFcnJvclwiO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbn1cbmRlcml2ZShCdWxrRXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG4vL1xuLy9cbi8vIER5bmFtaWNhbGx5IGdlbmVyYXRlIGVycm9yIG5hbWVzIGFuZCBleGNlcHRpb24gY2xhc3NlcyBiYXNlZFxuLy8gb24gdGhlIG5hbWVzIGluIGVycm9yTGlzdC5cbi8vXG4vL1xuLy8gTWFwIG9mIHtFcnJvck5hbWUgLT4gRXJyb3JOYW1lICsgXCJFcnJvclwifVxudmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7IHJldHVybiAob2JqW25hbWVdID0gbmFtZSArIFwiRXJyb3JcIiwgb2JqKTsgfSwge30pO1xuLy8gTmVlZCBhbiBhbGlhcyBmb3IgRGV4aWVFcnJvciBiZWNhdXNlIHdlJ3JlIGdvbm5hIGNyZWF0ZSBzdWJjbGFzc2VzIHdpdGggdGhlIHNhbWUgbmFtZS5cbnZhciBCYXNlRXhjZXB0aW9uID0gRGV4aWVFcnJvcjtcbi8vIE1hcCBvZiB7RXJyb3JOYW1lIC0+IGV4Y2VwdGlvbiBjb25zdHJ1Y3Rvcn1cbnZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgLy8gTGV0IHRoZSBuYW1lIGJlIFwiRGV4aWVFcnJvclwiIGJlY2F1c2UgdGhpcyBuYW1lIG1heVxuICAgIC8vIGJlIHNob3duIGluIGNhbGwgc3RhY2sgYW5kIHdoZW4gZGVidWdnaW5nLiBEZXhpZUVycm9yIGlzXG4gICAgLy8gdGhlIG1vc3QgdHJ1ZSBuYW1lIGJlY2F1c2UgaXQgZGVyaXZlcyBmcm9tIERleGllRXJyb3IsXG4gICAgLy8gYW5kIHdlIGNhbm5vdCBjaGFuZ2UgRnVuY3Rpb24ubmFtZSBwcm9ncmFtYXRpY2FsbHkgd2l0aG91dFxuICAgIC8vIGR5bmFtaWNhbGx5IGNyZWF0ZSBhIEZ1bmN0aW9uIG9iamVjdCwgd2hpY2ggd291bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vICdldmFsLWV2aWwnLlxuICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgZnVuY3Rpb24gRGV4aWVFcnJvcihtc2dPcklubmVyLCBpbm5lcikge1xuICAgICAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgIGlmICghbXNnT3JJbm5lcikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZGVmYXVsdFRleHRzW25hbWVdIHx8IGZ1bGxOYW1lO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2dPcklubmVyO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2dPcklubmVyLm5hbWUgKyBcIiBcIiArIG1zZ09ySW5uZXIubWVzc2FnZTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgIG9ialtuYW1lXSA9IERleGllRXJyb3I7XG4gICAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbi8vIFVzZSBFQ01BU0NSSVBUIHN0YW5kYXJkIGV4Y2VwdGlvbnMgd2hlcmUgYXBwbGljYWJsZTpcbmV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG5leGNlcHRpb25zLlR5cGUgPSBUeXBlRXJyb3I7XG5leGNlcHRpb25zLlJhbmdlID0gUmFuZ2VFcnJvcjtcbnZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZnVuY3Rpb24gbWFwRXJyb3IoZG9tRXJyb3IsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWRvbUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgRGV4aWVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yIHx8ICFkb21FcnJvci5uYW1lIHx8ICFleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0pXG4gICAgICAgIHJldHVybiBkb21FcnJvcjtcbiAgICB2YXIgcnYgPSBuZXcgZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKG1lc3NhZ2UgfHwgZG9tRXJyb3IubWVzc2FnZSwgZG9tRXJyb3IpO1xuICAgIGlmIChcInN0YWNrXCIgaW4gZG9tRXJyb3IpIHtcbiAgICAgICAgLy8gRGVyaXZlIHN0YWNrIGZyb20gaW5uZXIgZXhjZXB0aW9uIGlmIGl0IGhhcyBhIHN0YWNrXG4gICAgICAgIHNldFByb3AocnYsIFwic3RhY2tcIiwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbnZhciBmdWxsTmFtZUV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgICBpZiAoW1wiU3ludGF4XCIsIFwiVHlwZVwiLCBcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5EZXhpZUVycm9yID0gRGV4aWVFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG5cbmZ1bmN0aW9uIG5vcCgpIHsgfVxuZnVuY3Rpb24gbWlycm9yKHZhbCkgeyByZXR1cm4gdmFsOyB9XG5mdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAvLyBFbmFibGVzIGNoYWluZWQgZXZlbnRzIHRoYXQgdGFrZXMgT05FIGFyZ3VtZW50IGFuZCByZXR1cm5zIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIGNoYWluLlxuICAgIC8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGluIHRoZSBob29rKFwicmVhZGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgLy8gRW5hYmxlcyBjaGFpbmVkIGV2ZW50cyB0aGF0IHRha2VzIHNldmVyYWwgYXJndW1lbnRzIGFuZCBtYXkgbW9kaWZ5IGZpcnN0IGFyZ3VtZW50IGJ5IG1ha2luZyBhIG1vZGlmaWNhdGlvbiBhbmQgdGhlbiByZXR1cm5pbmcgdGhlIHNhbWUgaW5zdGFuY2UuXG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgaW4gdGhlIGhvb2soXCJjcmVhdGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSByZXM7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7IC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uZXJyb3JcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7IC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uZXJyb3JcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgIH07XG59XG5mdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZXh0ZW5kKG1vZGlmaWNhdGlvbnMsIHJlcyk7IC8vIElmIGYxIHJldHVybnMgbmV3IG1vZGlmaWNhdGlvbnMsIGV4dGVuZCBjYWxsZXIncyBtb2RpZmljYXRpb25zIHdpdGggdGhlIHJlc3VsdCBiZWZvcmUgY2FsbGluZyBuZXh0IGluIGNoYWluLlxuICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsIC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uc3VjY2Vzc1xuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcbiAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcywgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNyBEYXZpZCBGYWhsYW5kZXJcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG4vL1xuLy8gUHJvbWlzZSBhbmQgWm9uZSAoUFNEKSBmb3IgRGV4aWUgbGlicmFyeVxuLy9cbi8vIEkgc3RhcnRlZCBvdXQgd3JpdGluZyB0aGlzIFByb21pc2UgY2xhc3MgYnkgY29weWluZyBwcm9taXNlLWxpZ2h0IChodHRwczovL2dpdGh1Yi5jb20vdGF5bG9yaGFrZXMvcHJvbWlzZS1saWdodCkgYnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcyAtIGFuIEErIGFuZCBFQ01BU0NSSVBUIDYgY29tcGxpYW50IFByb21pc2UgaW1wbGVtZW50YXRpb24uXG4vL1xuLy8gSW4gcHJldmlvdXMgdmVyc2lvbnMgdGhpcyB3YXMgZml4ZWQgYnkgbm90IGNhbGxpbmcgc2V0VGltZW91dCB3aGVuIGtub3dpbmcgdGhhdCB0aGUgcmVzb2x2ZSgpIG9yIHJlamVjdCgpIGNhbWUgZnJvbSBhbm90aGVyXG4vLyB0aWNrLiBJbiBEZXhpZSB2MS40LjAsIEkndmUgcmV3cml0dGVuIHRoZSBQcm9taXNlIGNsYXNzIGVudGlyZWx5LiBKdXN0IHNvbWUgZnJhZ21lbnRzIG9mIHByb21pc2UtbGlnaHQgaXMgbGVmdC4gSSB1c2Vcbi8vIGFub3RoZXIgc3RyYXRlZ3kgbm93IHRoYXQgc2ltcGxpZmllcyBldmVyeXRoaW5nIGEgbG90OiB0byBhbHdheXMgZXhlY3V0ZSBjYWxsYmFja3MgaW4gYSBuZXcgbWljcm8tdGFzaywgYnV0IGhhdmUgYW4gb3duIG1pY3JvLXRhc2tcbi8vIGVuZ2luZSB0aGF0IGlzIGluZGV4ZWREQiBjb21wbGlhbnQgYWNyb3NzIGFsbCBicm93c2Vycy5cbi8vIFByb21pc2UgY2xhc3MgaGFzIGFsc28gYmVlbiBvcHRpbWl6ZWQgYSBsb3Qgd2l0aCBpbnNwaXJhdGlvbiBmcm9tIGJsdWViaXJkIC0gdG8gYXZvaWQgY2xvc3VyZXMgYXMgbXVjaCBhcyBwb3NzaWJsZS5cbi8vIEFsc28gd2l0aCBpbnNwaXJhdGlvbiBmcm9tIGJsdWViaXJkLCBhc3luY3JvbmljIHN0YWNrcyBpbiBkZWJ1ZyBtb2RlLlxuLy9cbi8vIFNwZWNpZmljIG5vbi1zdGFuZGFyZCBmZWF0dXJlcyBvZiB0aGlzIFByb21pc2UgY2xhc3M6XG4vLyAqIEN1c3RvbSB6b25lIHN1cHBvcnQgKGEuay5hLiBQU0QpIHdpdGggYWJpbGl0eSB0byBrZWVwIHpvbmVzIGFsc28gd2hlbiB1c2luZyBuYXRpdmUgcHJvbWlzZXMgYXMgd2VsbCBhc1xuLy8gICBuYXRpdmUgYXN5bmMgLyBhd2FpdC5cbi8vICogUHJvbWlzZS5mb2xsb3coKSBtZXRob2QgYnVpbHQgdXBvbiB0aGUgY3VzdG9tIHpvbmUgZW5naW5lLCB0aGF0IGFsbG93cyB1c2VyIHRvIHRyYWNrIGFsbCBwcm9taXNlcyBjcmVhdGVkIGZyb20gY3VycmVudCBzdGFjayBmcmFtZVxuLy8gICBhbmQgYmVsb3cgKyBhbGwgcHJvbWlzZXMgdGhhdCB0aG9zZSBwcm9taXNlcyBjcmVhdGVzIG9yIGF3YWl0cy5cbi8vICogRGV0ZWN0IGFueSB1bmhhbmRsZWQgcHJvbWlzZSBpbiBhIFBTRC1zY29wZSAoUFNELm9udW5oYW5kbGVkKS4gXG4vL1xuLy8gRGF2aWQgRmFobGFuZGVyLCBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlclxuLy9cbi8vIEp1c3QgYSBwb2ludGVyIHRoYXQgb25seSB0aGlzIG1vZHVsZSBrbm93cyBhYm91dC5cbi8vIFVzZWQgaW4gUHJvbWlzZSBjb25zdHJ1Y3RvciB0byBlbXVsYXRlIGEgcHJpdmF0ZSBjb25zdHJ1Y3Rvci5cbnZhciBJTlRFUk5BTCA9IHt9O1xuLy8gQXN5bmMgc3RhY2tzIChsb25nIHN0YWNrcykgbXVzdCBub3QgZ3JvdyBpbmZpbml0ZWx5LlxudmFyIExPTkdfU1RBQ0tTX0NMSVBfTElNSVQgPSAxMDA7XG52YXIgTUFYX0xPTkdfU1RBQ0tTID0gMjA7XG52YXIgWk9ORV9FQ0hPX0xJTUlUID0gNztcbnZhciBuYXRpdmVQcm9taXNlSW5zdGFuY2VBbmRQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmUgYWJsZSB0byBwYXRjaCBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJsZXQgRj1hc3luYyAoKT0+e30scD1GKCk7cmV0dXJuIFtwLE9iamVjdC5nZXRQcm90b3R5cGVPZihwKSxQcm9taXNlLnJlc29sdmUoKSxGLmNvbnN0cnVjdG9yXTtcIikoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIFAgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgICAgIHJldHVybiBQID9cbiAgICAgICAgICAgIFtQLnJlc29sdmUoKSwgUC5wcm90b3R5cGUsIFAucmVzb2x2ZSgpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9XG59KSgpO1xudmFyIHJlc29sdmVkTmF0aXZlUHJvbWlzZSA9IG5hdGl2ZVByb21pc2VJbnN0YW5jZUFuZFByb3RvWzBdO1xudmFyIG5hdGl2ZVByb21pc2VQcm90byA9IG5hdGl2ZVByb21pc2VJbnN0YW5jZUFuZFByb3RvWzFdO1xudmFyIHJlc29sdmVkR2xvYmFsUHJvbWlzZSA9IG5hdGl2ZVByb21pc2VJbnN0YW5jZUFuZFByb3RvWzJdO1xudmFyIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xudmFyIE5hdGl2ZVByb21pc2UgPSByZXNvbHZlZE5hdGl2ZVByb21pc2UgJiYgcmVzb2x2ZWROYXRpdmVQcm9taXNlLmNvbnN0cnVjdG9yO1xudmFyIEFzeW5jRnVuY3Rpb24gPSBuYXRpdmVQcm9taXNlSW5zdGFuY2VBbmRQcm90b1szXTtcbnZhciBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcbnZhciBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSBmYWxzZTtcbi8qIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHVzZWQgb25seSBmb3IgdGhlIHZlcnkgZmlyc3QgcHJvbWlzZSBpbiBhIHByb21pc2UgY2hhaW4uXG4gICBBcyBzb29uIGFzIHRoZW4gcHJvbWlzZSBpcyByZXNvbHZlZCBvciByZWplY3RlZCwgYWxsIG5leHQgdGFza3Mgd2lsbCBiZSBleGVjdXRlZCBpbiBtaWNybyB0aWNrc1xuICAgZW11bGF0ZWQgaW4gdGhpcyBtb2R1bGUuIEZvciBpbmRleGVkREIgY29tcGF0aWJpbGl0eSwgdGhpcyBtZWFucyB0aGF0IGV2ZXJ5IG1ldGhvZCBuZWVkcyB0b1xuICAgZXhlY3V0ZSBhdCBsZWFzdCBvbmUgcHJvbWlzZSBiZWZvcmUgZG9pbmcgYW4gaW5kZXhlZERCIG9wZXJhdGlvbi4gRGV4aWUgd2lsbCBhbHdheXMgY2FsbFxuICAgZGIucmVhZHkoKS50aGVuKCkgZm9yIGV2ZXJ5IG9wZXJhdGlvbiB0byBtYWtlIHN1cmUgdGhlIGluZGV4ZWREQiBldmVudCBpcyBzdGFydGVkIGluIGFuXG4gICBpbmRleGVkREItY29tcGF0aWJsZSBlbXVsYXRlZCBtaWNybyB0YXNrIGxvb3AuXG4qL1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICBmdW5jdGlvbiAoKSB7IHJlc29sdmVkR2xvYmFsUHJvbWlzZS50aGVuKHBoeXNpY2FsVGljayk7IH1cbiAgICA6XG4gICAgICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID9cbiAgICAgICAgICAgIC8vIHNldEltbWVkaWF0ZSBzdXBwb3J0ZWQuIFRob3NlIG1vZGVybiBwbGF0Zm9ybXMgYWxzbyBzdXBwb3J0cyBGdW5jdGlvbi5iaW5kKCkuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUuYmluZChudWxsLCBwaHlzaWNhbFRpY2spIDpcbiAgICAgICAgICAgIF9nbG9iYWwuTXV0YXRpb25PYnNlcnZlciA/XG4gICAgICAgICAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxUaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgnaScsICcxJyk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3Igc2V0SW1tZWRpYXRlIG9yIE11dGF0aW9uT2JzZXJ2ZXIuIE5vIHdvcnJ5LCBzZXRUaW1lb3V0IGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAgICAgLy8gb25jZSB0aW1lLiBFdmVyeSB0aWNrIHRoYXQgZm9sbG93cyB3aWxsIGJlIG91ciBlbXVsYXRlZCBtaWNybyB0aWNrLlxuICAgICAgICAgICAgICAgIC8vIENvdWxkIGhhdmUgdXNlcyBzZXRUaW1lb3V0LmJpbmQobnVsbCwgMCwgcGh5c2ljYWxUaWNrKSBpZiBpdCB3YXNudCBmb3IgdGhhdCBGRjEzIGFuZCBiZWxvdyBoYXMgYSBidWcgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywgMCk7IH07XG4vLyBDb25maWd1cmFibGUgdGhyb3VnaCBQcm9taXNlLnNjaGVkdWxlci5cbi8vIERvbid0IGV4cG9ydCBiZWNhdXNlIGl0IHdvdWxkIGJlIHVuc2FmZSB0byBsZXQgdW5rbm93blxuLy8gY29kZSBjYWxsIGl0IHVubGVzcyB0aGV5IGRvIHRyeS4uY2F0Y2ggd2l0aGluIHRoZWlyIGNhbGxiYWNrLlxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2ggZ2V0dGVyIG9mIFByb21pc2Uuc2NoZWR1bGVyIHRob3VnaCxcbi8vIGJ1dCB1c2VycyBtdXN0IG5vdCBkbyBQcm9taXNlLnNjaGVkdWxlciA9IG15RnVuY1RoYXRUaHJvd3NFeGNlcHRpb25cbnZhciBhc2FwJDEgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBtaWNyb3RpY2tRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnc10pO1xuICAgIGlmIChuZWVkc05ld1BoeXNpY2FsVGljaykge1xuICAgICAgICBzY2hlZHVsZVBoeXNpY2FsVGljaygpO1xuICAgICAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgIH1cbn07XG52YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbnZhciBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG52YXIgdW5oYW5kbGVkRXJyb3JzID0gW107XG52YXIgcmVqZWN0aW5nRXJyb3JzID0gW107XG52YXIgY3VycmVudEZ1bGZpbGxlciA9IG51bGw7XG52YXIgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yOyAvLyBSZW1vdmUgaW4gbmV4dCBtYWpvciB3aGVuIHJlbW92aW5nIGVycm9yIG1hcHBpbmcgb2YgRE9NRXJyb3JzIGFuZCBET01FeGNlcHRpb25zXG52YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2goZnVuY3Rpb24gKHVoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdsb2JhbEVycm9yKHVoWzBdLCB1aFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgUFNEID0gZ2xvYmFsUFNEO1xudmFyIG1pY3JvdGlja1F1ZXVlID0gW107IC8vIENhbGxiYWNrcyB0byBjYWxsIGluIHRoaXMgb3IgbmV4dCBwaHlzaWNhbCB0aWNrLlxudmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDsgLy8gTnVtYmVyIG9mIGxpc3RlbmVyLWNhbGxzIGxlZnQgdG8gZG8gaW4gdGhpcyBwaHlzaWNhbCB0aWNrLlxudmFyIHRpY2tGaW5hbGl6ZXJzID0gW107IC8vIEZpbmFsaXplcnMgdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGFzeW5jIGNhbGxzIHNjaGVkdWxlZCB3aXRoaW4gY3VycmVudCBwaHlzaWNhbCB0aWNrLlxuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMub251bmNhdGNoZWQgPSBub3A7IC8vIERlcHJlY2F0ZSBpbiBuZXh0IG1ham9yLiBOb3QgbmVlZGVkLiBCZXR0ZXIgdG8gdXNlIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgIC8vIEEgbGlicmFyeSBtYXkgc2V0IGBwcm9taXNlLl9saWIgPSB0cnVlO2AgYWZ0ZXIgcHJvbWlzZSBpcyBjcmVhdGVkIHRvIG1ha2UgcmVzb2x2ZSgpIG9yIHJlamVjdCgpXG4gICAgLy8gZXhlY3V0ZSB0aGUgbWljcm90YXNrIGVuZ2luZSBpbXBsaWNpdGVseSB3aXRoaW4gdGhlIGNhbGwgdG8gcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFRvIHJlbWFpbiBBKyBjb21wbGlhbnQsIGEgbGlicmFyeSBtdXN0IG9ubHkgc2V0IGBfbGliPXRydWVgIGlmIGl0IGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgc3RhY2tcbiAgICAvLyBvbmx5IGNvbnRhaW5zIGxpYnJhcnkgY29kZSB3aGVuIGNhbGxpbmcgcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFJVTEUgT0YgVEhVTUI6IE9OTFkgc2V0IF9saWIgPSB0cnVlIGZvciBwcm9taXNlcyBleHBsaWNpdGVseSByZXNvbHZpbmcvcmVqZWN0aW5nIGRpcmVjdGx5IGZyb21cbiAgICAvLyBnbG9iYWwgc2NvcGUgKGV2ZW50IGhhbmRsZXIsIHRpbWVyIGV0YykhXG4gICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgLy8gQ3VycmVudCBhc3luYyBzY29wZVxuICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgdGhpcy5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbnVtUHJldiA9IDA7IC8vIE51bWJlciBvZiBwcmV2aW91cyBwcm9taXNlcyAoZm9yIGxvbmcgc3RhY2tzKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yIChJTlRFUk5BTCwgc3RhdGUsIHZhbHVlKS5cbiAgICAgICAgLy8gVXNlZCBpbnRlcm5hbGx5IGJ5IFByb21pc2UucmVzb2x2ZSgpIGFuZCBQcm9taXNlLnJlamVjdCgpLlxuICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpOyAvLyBNYXAgZXJyb3IsIHNldCBzdGFjayBhbmQgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcigpLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gbnVsbDsgLy8gbnVsbCAoPXBlbmRpbmcpLCBmYWxzZSAoPXJlamVjdGVkKSBvciB0cnVlICg9cmVzb2x2ZWQpXG4gICAgdGhpcy5fdmFsdWUgPSBudWxsOyAvLyBlcnJvciBvciByZXN1bHRcbiAgICArK3BzZC5yZWY7IC8vIFJlZmNvdW50aW5nIGN1cnJlbnQgc2NvcGVcbiAgICBleGVjdXRlUHJvbWlzZVRhc2sodGhpcywgZm4pO1xufVxuLy8gUHJlcGFyZSBhIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcHV0IG9udG8gUHJvbWlzZS5wcm90b3R5cGUudGhlblxudmFyIHRoZW5Qcm9wID0ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHNkID0gUFNELCBtaWNyb1Rhc2tJZCA9IHRvdGFsRWNob2VzO1xuICAgICAgICBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KVxuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICB2YXIgcnYgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihfdGhpcywgbmV3IExpc3RlbmVyKG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0KSwgcmVzb2x2ZSwgcmVqZWN0LCBwc2QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVidWcgJiYgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMOyAvLyBGb3IgaWRlbXBvdGVuc2UsIHNlZSBzZXR0ZXIgYmVsb3cuXG4gICAgICAgIHJldHVybiB0aGVuO1xuICAgIH0sXG4gICAgLy8gQmUgaWRlbXBvdGVudCBhbmQgYWxsb3cgYW5vdGhlciBmcmFtZXdvcmsgKHN1Y2ggYXMgem9uZS5qcyBvciBhbm90aGVyIGluc3RhbmNlIG9mIGEgRGV4aWUuUHJvbWlzZSBtb2R1bGUpIHRvIHJlcGxhY2UgUHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIC8vIGFuZCB3aGVuIHRoYXQgZnJhbWV3b3JrIHdhbnRzIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnR5LCB3ZSBtdXN0IGlkZW50aWZ5IHRoYXQgYW5kIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgdGhlblByb3AgOiAvLyBSZXN0b3JlIHRvIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gR2V0dGVyIHJldHVybmluZyBwcm92aWRlZCB2YWx1ZSAoYmVoYXZlcyBsaWtlIHZhbHVlIGlzIGp1c3QgY2hhbmdlZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0IC8vIEtlZXAgYSBzZXR0ZXIgdGhhdCBpcyBwcmVwYXJlZCB0byByZXN0b3JlIG9yaWdpbmFsLlxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbnByb3BzKFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgdGhlbjogdGhlblByb3AsXG4gICAgX3RoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBBIGxpdHRsZSB0aW5pZXIgdmVyc2lvbiBvZiB0aGVuKCkgdGhhdCBkb24ndCBoYXZlIHRvIGNyZWF0ZSBhIHJlc3VsdGluZyBwcm9taXNlLlxuICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihudWxsLCBudWxsLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgUFNEKSk7XG4gICAgfSxcbiAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAvLyBGaXJzdCBhcmd1bWVudCBpcyB0aGUgRXJyb3IgdHlwZSB0byBjYXRjaFxuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBieSBpdHMgY29uc3RydWN0b3IgdHlwZSAoc2ltaWxhciB0byBqYXZhIC8gYysrIC8gYyMpXG4gICAgICAgICAgICAvLyBTYW1wbGU6IHByb21pc2UuY2F0Y2goVHlwZUVycm9yLCBmdW5jdGlvbiAoZSkgeyAuLi4gfSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIDogdGhpcy50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgYnkgdGhlIGVycm9yLm5hbWUgcHJvcGVydHkuIE1ha2VzIHNlbnNlIGZvciBpbmRleGVkREIgd2hlcmUgZXJyb3IgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBET01FcnJvciBidXQgd2hlcmUgZS5uYW1lIHRlbGxzIHRoZSBhY3R1YWwgZXJyb3IgdHlwZS5cbiAgICAgICAgICAgICAgICAvLyBTYW1wbGU6IHByb21pc2UuY2F0Y2goJ0NvbnN0cmFpbnRFcnJvcicsIGZ1bmN0aW9uIChlKSB7IC4uLiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tzID0gZ2V0U3RhY2sodGhpcywgW10sIE1BWF9MT05HX1NUQUNLUyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tzLmpvaW4oXCJcXG5Gcm9tIHByZXZpb3VzOiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IHN0YWNrOyAvLyBTdGFjayBtYXkgYmUgdXBkYXRlZCBvbiByZWplY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuVGltZW91dChtc2cpKTsgfSwgbXMpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgfSkgOiB0aGlzO1xuICAgIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICBzZXRQcm9wKFByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdQcm9taXNlJyk7XG4vLyBOb3cgdGhhdCBQcm9taXNlLnByb3RvdHlwZSBpcyBkZWZpbmVkLCB3ZSBoYXZlIGFsbCBpdCB0YWtlcyB0byBzZXQgZ2xvYmFsUFNELmVudi5cbi8vIEVudmlyb25tZW50IGdsb2JhbHMgc25hcHNob3R0ZWQgb24gbGVhdmluZyBnbG9iYWwgem9uZVxuZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5mdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5wc2QgPSB6b25lO1xufVxuLy8gUHJvbWlzZSBTdGF0aWMgUHJvcGVydGllc1xucHJvcHMoUHJvbWlzZSwge1xuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpIC8vIFN1cHBvcnRzIGl0ZXJhYmxlcywgaW1wbGljaXQgYXJndW1lbnRzIGFuZCBhcnJheS1saWtlLlxuICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpOyAvLyBIYW5kbGUgcGFyYWxsZWxsIGFzeW5jL2F3YWl0cyBcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSwgaSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCwgdHJ1ZSwgdmFsdWUpO1xuICAgICAgICBsaW5rVG9QcmV2aW91c1Byb21pc2UocnYsIGN1cnJlbnRGdWxmaWxsZXIpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfSxcbiAgICByZWplY3Q6IFByb21pc2VSZWplY3QsXG4gICAgcmFjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBQU0Q6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQU0Q7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBQU0QgPSB2YWx1ZTsgfVxuICAgIH0sXG4gICAgLy90b3RhbEVjaG9lczoge2dldDogKCk9PnRvdGFsRWNob2VzfSxcbiAgICAvL3Rhc2s6IHtnZXQ6ICgpPT50YXNrfSxcbiAgICBuZXdQU0Q6IG5ld1Njb3BlLFxuICAgIHVzZVBTRDogdXNlUFNELFxuICAgIHNjaGVkdWxlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzYXAkMTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgYXNhcCQxID0gdmFsdWU7IH1cbiAgICB9LFxuICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdGlvbk1hcHBlcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7IH0gLy8gTWFwIHJlamVjdCBmYWlsdXJlc1xuICAgIH0sXG4gICAgZm9sbG93OiBmdW5jdGlvbiAoZm4sIHpvbmVQcm9wcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107IC8vIEZvciB1bmhhbmRsZWQgc3RhbmRhcmQtIG9yIDNyZCBwYXJ0eSBQcm9taXNlcy4gQ2hlY2tlZCBhdCBwc2QuZmluYWxpemUoKVxuICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDsgLy8gVHJpZ2dlcmVkIGRpcmVjdGx5IG9uIHVuaGFuZGxlZCBwcm9taXNlcyBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmhhbmRsZWQgc3RhbmRhcmQgb3IgM3JkIHBhcnQgcHJvbWlzZXMgYXJlIHB1dCBpbiBQU0QudW5oYW5kbGVkcyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbWluZWQgdXBvbiBzY29wZSBjb21wbGV0aW9uIHdoaWxlIHVuaGFuZGxlZCByZWplY3Rpb25zIGluIHRoaXMgUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHRyaWdnZXIgZGlyZWN0bHkgdGhyb3VnaCBwc2Qub251bmhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdChfdGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbipcbiogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuKi9cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmbikge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICB0cnkge1xuICAgICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgc2V0dGxlZFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTsgLy8gSWYgRnVuY3Rpb24uYmluZCBpcyBub3Qgc3VwcG9ydGVkLiBFeGNlcHRpb24gaXMgaGFuZGxlZCBpbiBjYXRjaCBiZWxvd1xuICAgIH1cbiAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmVqZWN0aW5nRXJyb3JzLnB1c2gocmVhc29uKTtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgc2hvdWxkRXhlY3V0ZVRpY2sgPSBwcm9taXNlLl9saWIgJiYgYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgIHJlYXNvbiA9IHJlamVjdGlvbk1hcHBlcihyZWFzb24pO1xuICAgIHByb21pc2UuX3N0YXRlID0gZmFsc2U7XG4gICAgcHJvbWlzZS5fdmFsdWUgPSByZWFzb247XG4gICAgZGVidWcgJiYgcmVhc29uICE9PSBudWxsICYmIHR5cGVvZiByZWFzb24gPT09ICdvYmplY3QnICYmICFyZWFzb24uX3Byb21pc2UgJiYgdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3JpZ1Byb3AgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocmVhc29uLCBcInN0YWNrXCIpO1xuICAgICAgICByZWFzb24uX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBzZXRQcm9wKHJlYXNvbiwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AgJiYgKG9yaWdQcm9wLmdldCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC5nZXQuYXBwbHkocmVhc29uKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBBZGQgdGhlIGZhaWx1cmUgdG8gYSBsaXN0IG9mIHBvc3NpYmx5IHVuY2F1Z2h0IGVycm9yc1xuICAgIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSk7XG4gICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKSB7XG4gICAgLy9kZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSk7XG4gICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcbiAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAtLXBzZC5yZWYgfHwgcHNkLmZpbmFsaXplKCk7IC8vIGlmIHBzZC5yZWYgcmVhY2hlcyB6ZXJvLCBjYWxsIHBzZC5maW5hbGl6ZSgpO1xuICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuICAgICAgICAvLyBJZiBudW1TY2hlZHVsZWRDYWxscyBpcyAwLCBpdCBtZWFucyB0aGF0IG91ciBzdGFjayBpcyBub3QgaW4gYSBjYWxsYmFjayBvZiBhIHNjaGVkdWxlZCBjYWxsLFxuICAgICAgICAvLyBhbmQgdGhhdCBubyBkZWZlcnJlZHMgd2hlcmUgbGlzdGVuaW5nIHRvIHRoaXMgcmVqZWN0aW9uIG9yIHN1Y2Nlc3MuXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIGEgcmlzayB0aGF0IG91ciBzdGFjayBjYW4gY29udGFpbiBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgbWF5XG4gICAgICAgIC8vIGRvIHN0dWZmIGFmdGVyIHRoaXMgY29kZSBpcyBmaW5pc2hlZCB0aGF0IG1heSBnZW5lcmF0ZSBuZXcgY2FsbHMsIHdlIGNhbm5vdFxuICAgICAgICAvLyBjYWxsIGZpbmFsaXplcnMgaGVyZS5cbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7IC8vIFdpbGwgZGV0ZWN0IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcHJvbWlzZS5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIExpc3RlbmVyIGRvZXNudCBoYXZlIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBiZWluZyB0cmlnZ2VyZWQgKG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0KSBzbyBsZXRzIGZvcndhcmQgdGhlIGV2ZW50IHRvIGFueSBldmVudHVhbCBsaXN0ZW5lcnMgb24gdGhlIFByb21pc2UgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlbigpIG9yIGNhdGNoKClcbiAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpKHByb21pc2UuX3ZhbHVlKTtcbiAgICB9XG4gICAgKytsaXN0ZW5lci5wc2QucmVmO1xuICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgYXNhcCQxKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xufVxuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFNldCBzdGF0aWMgdmFyaWFibGUgY3VycmVudEZ1bGZpbGxlciB0byB0aGUgcHJvbWlzZSB0aGF0IGlzIGJlaW5nIGZ1bGxmaWxsZWQsXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgY29ubmVjdCB0aGUgY2hhaW4gb2YgcHJvbWlzZXMgKGZvciBsb25nIHN0YWNrcyBzdXBwb3J0KVxuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gcHJvbWlzZTtcbiAgICAgICAgLy8gQ2FsbCBjYWxsYmFjayBhbmQgcmVzb2x2ZSBvdXIgbGlzdGVuZXIgd2l0aCBpdCdzIHJldHVybiB2YWx1ZS5cbiAgICAgICAgdmFyIHJldCwgdmFsdWUgPSBwcm9taXNlLl92YWx1ZTtcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlKSB7XG4gICAgICAgICAgICAvLyBjYiBpcyBvblJlc29sdmVkXG4gICAgICAgICAgICByZXQgPSBjYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjYiBpcyBvblJlamVjdGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0aW5nRXJyb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZWplY3RpbmdFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHJldCA9IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTsgLy8gQ2FsbGJhY2sgZGlkbnQgZG8gUHJvbWlzZS5yZWplY3QoZXJyKSBub3IgcmVqZWN0KGVycikgb250byBhbm90aGVyIHByb21pc2UuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIGluIGNhbGxiYWNrLiBSZWplY3Qgb3VyIGxpc3RlbmVyLlxuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICAvLyBSZXN0b3JlIGVudiBhbmQgY3VycmVudEZ1bGZpbGxlci5cbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IG51bGw7XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFN0YWNrKHByb21pc2UsIHN0YWNrcywgbGltaXQpIHtcbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gbGltaXQpXG4gICAgICAgIHJldHVybiBzdGFja3M7XG4gICAgdmFyIHN0YWNrID0gXCJcIjtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBmYWlsdXJlID0gcHJvbWlzZS5fdmFsdWUsIGVycm9yTmFtZSwgbWVzc2FnZTtcbiAgICAgICAgaWYgKGZhaWx1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZS5uYW1lIHx8IFwiRXJyb3JcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmYWlsdXJlLm1lc3NhZ2UgfHwgZmFpbHVyZTtcbiAgICAgICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2soZmFpbHVyZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlOyAvLyBJZiBlcnJvciBpcyB1bmRlZmluZWQgb3IgbnVsbCwgc2hvdyB0aGF0LlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnB1c2goZXJyb3JOYW1lICsgKG1lc3NhZ2UgPyBcIjogXCIgKyBtZXNzYWdlIDogXCJcIikgKyBzdGFjayk7XG4gICAgfVxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKHByb21pc2UuX3N0YWNrSG9sZGVyLCAyKTtcbiAgICAgICAgaWYgKHN0YWNrICYmIHN0YWNrcy5pbmRleE9mKHN0YWNrKSA9PT0gLTEpXG4gICAgICAgICAgICBzdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgIGlmIChwcm9taXNlLl9wcmV2KVxuICAgICAgICAgICAgZ2V0U3RhY2socHJvbWlzZS5fcHJldiwgc3RhY2tzLCBsaW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSwgcHJldikge1xuICAgIC8vIFN1cHBvcnQgbG9uZyBzdGFja3MgYnkgbGlua2luZyB0byBwcmV2aW91cyBjb21wbGV0ZWQgcHJvbWlzZS5cbiAgICB2YXIgbnVtUHJldiA9IHByZXYgPyBwcmV2Ll9udW1QcmV2ICsgMSA6IDA7XG4gICAgaWYgKG51bVByZXYgPCBMT05HX1NUQUNLU19DTElQX0xJTUlUKSB7XG4gICAgICAgIHByb21pc2UuX3ByZXYgPSBwcmV2O1xuICAgICAgICBwcm9taXNlLl9udW1QcmV2ID0gbnVtUHJldjtcbiAgICB9XG59XG4vKiBUaGUgY2FsbGJhY2sgdG8gc2NoZWR1bGUgd2l0aCBzZXRJbW1lZGlhdGUoKSBvciBzZXRUaW1lb3V0KCkuXG4gICBJdCBydW5zIGEgdmlydHVhbCBtaWNyb3RpY2sgYW5kIGV4ZWN1dGVzIGFueSBjYWxsYmFjayByZWdpc3RlcmVkIGluIG1pY3JvdGlja1F1ZXVlLlxuICovXG5mdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG4gICAgYmVnaW5NaWNyb1RpY2tTY29wZSgpICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG59XG5mdW5jdGlvbiBiZWdpbk1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciB3YXNSb290RXhlYyA9IGlzT3V0c2lkZU1pY3JvVGljaztcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSBmYWxzZTtcbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgIHJldHVybiB3YXNSb290RXhlYztcbn1cbi8qIEV4ZWN1dGVzIG1pY3JvLXRpY2tzIHdpdGhvdXQgZG9pbmcgdHJ5Li5jYXRjaC5cbiAgIFRoaXMgY2FuIGJlIHBvc3NpYmxlIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBpbnRlcm5hbGx5IGFuZFxuICAgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGFyZSBleGNlcHRpb24tc2FmZSAodGhleSBkbyB0cnkuLmNhdGNoXG4gICBpbnRlcm5hbGx5IGJlZm9yZSBjYWxsaW5nIGFueSBleHRlcm5hbCBtZXRob2QpLiBJZiByZWdpc3RlcmluZ1xuICAgZnVuY3Rpb25zIGluIHRoZSBtaWNyb3RpY2tRdWV1ZSB0aGF0IGFyZSBub3QgZXhjZXB0aW9uLXNhZmUsIHRoaXNcbiAgIHdvdWxkIGRlc3Ryb3kgdGhlIGZyYW1ld29yayBhbmQgbWFrZSBpdCBpbnN0YWJsZS4gU28gd2UgZG9uJ3QgZXhwb3J0XG4gICBvdXIgYXNhcCBtZXRob2QuXG4qL1xuZnVuY3Rpb24gZW5kTWljcm9UaWNrU2NvcGUoKSB7XG4gICAgdmFyIGNhbGxiYWNrcywgaSwgbDtcbiAgICBkbyB7XG4gICAgICAgIHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MgPSBtaWNyb3RpY2tRdWV1ZTtcbiAgICAgICAgICAgIG1pY3JvdGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICBsID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpdGVtWzBdLmFwcGx5KG51bGwsIGl0ZW1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCk7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZTtcbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWU7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcbiAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuICAgIH0pO1xuICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7IC8vIENsb25lIGZpcnN0IGJlY2F1c2UgZmluYWxpemVyIG1heSByZW1vdmUgaXRzZWxmIGZyb20gbGlzdC5cbiAgICB2YXIgaSA9IGZpbmFsaXplcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpKVxuICAgICAgICBmaW5hbGl6ZXJzWy0taV0oKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgIH1cbiAgICB0aWNrRmluYWxpemVycy5wdXNoKGZpbmFsaXplcik7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwJDEoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgfSwgW10pO1xufVxuZnVuY3Rpb24gYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKSB7XG4gICAgLy8gT25seSBhZGQgdG8gdW5oYW5kbGVkRXJyb3JzIGlmIG5vdCBhbHJlYWR5IHRoZXJlLiBUaGUgZmlyc3Qgb25lIHRvIGFkZCB0byB0aGlzIGxpc3RcbiAgICAvLyB3aWxsIGJlIHVwb24gdGhlIGZpcnN0IHJlamVjdGlvbiBzbyB0aGF0IHRoZSByb290IGNhdXNlIChmaXJzdCBwcm9taXNlIGluIHRoZVxuICAgIC8vIHJlamVjdGlvbiBjaGFpbikgaXMgdGhlIG9uZSBsaXN0ZWQuXG4gICAgaWYgKCF1bmhhbmRsZWRFcnJvcnMuc29tZShmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlOyB9KSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5mdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgIC8vIENhbGxlZCB3aGVuIGEgcmVqZWN0IGhhbmRsZWQgaXMgYWN0dWFsbHkgYmVpbmcgY2FsbGVkLlxuICAgIC8vIFNlYXJjaCBpbiB1bmhhbmRsZWRFcnJvcnMgZm9yIGFueSBwcm9taXNlIHdob3MgX3ZhbHVlIGlzIHRoaXMgcHJvbWlzZV92YWx1ZSAobGlzdFxuICAgIC8vIGNvbnRhaW5zIG9ubHkgcmVqZWN0ZWQgcHJvbWlzZXMsIGFuZCBvbmx5IG9uZSBpdGVtIHBlciBlcnJvcilcbiAgICB2YXIgaSA9IHVuaGFuZGxlZEVycm9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGkpXG4gICAgICAgIGlmICh1bmhhbmRsZWRFcnJvcnNbLS1pXS5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHByb21pc2UgdGhhdCBmYWlsZWQgd2l0aCB0aGlzIHNhbWUgZXJyb3Igb2JqZWN0IHBvaW50ZXIsXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhhdCBzaW5jZSB0aGVyZSBpcyBhIGxpc3RlbmVyIHRoYXQgYWN0dWFsbHkgdGFrZXMgY2FyZSBvZiBpdC5cbiAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbn1cbmZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKElOVEVSTkFMLCBmYWxzZSwgcmVhc29uKTtcbn1cbmZ1bmN0aW9uIHdyYXAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLCBvdXRlclNjb3BlID0gUFNEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpXG4gICAgICAgICAgICAgICAgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vL1xuLy8gdmFyaWFibGVzIHVzZWQgZm9yIG5hdGl2ZSBhd2FpdCBzdXBwb3J0XG4vL1xudmFyIHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMCB9OyAvLyBUaGUgb25nb2luZyBtYWNyby10YXNrIHdoZW4gdXNpbmcgem9uZS1lY2hvaW5nLlxudmFyIHRhc2tDb3VudGVyID0gMDsgLy8gSUQgY291bnRlciBmb3IgbWFjcm8gdGFza3MuXG52YXIgem9uZVN0YWNrID0gW107IC8vIFN0YWNrIG9mIGxlZnQgem9uZXMgdG8gcmVzdG9yZSBhc3luY2hyb25pY2FsbHkuXG52YXIgem9uZUVjaG9lcyA9IDA7IC8vIHpvbmVFY2hvZXMgaXMgYSBtdXN0IGluIG9yZGVyIHRvIHBlcnNpc3Qgem9uZXMgYmV0d2VlbiBuYXRpdmUgYXdhaXQgZXhwcmVzc2lvbnMuXG52YXIgdG90YWxFY2hvZXMgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtaWNyby10YXNrcy4gVXNlZCB0byBkZXRlY3QgcG9zc2libGUgbmF0aXZlIGF3YWl0IGluIG91ciBQcm9taXNlLnByb3RvdHlwZS50aGVuLlxudmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXdTY29wZShmbiwgcHJvcHMkJDEsIGExLCBhMikge1xuICAgIHZhciBwYXJlbnQgPSBQU0QsIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgIHBzZC5yZWYgPSAwO1xuICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcbiAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICAvLyBQcmVwYXJlIGZvciBwcm9taXNlIHBhdGNoaW5nIChkb25lIGluIHVzZVBTRCk6XG4gICAgdmFyIGdsb2JhbEVudiA9IGdsb2JhbFBTRC5lbnY7XG4gICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IFByb21pc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgYWxsOiBQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogUHJvbWlzZS5yYWNlLFxuICAgICAgICByZXNvbHZlOiBQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4oZ2xvYmFsRW52Lm50aGVuLCBwc2QpLFxuICAgICAgICBndGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuKGdsb2JhbEVudi5ndGhlbiwgcHNkKSAvLyBnbG9iYWwgdGhlblxuICAgIH0gOiB7fTtcbiAgICBpZiAocHJvcHMkJDEpXG4gICAgICAgIGV4dGVuZChwc2QsIHByb3BzJCQxKTtcbiAgICAvLyB1bmhhbmRsZWRzIGFuZCBvbnVuaGFuZGxlZCBzaG91bGQgbm90IGJlIHNwZWNpZmljYWxseSBzZXQgaGVyZS5cbiAgICAvLyBMZWF2ZSB0aGVtIG9uIHBhcmVudCBwcm90b3R5cGUuXG4gICAgLy8gdW5oYW5kbGVkcy5wdXNoKGVycikgd2lsbCBwdXNoIHRvIHBhcmVudCdzIHByb3RvdHlwZVxuICAgIC8vIG9udW5oYW5kbGVkKCkgd2lsbCBjYWxsIHBhcmVudHMgb251bmhhbmRsZWQgKHdpdGggdGhpcyBzY29wZSdzIHRoaXMtcG9pbnRlciB0aG91Z2ghKVxuICAgICsrcGFyZW50LnJlZjtcbiAgICBwc2QuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC0tdGhpcy5wYXJlbnQucmVmIHx8IHRoaXMucGFyZW50LmZpbmFsaXplKCk7XG4gICAgfTtcbiAgICB2YXIgcnYgPSB1c2VQU0QocHNkLCBmbiwgYTEsIGEyKTtcbiAgICBpZiAocHNkLnJlZiA9PT0gMClcbiAgICAgICAgcHNkLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHJ2O1xufVxuLy8gRnVuY3Rpb24gdG8gY2FsbCBpZiBzY29wZUZ1bmMgcmV0dXJucyBOYXRpdmVQcm9taXNlXG4vLyBBbHNvIGZvciBlYWNoIE5hdGl2ZVByb21pc2UgaW4gdGhlIGFyZ3VtZW50cyB0byBQcm9taXNlLmFsbCgpXG5mdW5jdGlvbiBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suaWQpXG4gICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICsrdGFzay5hd2FpdHM7XG4gICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0YXNrLmlkO1xufVxuLy8gRnVuY3Rpb24gdG8gY2FsbCB3aGVuICd0aGVuJyBjYWxscyBiYWNrIG9uIGEgbmF0aXZlIHByb21pc2Ugd2hlcmUgb25Bd2FpdEV4cGVjdGVkKCkgaGFkIGJlZW4gY2FsbGVkLlxuLy8gQWxzbyBjYWxsIHRoaXMgd2hlbiBhIG5hdGl2ZSBhd2FpdCBjYWxscyB0aGVuIG1ldGhvZCBvbiBhIHByb21pc2UuIEluIHRoYXQgY2FzZSwgZG9uJ3Qgc3VwcGx5XG4vLyBzb3VyY2VUYXNrSWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGtub3cgaXQgcmVmZXJzIHRvIGN1cnJlbnQgdGFzay5cbmZ1bmN0aW9uIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKHNvdXJjZVRhc2tJZCkge1xuICAgIGlmICghdGFzay5hd2FpdHMgfHwgKHNvdXJjZVRhc2tJZCAmJiBzb3VyY2VUYXNrSWQgIT09IHRhc2suaWQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApXG4gICAgICAgIHRhc2suaWQgPSAwO1xuICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7IC8vIFdpbGwgcmVzZXQgZWNob2VzIHRvIDAgaWYgYXdhaXRzIGlzIDAuXG59XG4vLyBDYWxsIGZyb20gUHJvbWlzZS5hbGwoKSBhbmQgUHJvbWlzZS5yYWNlKClcbmZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyhwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuICAgICsrdG90YWxFY2hvZXM7XG4gICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG4gICAgICAgIHRhc2suZWNob2VzID0gdGFzay5pZCA9IDA7IC8vIENhbmNlbCB6b25lIGVjaG9pbmcuXG4gICAgfVxuICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIHRydWUpO1xufVxuZnVuY3Rpb24gem9uZUxlYXZlRWNobygpIHtcbiAgICB2YXIgem9uZSA9IHpvbmVTdGFja1t6b25lU3RhY2subGVuZ3RoIC0gMV07XG4gICAgem9uZVN0YWNrLnBvcCgpO1xuICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgYkVudGVyaW5nWm9uZSkge1xuICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICBpZiAoYkVudGVyaW5nWm9uZSA/IHRhc2suZWNob2VzICYmICghem9uZUVjaG9lcysrIHx8IHRhcmdldFpvbmUgIT09IFBTRCkgOiB6b25lRWNob2VzICYmICghLS16b25lRWNob2VzIHx8IHRhcmdldFpvbmUgIT09IFBTRCkpIHtcbiAgICAgICAgLy8gRW50ZXIgb3IgbGVhdmUgem9uZSBhc3luY2hyb25pY2FsbHkgYXMgd2VsbCwgc28gdGhhdCB0YXNrcyBpbml0aWF0ZWQgZHVyaW5nIGN1cnJlbnQgdGlja1xuICAgICAgICAvLyB3aWxsIGJlIHN1cnJvdW5kZWQgYnkgdGhlIHpvbmUgd2hlbiB0aGV5IGFyZSBpbnZva2VkLlxuICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgcmV0dXJuO1xuICAgIFBTRCA9IHRhcmdldFpvbmU7IC8vIFRoZSBhY3R1YWwgem9uZSBzd2l0Y2ggb2NjdXJzIGF0IHRoaXMgbGluZS5cbiAgICAvLyBTbmFwc2hvdCBvbiBldmVyeSBsZWF2ZSBmcm9tIGdsb2JhbCB6b25lLlxuICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKVxuICAgICAgICBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbiAgICBpZiAocGF0Y2hHbG9iYWxQcm9taXNlKSB7XG4gICAgICAgIC8vIExldCdzIHBhdGNoIHRoZSBnbG9iYWwgYW5kIG5hdGl2ZSBQcm9taXNlcyAobWF5IGJlIHNhbWUgb3IgbWF5IGJlIGRpZmZlcmVudClcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIC8vIFN3aWNoIGVudmlyb25tZW50cyAobWF5IGJlIFBTRC16b25lIG9yIHRoZSBnbG9iYWwgem9uZS4gQm90aCBhcHBseS4pXG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcbiAgICAgICAgLy8gQ2hhbmdlIFByb21pc2UucHJvdG90eXBlLnRoZW4gZm9yIG5hdGl2ZSBhbmQgZ2xvYmFsIFByb21pc2UgKHRoZXkgTUFZIGRpZmZlciBvbiBwb2x5ZmlsbGVkIGVudmlyb25tZW50cywgYnV0IGJvdGggY2FuIGJlIGFjY2Vzc2VkKVxuICAgICAgICAvLyBNdXN0IGJlIGRvbmUgb24gZWFjaCB6b25lIGNoYW5nZSBiZWNhdXNlIHRoZSBwYXRjaGVkIG1ldGhvZCBjb250YWlucyB0YXJnZXRab25lIGluIGl0cyBjbG9zdXJlLlxuICAgICAgICBuYXRpdmVQcm9taXNlUHJvdG8udGhlbiA9IHRhcmdldEVudi5udGhlbjtcbiAgICAgICAgR2xvYmFsUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IHRhcmdldEVudi5ndGhlbjtcbiAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuICAgICAgICAgICAgLy8gTGVhdmluZyBvciBlbnRlcmluZyBnbG9iYWwgem9uZS4gSXQncyB0aW1lIHRvIHBhdGNoIC8gcmVzdG9yZSBnbG9iYWwgUHJvbWlzZS5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIFByb21pc2UgdG8gd2luZG93LlByb21pc2Ugc28gdGhhdCB0cmFuc2lsZWQgYXN5bmMgZnVuY3Rpb25zIHdpbGwgd29yayBvbiBGaXJlZm94LCBTYWZhcmkgYW5kIElFLCBhcyB3ZWxsIGFzIHdpdGggWm9uZWpzIGFuZCBhbmd1bGFyLlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgUHJvbWlzZS5hbGwoKSBldGMgdG8gd29yayBpbmRleGVkREItc2FmZSBhbHNvIHdoZW4gcGVvcGxlIGFyZSBpbmNsdWRpbmcgZXM2LXByb21pc2UgYXMgYSBtb2R1bGUgKHRoZXkgbWlnaHRcbiAgICAgICAgICAgIC8vIG5vdCBiZSBhY2Nlc3NpbmcgZ2xvYmFsLlByb21pc2UgYnV0IGEgbG9jYWwgcmVmZXJlbmNlIHRvIGl0KVxuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGwgPSB0YXJnZXRFbnYuYWxsO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yYWNlID0gdGFyZ2V0RW52LnJhY2U7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlc29sdmUgPSB0YXJnZXRFbnYucmVzb2x2ZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVqZWN0ID0gdGFyZ2V0RW52LnJlamVjdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNuYXBTaG90KCkge1xuICAgIHZhciBHbG9iYWxQcm9taXNlID0gX2dsb2JhbC5Qcm9taXNlO1xuICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG4gICAgICAgIFByb21pc2VQcm9wOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9nbG9iYWwsIFwiUHJvbWlzZVwiKSxcbiAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogR2xvYmFsUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbixcbiAgICAgICAgZ3RoZW46IEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICB9IDoge307XG59XG5mdW5jdGlvbiB1c2VQU0QocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soam9iKSB7XG4gICAgLy9cbiAgICAvLyBQcmVjb25kaXRpb246IG5hdGl2ZVByb21pc2VUaGVuICE9PSB1bmRlZmluZWRcbiAgICAvL1xuICAgIG5hdGl2ZVByb21pc2VUaGVuLmNhbGwocmVzb2x2ZWROYXRpdmVQcm9taXNlLCBqb2IpO1xufVxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpXG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4ob3JpZ1RoZW4sIHpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdUaGVuLmNhbGwodGhpcywgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlc29sdmVkLCB6b25lLCBmYWxzZSksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgem9uZSwgZmFsc2UpKTtcbiAgICB9O1xufVxudmFyIFVOSEFORExFRFJFSkVDVElPTiA9IFwidW5oYW5kbGVkcmVqZWN0aW9uXCI7XG5mdW5jdGlvbiBnbG9iYWxFcnJvcihlcnIsIHByb21pc2UpIHtcbiAgICB2YXIgcnY7XG4gICAgdHJ5IHtcbiAgICAgICAgcnYgPSBwcm9taXNlLm9udW5jYXRjaGVkKGVycik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBpZiAocnYgIT09IGZhbHNlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV2ZW50LCBldmVudERhdGEgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogZXJyIH07XG4gICAgICAgICAgICBpZiAoX2dsb2JhbC5kb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGV2ZW50LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2dsb2JhbC5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgeyBkZXRhaWw6IGV2ZW50RGF0YSB9KTtcbiAgICAgICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgX2dsb2JhbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCAmJiBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAvLyBObyBuYXRpdmUgc3VwcG9ydCBmb3IgUHJvbWlzZVJlamVjdGlvbkV2ZW50IGJ1dCB1c2VyIGhhcyBzZXQgd2luZG93Lm9udW5oYW5kbGVkcmVqZWN0aW9uLiBNYW51YWxseSBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5oYW5kbGVkIHJlamVjdGlvbjogXCIgKyAoZXJyLnN0YWNrIHx8IGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbn1cbnZhciByZWplY3Rpb24gPSBQcm9taXNlLnJlamVjdDtcblxuZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgIHZhciBldnMgPSB7fTtcbiAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUuIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYW4ganVzdCB0aGUgc3Vic2NyaWJlciB3YXMgcHJvdmlkZWQsIGZvcndhcmQgdGhlbSBhcyB3ZWxsLlxuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpXG4gICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBldnNbZXZlbnROYW1lXS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBpbnRlcmZhY2UgYWxsb3dpbmcgdG8gZmlyZSBvciB1bnN1YnNjcmliZSBmcm9tIGV2ZW50XG4gICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKVxuICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICBpZiAoIWRlZmF1bHRGdW5jdGlvbilcbiAgICAgICAgICAgIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQ29uZmlndXJlZEV2ZW50cyhjZmcpIHtcbiAgICAgICAgLy8gZXZlbnRzKHRoaXMsIHtyZWFkaW5nOiBbZnVuY3Rpb25DaGFpbiwgbm9wXX0pO1xuICAgICAgICBrZXlzKGNmZykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGNmZ1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgICAgICAgICBhZGQoZXZlbnROYW1lLCBjZmdbZXZlbnROYW1lXVswXSwgY2ZnW2V2ZW50TmFtZV1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmF0aGVyIHRoYW4gYXBwcm9hY2hpbmcgZXZlbnQgc3Vic2NyaXB0aW9uIHVzaW5nIGEgZnVuY3Rpb25hbCBhcHByb2FjaCwgd2UgaGVyZSBkbyBpdCBpbiBhIGZvci1sb29wIHdoZXJlIHN1YnNjcmliZXIgaXMgZXhlY3V0ZWQgaW4gaXRzIG93biBzdGFja1xuICAgICAgICAgICAgICAgIC8vIGVuYWJsaW5nIHRoYXQgYW55IGV4Y2VwdGlvbiB0aGF0IG9jY3VyIHdvbnQgZGlzdHVyYiB0aGUgaW5pdGlhdG9yIGFuZCBhbHNvIG5vdCBuZXNjZXNzYXJ5IGJlIGNhdGNoZWQgYW5kIGZvcmdvdHRlbi5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1hemF0aW9uLXNhZmUgY2xvbmluZyBvZiBhcmd1bWVudHMgaW50byBhcmdzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZWFjaCBzdWJzY3JpYmVyOlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2FwKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICogRGV4aWUuanMgLSBhIG1pbmltYWxpc3RpYyB3cmFwcGVyIGZvciBJbmRleGVkREJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcgRGF2aWQgRmFobGFuZGVyXG4gKlxuICogVmVyc2lvbiAyLjAuMiwgVGh1IE1hciAwMSAyMDE4XG4gKlxuICogaHR0cDovL2RleGllLm9yZ1xuICpcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqL1xudmFyIERFWElFX1ZFUlNJT04gPSAnMi4wLjInO1xudmFyIG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xudmFyIG1heEtleSA9IChmdW5jdGlvbiAoKSB7IHRyeSB7XG4gICAgSURCS2V5UmFuZ2Uub25seShbW11dKTtcbiAgICByZXR1cm4gW1tdXTtcbn1cbmNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG1heFN0cmluZztcbn0gfSkoKTtcbnZhciBtaW5LZXkgPSAtSW5maW5pdHk7XG52YXIgSU5WQUxJRF9LRVlfQVJHVU1FTlQgPSBcIkludmFsaWQga2V5IHByb3ZpZGVkLiBLZXlzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgRGF0ZSBvciBBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBEYXRlPi5cIjtcbnZhciBTVFJJTkdfRVhQRUNURUQgPSBcIlN0cmluZyBleHBlY3RlZC5cIjtcbnZhciBjb25uZWN0aW9ucyA9IFtdO1xudmFyIGlzSUVPckVkZ2UgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvKE1TSUV8VHJpZGVudHxFZGdlKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnID0gaXNJRU9yRWRnZTtcbnZhciBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSA9IGlzSUVPckVkZ2U7XG52YXIgZGV4aWVTdGFja0ZyYW1lRmlsdGVyID0gZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiAhLyhkZXhpZVxcLmpzfGRleGllXFwubWluXFwuanMpLy50ZXN0KGZyYW1lKTsgfTtcbnZhciBkYk5hbWVzREI7IC8vIEdsb2JhbCBkYXRhYmFzZSBmb3IgYmFja2luZyBEZXhpZS5nZXREYXRhYmFzZU5hbWVzKCkgb24gYnJvd3NlciB3aXRob3V0IGluZGV4ZWREQi53ZWJraXRHZXREYXRhYmFzZU5hbWVzKCkgXG4vLyBJbml0IGRlYnVnXG5zZXREZWJ1ZyhkZWJ1ZywgZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcbmZ1bmN0aW9uIERleGllKGRiTmFtZSwgb3B0aW9ucykge1xuICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9wdGlvbnNcIiB0eXBlPVwiT2JqZWN0XCIgb3B0aW9uYWw9XCJ0cnVlXCI+U3BlY2lmeSBvbmx5IGlmIHlvdSB3aWNoIHRvIGNvbnRyb2wgd2hpY2ggYWRkb25zIHRoYXQgc2hvdWxkIHJ1biBvbiB0aGlzIGluc3RhbmNlPC9wYXJhbT5cbiAgICB2YXIgZGVwcyA9IERleGllLmRlcGVuZGVuY2llcztcbiAgICB2YXIgb3B0cyA9IGV4dGVuZCh7XG4gICAgICAgIC8vIERlZmF1bHQgT3B0aW9uc1xuICAgICAgICBhZGRvbnM6IERleGllLmFkZG9ucyxcbiAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsXG4gICAgICAgIElEQktleVJhbmdlOiBkZXBzLklEQktleVJhbmdlIC8vIEJhY2tlbmQgSURCS2V5UmFuZ2UgYXBpLiBEZWZhdWx0IHRvIGJyb3dzZXIgZW52LlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHZhciBhZGRvbnMgPSBvcHRzLmFkZG9ucywgYXV0b09wZW4gPSBvcHRzLmF1dG9PcGVuLCBpbmRleGVkREIgPSBvcHRzLmluZGV4ZWREQiwgSURCS2V5UmFuZ2UgPSBvcHRzLklEQktleVJhbmdlO1xuICAgIHZhciBnbG9iYWxTY2hlbWEgPSB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgIHZhciB2ZXJzaW9ucyA9IFtdO1xuICAgIHZhciBkYlN0b3JlTmFtZXMgPSBbXTtcbiAgICB2YXIgYWxsVGFibGVzID0ge307XG4gICAgLy8vPHZhciB0eXBlPVwiSURCRGF0YWJhc2VcIiAvPlxuICAgIHZhciBpZGJkYiA9IG51bGw7IC8vIEluc3RhbmNlIG9mIElEQkRhdGFiYXNlXG4gICAgdmFyIGRiT3BlbkVycm9yID0gbnVsbDtcbiAgICB2YXIgaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICAgIHZhciBvblJlYWR5QmVpbmdGaXJlZCA9IG51bGw7XG4gICAgdmFyIG9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgIHZhciBSRUFET05MWSA9IFwicmVhZG9ubHlcIiwgUkVBRFdSSVRFID0gXCJyZWFkd3JpdGVcIjtcbiAgICB2YXIgZGIgPSB0aGlzO1xuICAgIHZhciBkYlJlYWR5UmVzb2x2ZSwgZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBkYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSksIGNhbmNlbE9wZW4sIG9wZW5DYW5jZWxsZXIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICAgIGNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgfSk7XG4gICAgdmFyIGF1dG9TY2hlbWEgPSB0cnVlO1xuICAgIHZhciBoYXNOYXRpdmVHZXREYXRhYmFzZU5hbWVzID0gISFnZXROYXRpdmVHZXREYXRhYmFzZU5hbWVzRm4oaW5kZXhlZERCKSwgaGFzR2V0QWxsO1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIC8vIERlZmF1bHQgc3Vic2NyaWJlcnMgdG8gXCJ2ZXJzaW9uY2hhbmdlXCIgYW5kIFwiYmxvY2tlZFwiLlxuICAgICAgICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gaGFuZGxlcnMuIElmIGN1c3RvbSBoYW5kbGVycyByZXR1cm4gZmFsc2UsIHRoZXNlIGRlZmF1bHRcbiAgICAgICAgLy8gYmVoYXZpb3VycyB3aWxsIGJlIHByZXZlbnRlZC5cbiAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvciBmb3IgdmVyc2lvbmNoYW5nZSBldmVudCBpcyB0byBjbG9zZSBkYXRhYmFzZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIGJ5IGRvaW5nIGRiLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICAgICAgLy8gTGV0J3Mgbm90IGJsb2NrIHRoZSBvdGhlciB3aW5kb3cgZnJvbSBtYWtpbmcgaXQncyBkZWxldGUoKSBvciBvcGVuKCkgY2FsbC5cbiAgICAgICAgICAgIC8vIE5PVEUhIFRoaXMgZXZlbnQgaXMgbmV2ZXIgZmlyZWQgaW4gSUUsRWRnZSBvciBTYWZhcmkuXG4gICAgICAgICAgICBpZiAoZXYubmV3VmVyc2lvbiA+IDApXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIHVwZ3JhZGUgZGF0YWJhc2UgJ1wiICsgZGIubmFtZSArIFwiJy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gZGVsZXRlIGRhdGFiYXNlICdcIiArIGRiLm5hbWUgKyBcIicuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuXCIpO1xuICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIEluIG1hbnkgd2ViIGFwcGxpY2F0aW9ucywgaXQgd291bGQgYmUgcmVjb21tZW5kZWQgdG8gZm9yY2Ugd2luZG93LnJlbG9hZCgpXG4gICAgICAgICAgICAvLyB3aGVuIHRoaXMgZXZlbnQgb2NjdXJzLiBUbyBkbyB0aGF0LCBzdWJzY3JpYmUgdG8gdGhlIHZlcnNpb25jaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGFuZCBjYWxsIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSkgaWYgZXYubmV3VmVyc2lvbiA+IDAgKG5vdCBhIGRlbGV0aW9uKVxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHlvdXIgY3VycmVudCB3ZWIgYXBwIG9idmlvdXNseSBoYXMgb2xkIHNjaGVtYSBjb2RlIHRoYXQgbmVlZHNcbiAgICAgICAgICAgIC8vIHRvIGJlIHVwZGF0ZWQuIEFub3RoZXIgd2luZG93IGdvdCBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIGFwcCBhbmQgbmVlZHMgdG8gdXBncmFkZSBEQiBidXRcbiAgICAgICAgICAgIC8vIHlvdXIgd2luZG93IGlzIGJsb2NraW5nIGl0IHVubGVzcyB3ZSBjbG9zZSBpdCBoZXJlLlxuICAgICAgICB9KTtcbiAgICAgICAgZGIub24oXCJibG9ja2VkXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRleGllLmRlbGV0ZSgnXCIgKyBkYi5uYW1lICsgXCInKSB3YXMgYmxvY2tlZFwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVcGdyYWRlICdcIiArIGRiLm5hbWUgKyBcIicgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiBcIiArIGV2Lm9sZFZlcnNpb24gLyAxMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFZlcnNpb25pbmcgRnJhbWV3b3JrLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgdGhpcy52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVyc2lvbk51bWJlclwiIHR5cGU9XCJOdW1iZXJcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIlZlcnNpb25cIj48L3JldHVybnM+XG4gICAgICAgIGlmIChpZGJkYiB8fCBpc0JlaW5nT3BlbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiQ2Fubm90IGFkZCB2ZXJzaW9uIHdoZW4gZGF0YWJhc2UgaXMgb3BlblwiKTtcbiAgICAgICAgdGhpcy52ZXJubyA9IE1hdGgubWF4KHRoaXMudmVybm8sIHZlcnNpb25OdW1iZXIpO1xuICAgICAgICB2YXIgdmVyc2lvbkluc3RhbmNlID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA9PT0gdmVyc2lvbk51bWJlcjsgfSlbMF07XG4gICAgICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgICAgICB2ZXJzaW9uSW5zdGFuY2UgPSBuZXcgVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uSW5zdGFuY2UpO1xuICAgICAgICB2ZXJzaW9ucy5zb3J0KGxvd2VyVmVyc2lvbkZpcnN0KTtcbiAgICAgICAgLy8gRGlzYWJsZSBhdXRvc2NoZW1hIG1vZGUsIGFzIGF0IGxlYXN0IG9uZSB2ZXJzaW9uIGlzIHNwZWNpZmllZC5cbiAgICAgICAgYXV0b1NjaGVtYSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2NmZyA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBkYnNjaGVtYToge30sXG4gICAgICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9yZXMoe30pOyAvLyBEZXJpdmUgZWFybGllciBzY2hlbWFzIGJ5IGRlZmF1bHQuXG4gICAgfVxuICAgIGV4dGVuZChWZXJzaW9uLnByb3RvdHlwZSwge1xuICAgICAgICBzdG9yZXM6IGZ1bmN0aW9uIChzdG9yZXMpIHtcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyAgIERlZmluZXMgdGhlIHNjaGVtYSBmb3IgYSBwYXJ0aWN1bGFyIHZlcnNpb25cbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdG9yZXNcIiB0eXBlPVwiT2JqZWN0XCI+XG4gICAgICAgICAgICAvLy8gRXhhbXBsZTogPGJyLz5cbiAgICAgICAgICAgIC8vLyAgIHt1c2VyczogXCJpZCsrLGZpcnN0LGxhc3QsJmFtcDt1c2VybmFtZSwqZW1haWxcIiwgPGJyLz5cbiAgICAgICAgICAgIC8vLyAgIHBhc3N3b3JkczogXCJpZCsrLCZhbXA7dXNlcm5hbWVcIn08YnIvPlxuICAgICAgICAgICAgLy8vIDxici8+XG4gICAgICAgICAgICAvLy8gU3ludGF4OiB7VGFibGU6IFwiW3ByaW1hcnlLZXldWysrXSxbJmFtcDtdWypdaW5kZXgxLFsmYW1wO11bKl1pbmRleDIsLi4uXCJ9PGJyLz48YnIvPlxuICAgICAgICAgICAgLy8vIFNwZWNpYWwgY2hhcmFjdGVyczo8YnIvPlxuICAgICAgICAgICAgLy8vICBcIiZhbXA7XCIgIG1lYW5zIHVuaXF1ZSBrZXksIDxici8+XG4gICAgICAgICAgICAvLy8gIFwiKlwiICBtZWFucyB2YWx1ZSBpcyBtdWx0aUVudHJ5LCA8YnIvPlxuICAgICAgICAgICAgLy8vICBcIisrXCIgbWVhbnMgYXV0by1pbmNyZW1lbnQgYW5kIG9ubHkgYXBwbGljYWJsZSBmb3IgcHJpbWFyeSBrZXkgPGJyLz5cbiAgICAgICAgICAgIC8vLyA8L3BhcmFtPlxuICAgICAgICAgICAgdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA9IHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPyBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKSA6IHN0b3JlcztcbiAgICAgICAgICAgIC8vIERlcml2ZSBzdG9yZXMgZnJvbSBlYXJsaWVyIHZlcnNpb25zIGlmIHRoZXkgYXJlIG5vdCBleHBsaWNpdGVseSBzcGVjaWZpZWQgYXMgbnVsbCBvciBhIG5ldyBzeW50YXguXG4gICAgICAgICAgICB2YXIgc3RvcmVzU3BlYyA9IHt9O1xuICAgICAgICAgICAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGV4dGVuZChzdG9yZXNTcGVjLCB2ZXJzaW9uLl9jZmcuc3RvcmVzU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRic2NoZW1hID0gKHRoaXMuX2NmZy5kYnNjaGVtYSA9IHt9KTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXNTcGVjLCBkYnNjaGVtYSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhdGVzdCBzY2hlbWEgdG8gdGhpcyB2ZXJzaW9uXG4gICAgICAgICAgICAvLyBVcGRhdGUgQVBJXG4gICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShbYWxsVGFibGVzLCBkYiwgVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7IC8vIEtlZXAgVHJhbnNhY3Rpb24ucHJvdG90eXBlIGV2ZW4gdGhvdWdoIGl0IHNob3VsZCBiZSBkZXByLlxuICAgICAgICAgICAgc2V0QXBpT25QbGFjZShbYWxsVGFibGVzLCBkYiwgVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB0aGlzLl9jZmcudGFibGVzXSwga2V5cyhkYnNjaGVtYSksIGRic2NoZW1hKTtcbiAgICAgICAgICAgIGRiU3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZ3JhZGU6IGZ1bmN0aW9uICh1cGdyYWRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInVwZ3JhZGVGdW5jdGlvblwiIG9wdGlvbmFsPVwidHJ1ZVwiPkZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgdXBncmFkaW5nIGFjdGlvbnMuPC9wYXJhbT5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHVwZ3JhZGVGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfcGFyc2VTdG9yZXNTcGVjOiBmdW5jdGlvbiAoc3RvcmVzLCBvdXRTY2hlbWEpIHtcbiAgICAgICAgICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlVGVtcGxhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBwYXJzZUluZGV4U3ludGF4KHN0b3Jlc1t0YWJsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpLXZhbHVlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkua2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbnN0YW5jZVRlbXBsYXRlLCBwcmltS2V5LmtleVBhdGgsIHByaW1LZXkuYXV0byA/IDAgOiBwcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIk9ubHkgcHJpbWFyeSBrZXkgY2FuIGJlIG1hcmtlZCBhcyBhdXRvSW5jcmVtZW50ICgrKylcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlkeC5rZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkluZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaW5zdGFuY2VUZW1wbGF0ZSwgaWR4LmtleVBhdGgsIGlkeC5jb21wb3VuZCA/IGlkeC5rZXlQYXRoLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiOyB9KSA6IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSBuZXcgVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzLCBpbnN0YW5jZVRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJ1blVwZ3JhZGVycyhvbGRWZXJzaW9uLCBpZGJ0cmFucywgcmVqZWN0KSB7XG4gICAgICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihSRUFEV1JJVEUsIGRiU3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICAgICAgdHJhbnMuY3JlYXRlKGlkYnRyYW5zKTtcbiAgICAgICAgdHJhbnMuX2NvbXBsZXRpb24uY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgdmFyIHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcbiAgICAgICAgbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0YWJsZXM6XG4gICAgICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLmZvbGxvdyhmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKTsgfSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMob2xkVmVyc2lvbiwgdHJhbnMsIGlkYnRyYW5zKS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKG9sZFZlcnNpb24sIHRyYW5zLCBpZGJ0cmFucykge1xuICAgICAgICAvLyBVcGdyYWRlIHZlcnNpb24gdG8gdmVyc2lvbiwgc3RlcC1ieS1zdGVwIGZyb20gb2xkZXN0IHRvIG5ld2VzdCB2ZXJzaW9uLlxuICAgICAgICAvLyBFYWNoIHRyYW5zYWN0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIHRhYmxlIHNldCB0aGF0IHdhcyBjdXJyZW50IGluIHRoYXQgdmVyc2lvbiAoYnV0IGFsc28gbm90LXlldC1kZWxldGVkIHRhYmxlcyBmcm9tIGl0cyBwcmV2aW91cyB2ZXJzaW9uKVxuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIG9sZFZlcnNpb25TdHJ1Y3QgPSB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24gKHZlcnNpb24pIHsgcmV0dXJuIHZlcnNpb24uX2NmZy52ZXJzaW9uID09PSBvbGRWZXJzaW9uOyB9KVswXTtcbiAgICAgICAgaWYgKCFvbGRWZXJzaW9uU3RydWN0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIkRleGllIHNwZWNpZmljYXRpb24gb2YgY3VycmVudGx5IGluc3RhbGxlZCBEQiB2ZXJzaW9uIGlzIG1pc3NpbmdcIik7XG4gICAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG9sZFZlcnNpb25TdHJ1Y3QuX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgdmFyIGFueUNvbnRlbnRVcGdyYWRlckhhc1J1biA9IGZhbHNlO1xuICAgICAgICB2YXIgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Ll9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb247IH0pO1xuICAgICAgICB2ZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVyc2lvblwiIHR5cGU9XCJWZXJzaW9uXCI+PC9wYXJhbT5cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhvbGRTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBuZXdTY2hlbWE7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGFibGVzICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkaWZmLmFkZC5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdHVwbGVbMF0sIHR1cGxlWzFdLnByaW1LZXksIHR1cGxlWzFdLmluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0YWJsZXNcbiAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShjaGFuZ2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgaW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlSW5kZXgoaWR4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgaW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5mb3JFYWNoKGZ1bmN0aW9uIChpZHhOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlSW5kZXgoaWR4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuZm9sbG93KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24uX2NmZy5jb250ZW50VXBncmFkZSh0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFueUNvbnRlbnRVcGdyYWRlckhhc1J1biB8fCAhaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgb2xkIHRhYmxlc1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm93LCBjcmVhdGUgYSBxdWV1ZSBleGVjdXRpb24gZW5naW5lXG4gICAgICAgIGZ1bmN0aW9uIHJ1blF1ZXVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IFByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlTWlzc2luZ1RhYmxlcyhnbG9iYWxTY2hlbWEsIGlkYnRyYW5zKTsgLy8gQXQgbGFzdCwgbWFrZSBzdXJlIHRvIGNyZWF0ZSBhbnkgbWlzc2luZyB0YWJsZXMuIChOZWVkZWQgYnkgYWRkb25zIHRoYXQgYWRkIHN0b3JlcyB0byBEQiB3aXRob3V0IHNwZWNpZnlpbmcgdmVyc2lvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgICAgICBkZWw6IFtdLFxuICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgIGNoYW5nZTogW10gLy8gQXJyYXkgb2Yge25hbWU6IHRhYmxlTmFtZSwgcmVjcmVhdGU6IG5ld0RlZmluaXRpb24sIGRlbDogZGVsSW5kZXhOYW1lcywgYWRkOiBuZXdJbmRleERlZnMsIGNoYW5nZTogY2hhbmdlZEluZGV4RGVmc31cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgdGFibGUgaW4gb2xkU2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pXG4gICAgICAgICAgICAgICAgZGlmZi5kZWwucHVzaCh0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBvbGREZWYgPSBvbGRTY2hlbWFbdGFibGVdLCBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuICAgICAgICAgICAgaWYgKCFvbGREZWYpIHtcbiAgICAgICAgICAgICAgICBkaWZmLmFkZC5wdXNoKFt0YWJsZSwgbmV3RGVmXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBuZXdEZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG9sZERlZi5wcmltS2V5LnNyYyAhPT0gbmV3RGVmLnByaW1LZXkuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1hcnkga2V5IGhhcyBjaGFuZ2VkLiBSZW1vdmUgYW5kIHJlLWFkZCB0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FtZSBwcmltYXJ5IGtleS4gSnVzdCBmaW5kIG91dCB3aGF0IGRpZmZlcnM6XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRJbmRleGVzID0gb2xkRGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLnB1c2goaWR4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRJZHggPSBvbGRJbmRleGVzW2lkeE5hbWVdLCBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGVsLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmFkZC5sZW5ndGggPiAwIHx8IGNoYW5nZS5jaGFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlkYnRyYW5zXCIgdHlwZT1cIklEQlRyYW5zYWN0aW9uXCI+PC9wYXJhbT5cbiAgICAgICAgdmFyIHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVOYW1lLCBwcmltS2V5LmtleVBhdGggPyB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOiB7IGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9KTtcbiAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHsgYWRkSW5kZXgoc3RvcmUsIGlkeCk7IH0pO1xuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuICAgICAgICBrZXlzKG5ld1NjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAobmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkSW5kZXgoc3RvcmUsIGlkeCkge1xuICAgICAgICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy9cbiAgICAvLyAgICAgIERleGllIFByb3RlY3RlZCBBUElcbiAgICAvL1xuICAgIC8vXG4gICAgdGhpcy5fYWxsVGFibGVzID0gYWxsVGFibGVzO1xuICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgfTtcbiAgICAvKiBHZW5lcmF0ZSBhIHRlbXBvcmFyeSB0cmFuc2FjdGlvbiB3aGVuIGRiIG9wZXJhdGlvbnMgYXJlIGRvbmUgb3V0c2lkZSBhIHRyYW5zYWN0aW9uIHNjb3BlLlxuICAgICovXG4gICAgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG4gICAgICAgIGlmICghb3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2gpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF1dG9PcGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnMuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgcmVzb2x2aW5nIHZhbHVlIGRpcmVjdGx5LCB3YWl0IHdpdGggcmVzb2x2aW5nIGl0IHVudGlsIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBkYXRhIHdvdWxkIG5vdCBiZSBpbiB0aGUgREIgaWYgcmVxdWVzdGluZyBpdCBpbiB0aGUgdGhlbigpIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBTcGVjaWZpY2FsbHksIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiB3aWxsIHdvcms6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIGRiLmZyaWVuZHMucHV0KHtuYW1lOiBcIkFybmVcIn0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIGRiLmZyaWVuZHMud2hlcmUoXCJuYW1lXCIpLmVxdWFscyhcIkFybmVcIikuY291bnQoZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgYXNzZXJ0IChjb3VudCA9PT0gMSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG4gICAgICAgICAgICB9KTsgLyouY2F0Y2goZXJyID0+IHsgLy8gRG9uJ3QgZG8gdGhpcyBhcyBvZiBub3cuIElmIHdvdWxkIGFmZmVjdCBidWxrLSBhbmQgbW9kaWZ5IG1ldGhvZHMgaW4gYSB3YXkgdGhhdCBjb3VsZCBiZSBtb3JlIGludHVpdGl2ZS4gQnV0IHdhaXQhIE1heWJlIGNoYW5nZSBpbiBuZXh0IG1ham9yLlxuICAgICAgICAgICAgICAgIHRyYW5zLl9yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGVycik7XG4gICAgICAgICAgICB9KTsqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3doZW5SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gb3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoID8gZm4oKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICghaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghYXV0b09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKGZuKTtcbiAgICB9O1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgLy8gICAgICBEZXhpZSBBUElcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICB0aGlzLnZlcm5vID0gMDtcbiAgICB0aGlzLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0JlaW5nT3BlbmVkIHx8IGlkYmRiKVxuICAgICAgICAgICAgcmV0dXJuIGRiUmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZGJPcGVuRXJyb3IgPyByZWplY3Rpb24oZGJPcGVuRXJyb3IpIDogZGI7IH0pO1xuICAgICAgICBkZWJ1ZyAmJiAob3BlbkNhbmNlbGxlci5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpKTsgLy8gTGV0IHN0YWNrcyBwb2ludCB0byB3aGVuIG9wZW4oKSB3YXMgY2FsbGVkIHJhdGhlciB0aGFuIHdoZXJlIG5ldyBEZXhpZSgpIHdhcyBjYWxsZWQuXG4gICAgICAgIGlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICAgICAgICBkYk9wZW5FcnJvciA9IG51bGw7XG4gICAgICAgIG9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAvLyBGdW5jdGlvbiBwb2ludGVycyB0byBjYWxsIHdoZW4gdGhlIGNvcmUgb3BlbmluZyBwcm9jZXNzIGNvbXBsZXRlcy5cbiAgICAgICAgdmFyIHJlc29sdmVEYlJlYWR5ID0gZGJSZWFkeVJlc29sdmUsIFxuICAgICAgICAvLyB1cGdyYWRlVHJhbnNhY3Rpb24gdG8gYWJvcnQgb24gZmFpbHVyZS5cbiAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbb3BlbkNhbmNlbGxlciwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGRiLnZlcm5vIHdpdGggMTAgd2lsbCBiZSBuZWVkZWQgdG8gd29ya2Fyb3VuZCB1cGdyYWRpbmcgYnVnIGluIElFOlxuICAgICAgICAgICAgICAgIC8vIElFIGZhaWxzIHdoZW4gZGVsZXRpbmcgb2JqZWN0U3RvcmUgYWZ0ZXIgcmVhZGluZyBmcm9tIGl0LlxuICAgICAgICAgICAgICAgIC8vIEEgZnV0dXJlIHZlcnNpb24gb2YgRGV4aWUuanMgd2lsbCBzdG9wb3ZlciBhbiBpbnRlcm1lZGlhdGUgdmVyc2lvbiB0byB3b3JrYXJvdW5kIHRoaXMuXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhhdCBwb2ludCwgd2Ugd2FudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlLiBDb3VsZCBoYXZlIGJlZW4gbXVsdGlwbGllZCB3aXRoIDIsIGJ1dCBieSB1c2luZyAxMCwgaXQgaXMgZWFzaWVyIHRvIG1hcCB0aGUgbnVtYmVyIHRvIHRoZSByZWFsIHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgICAgICAgIC8vIElmIG5vIEFQSSwgdGhyb3chXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleGVkREIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoXCJpbmRleGVkREIgQVBJIG5vdCBmb3VuZC4gSWYgdXNpbmcgSUUxMCssIG1ha2Ugc3VyZSB0byBydW4geW91ciBjb2RlIG9uIGEgc2VydmVyIFVSTCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihub3QgbG9jYWxseSkuIElmIHVzaW5nIG9sZCBTYWZhcmkgdmVyc2lvbnMsIG1ha2Ugc3VyZSB0byBpbmNsdWRlIGluZGV4ZWREQiBwb2x5ZmlsbC5cIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IGF1dG9TY2hlbWEgPyBpbmRleGVkREIub3BlbihkYk5hbWUpIDogaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBNYXRoLnJvdW5kKGRiLnZlcm5vICogMTApKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShcIkluZGV4ZWREQiBBUEkgbm90IGF2YWlsYWJsZVwiKTsgLy8gTWF5IGhhcHBlbiBpbiBTYWZhcmkgcHJpdmF0ZSBtb2RlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzEzNFxuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHdyYXAoZmlyZU9uQmxvY2tlZCk7XG4gICAgICAgICAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b1NjaGVtYSAmJiAhZGIuX2FsbG93RW1wdHlEQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVyIGRpZCBub3Qgc3BlY2lmeSBhIHZlcnNpb24gb3Igc2NoZW1hLiBEb2luZyB0aGF0IGlzIG9ubHkgYWNjZXB0YWJsZSBmb3Igb3BlbmluZyBhbHJlYWQgZXhpc3RpbmcgZGF0YWJhc2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb251cGdyYWRlbmVlZGVkIGlzIGNhbGxlZCBpdCBtZWFucyBkYXRhYmFzZSBkaWQgbm90IGV4aXN0LiBSZWplY3QgdGhlIG9wZW4oKSBwcm9taXNlIGFuZCBtYWtlIHN1cmUgdGhhdCB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSBhIG5ldyBkYXRhYmFzZSBieSBhY2NpZGVudCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBwcmV2ZW50RGVmYXVsdDsgLy8gUHJvaGliaXQgb25hYm9ydCBlcnJvciBmcm9tIGZpcmluZyBiZWZvcmUgd2UncmUgZG9uZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpOyAvLyBBYm9ydCB0cmFuc2FjdGlvbiAod291bGQgaG9wZSB0aGF0IHRoaXMgd291bGQgbWFrZSBEQiBkaXNhcHBlYXIgYnV0IGl0IGRvZXNudC4pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBkYXRhYmFzZSBhbmQgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpOyAvLyBUaGUgdXBncmFkZSB0cmFuc2FjdGlvbiBpcyBhdG9taWMsIGFuZCBqYXZhc2NyaXB0IGlzIHNpbmdsZSB0aHJlYWRlZCAtIG1lYW5pbmcgdGhhdCB0aGVyZSBpcyBubyByaXNrIHRoYXQgd2UgZGVsZXRlIHNvbWVvbmUgZWxzZXMgZGF0YWJhc2UgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5Ob1N1Y2hEYXRhYmFzZShcIkRhdGFiYXNlIFwiICsgZGJOYW1lICsgXCIgZG9lc250IGV4aXN0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uOyAvLyBTYWZhcmkgOCBmaXguXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5VcGdyYWRlcnMob2xkVmVyIC8gMTAsIHVwZ3JhZGVUcmFuc2FjdGlvbiwgcmVqZWN0LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcmUgb3BlbmluZyBwcm9jZWR1cmUgY29tcGxldGUuIE5vdyBsZXQncyBqdXN0IHJlY29yZCBzb21lIHN0dWZmLlxuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpOyAvLyBVc2VkIGZvciBlbXVsYXRpbmcgdmVyc2lvbmNoYW5nZSBldmVudCBvbiBJRS9FZGdlL1NhZmFyaS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9TY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhnbG9iYWxTY2hlbWEsIGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyksIFJFQURPTkxZKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBtYXkgYmFpbCBvdXQgaWYgPiAxIHN0b3JlIG5hbWVzLiBIb3dldmVyLCB0aGlzIHNob3VsZG50IGJlIGEgc2hvd3N0b3BwZXIuIElzc3VlICMxMjAuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLl92Y0ZpcmVkID0gdHJ1ZTsgLy8gZGV0ZWN0IGltcGxlbWVudGF0aW9ucyB0aGF0IG5vdCBzdXBwb3J0IHZlcnNpb25jaGFuZ2UgKElFL0VkZ2UvU2FmYXJpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNOYXRpdmVHZXREYXRhYmFzZU5hbWVzICYmIGRiTmFtZSAhPT0gJ19fZGJuYW1lcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiTmFtZXNEQi5kYm5hbWVzLnB1dCh7IG5hbWU6IGRiTmFtZSB9KS5jYXRjaChub3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSldKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEJlZm9yZSBmaW5hbGx5IHJlc29sdmluZyB0aGUgZGJSZWFkeVByb21pc2UgYW5kIHRoaXMgcHJvbWlzZSxcbiAgICAgICAgICAgIC8vIGNhbGwgYW5kIGF3YWl0IGFsbCBvbigncmVhZHknKSBzdWJzY3JpYmVyczpcbiAgICAgICAgICAgIC8vIERleGllLnZpcCgpIG1ha2VzIHN1YnNjcmliZXJzIGFibGUgdG8gdXNlIHRoZSBkYXRhYmFzZSB3aGlsZSBiZWluZyBvcGVuZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbXVzdCBzaW5jZSB0aGVzZSBzdWJzY3JpYmVycyB0YWtlIHBhcnQgb2YgdGhlIG9wZW5pbmcgcHJvY2VkdXJlLlxuICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoRGV4aWUudmlwKGRiLm9uLnJlYWR5LmZpcmUpKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgICAgICAgIGlmIChvblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgYWRkaXRpb25hbCBzdWJzY3JpYmVycyB0byBkYi5vbigncmVhZHknKSB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgdGltZSBkYi5vbi5yZWFkeS5maXJlIHdhcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlcnMgPSBvblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKERleGllLnZpcChyZW1haW5kZXJzKSkudGhlbihmaXJlUmVtYWluZGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIGRiLm9wZW4oKSB3aXRoIHRoZSBkYiBpbnN0YW5jZS5cbiAgICAgICAgICAgIGlzQmVpbmdPcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBkYjtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBEaWQgd2UgZmFpbCB3aXRoaW4gb251cGdyYWRlbmVlZGVkPyBNYWtlIHN1cmUgdG8gYWJvcnQgdGhlIHVwZ3JhZGUgdHJhbnNhY3Rpb24gc28gaXQgZG9lc250IGNvbW1pdC5cbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gJiYgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICBpc0JlaW5nT3BlbmVkID0gZmFsc2U7IC8vIFNldCBiZWZvcmUgY2FsbGluZyBkYi5jbG9zZSgpIHNvIHRoYXQgaXQgZG9lc250IHJlamVjdCBvcGVuQ2FuY2VsbGVyIGFnYWluIChsZWFkcyB0byB1bmhhbmRsZWQgcmVqZWN0aW9uIGV2ZW50KS5cbiAgICAgICAgICAgIGRiLmNsb3NlKCk7IC8vIENsb3NlcyBhbmQgcmVzZXRzIGlkYmRiLCByZW1vdmVzIGNvbm5lY3Rpb25zLCByZXNldHMgZGJSZWFkeVByb21pc2UgYW5kIG9wZW5DYW5jZWxsZXIgc28gdGhhdCBhIGxhdGVyIGRiLm9wZW4oKSBpcyBmcmVzaC5cbiAgICAgICAgICAgIC8vIEEgY2FsbCB0byBkYi5jbG9zZSgpIG1heSBoYXZlIG1hZGUgb24tcmVhZHkgc3Vic2NyaWJlcnMgZmFpbC4gVXNlIGRiT3BlbkVycm9yIGlmIHNldCwgc2luY2UgZXJyIGNvdWxkIGJlIGEgZm9sbG93LXVwIGVycm9yIG9uIHRoYXQuXG4gICAgICAgICAgICBkYk9wZW5FcnJvciA9IGVycjsgLy8gUmVjb3JkIHRoZSBlcnJvci4gSXQgd2lsbCBiZSB1c2VkIHRvIHJlamVjdCBmdXJ0aGVyIHByb21pc2VzIG9mIGRiIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGRiT3BlbkVycm9yKTtcbiAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZURiUmVhZHkoKTsgLy8gZGJSZWFkeVByb21pc2UgaXMgcmVzb2x2ZWQgbm8gbWF0dGVyIGlmIG9wZW4oKSByZWplY3RzIG9yIHJlc29sdmVkLiBJdCdzIGp1c3QgdG8gd2FrZSB1cCB3YWl0ZXJzLlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKGRiKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIGlmIChpZGJkYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZGJkYi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWRiZGIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGF1dG9PcGVuID0gZmFsc2U7XG4gICAgICAgIGRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICAgICAgaWYgKGlzQmVpbmdPcGVuZWQpXG4gICAgICAgICAgICBjYW5jZWxPcGVuKGRiT3BlbkVycm9yKTtcbiAgICAgICAgLy8gUmVzZXQgZGJSZWFkeVByb21pc2UgcHJvbWlzZTpcbiAgICAgICAgZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgb3BlbkNhbmNlbGxlciA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNBcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG5vdCBhbGxvd2VkIGluIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgICAgICAgaWYgKGlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBkYlJlYWR5UHJvbWlzZS50aGVuKGRvRGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvRGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkb0RlbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzTmF0aXZlR2V0RGF0YWJhc2VOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGJOYW1lc0RCLmRibmFtZXMuZGVsZXRlKGRiTmFtZSkuY2F0Y2gobm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXEub25ibG9ja2VkID0gZmlyZU9uQmxvY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmJhY2tlbmREQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkYmRiO1xuICAgIH07XG4gICAgdGhpcy5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZGJkYiAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuaGFzQmVlbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRiT3BlbkVycm9yICYmIChkYk9wZW5FcnJvciBpbnN0YW5jZW9mIGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkYk9wZW5FcnJvciAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuZHluYW1pY2FsbHlPcGVuZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhdXRvU2NoZW1hO1xuICAgIH07XG4gICAgLy9cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgLy9cbiAgICB0aGlzLm5hbWUgPSBkYk5hbWU7XG4gICAgLy8gZGIudGFibGVzIC0gYW4gYXJyYXkgb2YgYWxsIFRhYmxlIGluc3RhbmNlcy5cbiAgICBwcm9wcyh0aGlzLCB7XG4gICAgICAgIHRhYmxlczoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJBcnJheVwiIGVsZW1lbnRUeXBlPVwiVGFibGVcIiAvPlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzKGFsbFRhYmxlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBhbGxUYWJsZXNbbmFtZV07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9cbiAgICAvLyBFdmVudHNcbiAgICAvL1xuICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJwb3B1bGF0ZVwiLCBcImJsb2NrZWRcIiwgXCJ2ZXJzaW9uY2hhbmdlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSk7XG4gICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIsIGJTdGlja3kpIHtcbiAgICAgICAgICAgIERleGllLnZpcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEYXRhYmFzZSBhbHJlYWR5IG9wZW4uIENhbGwgc3Vic2NyaWJlciBhc2FwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRiT3BlbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYlN0aWNreTogQWxzbyBzdWJzY3JpYmUgdG8gZnV0dXJlIG9wZW4gc3VjZXNzZXMgKGFmdGVyIGNsb3NlIC8gcmVvcGVuKSBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uUmVhZHlCZWluZ0ZpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRiLm9uKCdyZWFkeScpIHN1YnNjcmliZXJzIGFyZSBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgYW5kIGhhdmUgbm90IHlldCByZXNvbHZlZCBvciByZWplY3RlZFxuICAgICAgICAgICAgICAgICAgICBvblJlYWR5QmVpbmdGaXJlZC5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhdGFiYXNlIG5vdCB5ZXQgb3Blbi4gU3Vic2NyaWJlIHRvIGl0LlxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGJTdGlja3kgaXMgZmFsc3ksIG1ha2Ugc3VyZSB0byB1bnN1YnNjcmliZSBzdWJzY3JpYmVyIHdoZW4gZmlyZWQgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiU3RpY2t5KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vLyA8c3VtbWFyeT5cbiAgICAgICAgLy8vXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1vZGVcIiB0eXBlPVwiU3RyaW5nXCI+XCJyXCIgZm9yIHJlYWRvbmx5LCBvciBcInJ3XCIgZm9yIHJlYWR3cml0ZTwvcGFyYW0+XG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRhYmxlSW5zdGFuY2VzXCI+VGFibGUgaW5zdGFuY2UsIEFycmF5IG9mIFRhYmxlIGluc3RhbmNlcywgU3RyaW5nIG9yIFN0cmluZyBBcnJheSBvZiBvYmplY3Qgc3RvcmVzIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9uPC9wYXJhbT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NvcGVGdW5jXCIgdHlwZT1cIkZ1bmN0aW9uXCI+RnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoIHRyYW5zYWN0aW9uPC9wYXJhbT5cbiAgICAgICAgdmFyIGFyZ3MgPSBleHRyYWN0VHJhbnNhY3Rpb25BcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAgICAgICAvLyBMZXQgdGFibGUgYXJndW1lbnRzIGJlIGFsbCBhcmd1bWVudHMgYmV0d2VlbiBtb2RlIGFuZCBsYXN0IGFyZ3VtZW50LlxuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIlRvbyBmZXcgYXJndW1lbnRzXCIpO1xuICAgICAgICAvLyBQcmV2ZW50IG9wdGltemF0aW9uIGtpbGxlciAoaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMyLWxlYWtpbmctYXJndW1lbnRzKVxuICAgICAgICAvLyBhbmQgY2xvbmUgYXJndW1lbnRzIGV4Y2VwdCB0aGUgZmlyc3Qgb25lIGludG8gbG9jYWwgdmFyICdhcmdzJy5cbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIC8vIExldCBzY29wZUZ1bmMgYmUgdGhlIGxhc3QgYXJndW1lbnQgYW5kIHBvcCBpdCBzbyB0aGF0IGFyZ3Mgbm93IG9ubHkgY29udGFpbiB0aGUgdGFibGUgYXJndW1lbnRzLlxuICAgICAgICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTsgLy8gU3VwcG9ydCB1c2luZyBhcnJheSBhcyBtaWRkbGUgYXJndW1lbnQsIG9yIGEgbWl4IG9mIGFycmF5cyBhbmQgbm9uLWFycmF5cy5cbiAgICAgICAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHRhYmxlcywgc2NvcGVGdW5jKSB7XG4gICAgICAgIHZhciBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGFyZW50IHRyYW5zYWN0aW9ucyBpcyBib3VuZCB0byB0aGlzIGRiIGluc3RhbmNlLCBhbmQgaWYgY2FsbGVyIHdhbnRzIHRvIHJldXNlIGl0XG4gICAgICAgIGlmICghcGFyZW50VHJhbnNhY3Rpb24gfHwgcGFyZW50VHJhbnNhY3Rpb24uZGIgIT09IGRiIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSlcbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKTsgLy8gT2suIFdpbGwgY2hhbmdlIGFyZ3VtZW50c1swXSBhcyB3ZWxsIGJ1dCB3ZSB3b250IHRvdWNoIGFyZ3VtZW50cyBoZW5jZWZvcnRoLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEdldCBzdG9yZU5hbWVzIGZyb20gYXJndW1lbnRzLiBFaXRoZXIgdGhyb3VnaCBnaXZlbiB0YWJsZSBpbnN0YW5jZXMsIG9yIHRocm91Z2ggZ2l2ZW4gdGFibGUgbmFtZXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHN0b3JlTmFtZXMgPSB0YWJsZXMubWFwKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWUgPSB0YWJsZSBpbnN0YW5jZW9mIFRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVOYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJlc29sdmUgbW9kZS4gQWxsb3cgc2hvcnRjdXRzIFwiclwiIGFuZCBcInJ3XCIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyXCIgfHwgbW9kZSA9PSBSRUFET05MWSlcbiAgICAgICAgICAgICAgICBtb2RlID0gUkVBRE9OTFk7XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicndcIiB8fCBtb2RlID09IFJFQURXUklURSlcbiAgICAgICAgICAgICAgICBtb2RlID0gUkVBRFdSSVRFO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIGNoZWNrc1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbi5tb2RlID09PSBSRUFET05MWSAmJiBtb2RlID09PSBSRUFEV1JJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uICYmIHBhcmVudFRyYW5zYWN0aW9uLnN0b3JlTmFtZXMuaW5kZXhPZihzdG9yZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJUYWJsZSBcIiArIHN0b3JlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJz8nIG1vZGUgc2hvdWxkIG5vdCBrZWVwIHVzaW5nIGFuIGluYWN0aXZlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmVqZWN0KGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWItdHJhbnNhY3Rpb24sIGxvY2sgdGhlIHBhcmVudCBhbmQgdGhlbiBsYXVuY2ggdGhlIHN1Yi10cmFuc2FjdGlvbi5cbiAgICAgICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShtb2RlLCBlbnRlclRyYW5zYWN0aW9uU2NvcGUsIFwibG9ja1wiKSA6XG4gICAgICAgICAgICBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgIC8vIG5vIHBhcmVudCB0cmFuc2FjdGlvbiBkZXNwaXRlIFBTRC50cmFucyBleGlzdHMuIE1ha2Ugc3VyZSBhbHNvXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgem9uZSB3ZSBjcmVhdGUgaXMgbm90IGEgc3ViLXpvbmUgb2YgY3VycmVudCwgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIFByb21pc2UuZm9sbG93KCkgc2hvdWxkIG5vdCB3YWl0IGZvciBpdCBpZiBzby5cbiAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uU2NvcGUpOyB9KSA6XG4gICAgICAgICAgICAgICAgZGIuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uU2NvcGUpKTtcbiAgICAgICAgZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIGxhc3Qgbm9uLXRyYW5zYWN0aW9uYWwgUFNEIHRvIHVzZSBpZiBzb21lb25lIGNhbGxzIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkuXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgICAgICAgICAgICAgIC8vIE91ciB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIExldCB0aGUgdHJhbnNhY3Rpb24gaW5zdGFuY2UgYmUgcGFydCBvZiBhIFByb21pc2Utc3BlY2lmaWMgZGF0YSAoUFNEKSB2YWx1ZS5cbiAgICAgICAgICAgICAgICB2YXIgem9uZVByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW11bGF0ZSB0cmFuc2FjdGlvbiBjb21taXQgYXdhcmVuZXNzIGZvciBpbm5lciB0cmFuc2FjdGlvbiAobXVzdCAnY29tbWl0JyB3aGVuIHRoZSBpbm5lciB0cmFuc2FjdGlvbiBoYXMgbm8gbW9yZSBvcGVyYXRpb25zIG9uZ29pbmcpXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5jcmVhdGUoKTsgLy8gQ3JlYXRlIHRoZSBiYWNrZW5kIHRyYW5zYWN0aW9uIHNvIHRoYXQgY29tcGxldGUoKSBvciBlcnJvcigpIHdpbGwgdHJpZ2dlciBldmVuIGlmIG5vIG9wZXJhdGlvbiBpcyBtYWRlIHVwb24gaXQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIG5hdGl2ZSBhc3luYyBhd2FpdC5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVGdW5jLmNvbnN0cnVjdG9yID09PSBBc3luY0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUZvbGxvd2VkID0gUHJvbWlzZS5mb2xsb3coZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBjYWxsIHRoZSBzY29wZSBmdW5jdGlvbiB3aXRoIG91ciB0YWJsZSBhbmQgdHJhbnNhY3Rpb24gYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLmNvbnN0cnVjdG9yID09PSBOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudG9yID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMuYmluZChudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY29wZUZ1bmMgcmV0dXJuZWQgYW4gaXRlcmF0b3Igd2l0aCB0aHJvdy1zdXBwb3J0LiBIYW5kbGUgeWllbGQgYXMgYXdhaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHpvbmVQcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb21pc2UgcmV0dXJuZWQuIFVzZXIgdXNlcyBwcm9taXNlLXN0eWxlIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS50aGVuKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0cmFucy5hY3RpdmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeCAvLyBUcmFuc2FjdGlvbiBzdGlsbCBhY3RpdmUuIENvbnRpbnVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHByb21pc2UgcmV0dXJuZWQuIFdhaXQgZm9yIGFsbCBvdXRzdGFuZGluZyBwcm9taXNlcyBiZWZvcmUgY29udGludWluZy4gXG4gICAgICAgICAgICAgICAgICAgIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVmFsdWU7IH0pKS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YiB0cmFuc2FjdGlvbnMgZG9uJ3QgcmVhY3QgdG8gaWRidHJhbnMub25jb21wbGV0ZS4gV2UgbXVzdCB0cmlnZ2VyIGEgY29tcGxldGlvbjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgdHJhbnMuX2NvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKGlmIHJvb3QgdHJhbnNhY3Rpb24sIHRoaXMgbWVhbnMgJ2NvbXBsZXRlJyBldmVudC4gSWYgc3ViLXRyYW5zYWN0aW9uLCB3ZSd2ZSBqdXN0IGZpcmVkIGl0IG91cnNlbHZlcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTsgLy8gWWVzLCBhYm92ZSB0aGVuLWhhbmRsZXIgd2VyZSBtYXliZSBub3QgY2FsbGVkIGJlY2F1c2Ugb2YgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpbiBzY29wZUZ1bmMhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50YWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJUYWJsZVwiPjwvcmV0dXJucz5cbiAgICAgICAgaWYgKCFoYXNPd24oYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxUYWJsZXNbdGFibGVOYW1lXTtcbiAgICB9O1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFRhYmxlIENsYXNzXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gVGFibGUobmFtZSwgdGFibGVTY2hlbWEsIG9wdGlvbmFsVHJhbnMpIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibmFtZVwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgICB0aGlzLl90eCA9IG9wdGlvbmFsVHJhbnM7XG4gICAgICAgIHRoaXMuaG9vayA9IGFsbFRhYmxlc1tuYW1lXSA/IGFsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcbiAgICAgICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJyZWFkaW5nXCI6IFtwdXJlRnVuY3Rpb25DaGFpbiwgbWlycm9yXSxcbiAgICAgICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbChlcnJvckxpc3QsIGRvbmUsIHN1cHBvcnRIb29rcykge1xuICAgICAgICByZXR1cm4gKHN1cHBvcnRIb29rcyA/IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciA6IGV2ZW50UmVqZWN0SGFuZGxlcikoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlzdC5wdXNoKGUpO1xuICAgICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWxrRGVsZXRlKGlkYnN0b3JlLCB0cmFucywga2V5c09yVHVwbGVzLCBoYXNEZWxldGVIb29rLCBkZWxldGluZ0hvb2spIHtcbiAgICAgICAgLy8gSWYgaGFzRGVsZXRlSG9vaywga2V5c09yVHVwbGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHVwbGVzOiBbW2tleTEsIHZhbHVlMl0sW2tleTIsdmFsdWUyXSwuLi5dLFxuICAgICAgICAvLyBlbHNlIGtleXNPclR1cGxlcyBtdXN0IGJlIGp1c3QgYW4gYXJyYXkgb2Yga2V5czogW2tleTEsIGtleTIsIC4uLl0uXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0ga2V5c09yVHVwbGVzLmxlbmd0aCwgbGFzdEl0ZW0gPSBsZW4gLSAxO1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKCFoYXNEZWxldGVIb29rKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRic3RvcmUuZGVsZXRlKGtleXNPclR1cGxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsYXN0SXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvb2tDdHgsIGVycm9ySGFuZGxlciA9IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpLCBzdWNjZXNzSGFuZGxlciA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIobnVsbCk7XG4gICAgICAgICAgICAgICAgdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rQ3R4ID0geyBvbnN1Y2Nlc3M6IG51bGwsIG9uZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IGtleXNPclR1cGxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW5nSG9vay5jYWxsKGhvb2tDdHgsIHR1cGxlWzBdLCB0dXBsZVsxXSwgdHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYnN0b3JlLmRlbGV0ZSh0dXBsZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuX2hvb2tDdHggPSBob29rQ3R4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdEl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBob29rQ3R4Lm9uZXJyb3IgJiYgaG9va0N0eC5vbmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzKFRhYmxlLnByb3RvdHlwZSwge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUYWJsZSBQcm90ZWN0ZWQgTWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICBfdHJhbnM6IGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSBkYiA/XG4gICAgICAgICAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLl9wcm9taXNlKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkgOlxuICAgICAgICAgICAgICAgICAgICBuZXdTY29wZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCBmbiwgd3JpdGVMb2NrZWQpOyB9LCB7IHRyYW5zOiB0cmFucywgdHJhbnNsZXNzOiBQU0QudHJhbnNsZXNzIHx8IFBTRCB9KSA6XG4gICAgICAgICAgICAgICAgdGVtcFRyYW5zYWN0aW9uKG1vZGUsIFt0aGlzLm5hbWVdLCBmbik7XG4gICAgICAgIH0sXG4gICAgICAgIF9pZGJzdG9yZTogZnVuY3Rpb24gZ2V0SURCT2JqZWN0U3RvcmUobW9kZSwgZm4sIHdyaXRlTG9ja2VkKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgZnVuY3Rpb24gc3VwcGx5SWRiU3RvcmUocmVzb2x2ZSwgcmVqZWN0LCB0cmFucykge1xuICAgICAgICAgICAgICAgIGlmICh0cmFucy5zdG9yZU5hbWVzLmluZGV4T2YodGFibGVOYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGVcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zLmlkYnRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSksIHRyYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucyhtb2RlLCBzdXBwbHlJZGJTdG9yZSwgd3JpdGVMb2NrZWQpO1xuICAgICAgICB9LFxuICAgICAgICAvL1xuICAgICAgICAvLyBUYWJsZSBQdWJsaWMgTWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgICAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKGtleU9yQ3JpdCkuZmlyc3QoY2IpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkYnN0b3JlKFJFQURPTkxZLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGJzdG9yZS5nZXQoa2V5T3JDcml0KTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLmhvb2sucmVhZGluZy5maXJlKHJlcS5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgIH0sXG4gICAgICAgIHdoZXJlOiBmdW5jdGlvbiAoaW5kZXhPckNyaXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVDbGF1c2UodGhpcywgXCJbXCIgKyBpbmRleE9yQ3JpdC5qb2luKCcrJykgKyBcIl1cIik7XG4gICAgICAgICAgICAvLyBpbmRleE9yQ3JpdCBpcyBhbiBvYmplY3QgbWFwIG9mIHtba2V5UGF0aF06dmFsdWV9IFxuICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIC8vIE9ubHkgb25lIGNyaXRlcmEuIFRoaXMgd2FzIHRoZSBlYXN5IGNhc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGluZGV4T3JDcml0W2tleVBhdGhzWzBdXSk7XG4gICAgICAgICAgICAvLyBNdWx0aXBsZSBjcml0ZXJpYXMuXG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgZmluZGluZyBhIGNvbXBvdW5kIGluZGV4IHRoYXQgbWF0Y2hlcyBhbGwga2V5UGF0aHMgaW5cbiAgICAgICAgICAgIC8vIGFyYnJpdGFyeSBvcmRlcjpcbiAgICAgICAgICAgIHZhciBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGZ1bmN0aW9uIChpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpeC5jb21wb3VuZCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRocy5ldmVyeShmdW5jdGlvbiAoa2V5UGF0aCkgeyByZXR1cm4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDA7IH0pICYmXG4gICAgICAgICAgICAgICAgICAgIGl4LmtleVBhdGguZXZlcnkoZnVuY3Rpb24gKGtleVBhdGgpIHsgcmV0dXJuIGtleVBhdGhzLmluZGV4T2Yoa2V5UGF0aCkgPj0gMDsgfSk7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGlmIChjb21wb3VuZEluZGV4ICYmIG1heEtleSAhPT0gbWF4U3RyaW5nKVxuICAgICAgICAgICAgICAgIC8vIENvb2whIFdlIGZvdW5kIHN1Y2ggY29tcG91bmQgaW5kZXhcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBicm93c2VyIHN1cHBvcnRzIGNvbXBvdW5kIGluZGV4ZXMgKG1heEtleSAhPT0gbWF4U3RyaW5nKSFcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUoY29tcG91bmRJbmRleC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKGNvbXBvdW5kSW5kZXgua2V5UGF0aC5tYXAoZnVuY3Rpb24gKGtwKSB7IHJldHVybiBpbmRleE9yQ3JpdFtrcF07IH0pKTtcbiAgICAgICAgICAgIGlmICghY29tcG91bmRJbmRleClcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgcXVlcnkgXCIgKyBKU09OLnN0cmluZ2lmeShpbmRleE9yQ3JpdCkgKyBcIiBvbiBcIiArIHRoaXMubmFtZSArIFwiIHdvdWxkIGJlbmVmaXQgb2YgYSBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcImNvbXBvdW5kIGluZGV4IFtcIiArIGtleVBhdGhzLmpvaW4oJysnKSArIFwiXVwiKSk7XG4gICAgICAgICAgICAvLyBPaywgbm93IGxldCdzIGZhbGxiYWNrIHRvIGZpbmRpbmcgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIGluZGV4XG4gICAgICAgICAgICAvLyBhbmQgZmlsdGVyIHRoZSByZXN0LlxuICAgICAgICAgICAgdmFyIGlkeEJ5TmFtZSA9IHRoaXMuc2NoZW1hLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgIHZhciBzaW1wbGVJbmRleCA9IGtleVBhdGhzLnJlZHVjZShmdW5jdGlvbiAociwga2V5UGF0aCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJbMF0gfHwgaWR4QnlOYW1lW2tleVBhdGhdLFxuICAgICAgICAgICAgICAgIHJbMF0gfHwgIWlkeEJ5TmFtZVtrZXlQYXRoXSA/XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmUoclsxXSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuICcnICsgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpID09XG4gICAgICAgICAgICAgICAgICAgICAgICAnJyArIGluZGV4T3JDcml0W2tleVBhdGhdOyB9KVxuICAgICAgICAgICAgICAgICAgICA6IHJbMV1cbiAgICAgICAgICAgIF07IH0sIFtudWxsLCBudWxsXSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc2ltcGxlSW5kZXhbMF07XG4gICAgICAgICAgICByZXR1cm4gaWR4ID9cbiAgICAgICAgICAgICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNpbXBsZUluZGV4WzFdKSA6XG4gICAgICAgICAgICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKHNpbXBsZUluZGV4WzFdKSA6IC8vIEhhcyBjb21wb3VuZCBidXQgYnJvd3NlciBiYWQuIEFsbG93IGZpbHRlci5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTsgLy8gTm8gaW5kZXggYXQgYWxsLiBGYWlsIGxhemlseS5cbiAgICAgICAgfSxcbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQoY2IpO1xuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICBsaW1pdDogZnVuY3Rpb24gKG51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmxpbWl0KG51bVJvd3MpO1xuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5yZXZlcnNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICB9LFxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goZm4pO1xuICAgICAgICB9LFxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkoY2IpO1xuICAgICAgICB9LFxuICAgICAgICBvcmRlckJ5OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihuZXcgV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuICAgICAgICAgICAgICAgIFwiW1wiICsgaW5kZXguam9pbignKycpICsgXCJdXCIgOlxuICAgICAgICAgICAgICAgIGluZGV4KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvQ29sbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKG5ldyBXaGVyZUNsYXVzZSh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1hcFRvQ2xhc3M6IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3RydWN0dXJlKSB7XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgICAgICAvLy8gICAgIE1hcCB0YWJsZSB0byBhIGphdmFzY3JpcHQgY29uc3RydWN0b3IgZnVuY3Rpb24uIE9iamVjdHMgcmV0dXJuZWQgZnJvbSB0aGUgZGF0YWJhc2Ugd2lsbCBiZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcywgbWFraW5nXG4gICAgICAgICAgICAvLy8gICAgIGl0IHBvc3NpYmxlIHRvIHRoZSBpbnN0YW5jZU9mIG9wZXJhdG9yIGFzIHdlbGwgYXMgZXh0ZW5kaW5nIHRoZSBjbGFzcyB1c2luZyBjb25zdHJ1Y3Rvci5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24oKXsuLi59LlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnN0cnVjdG9yXCI+Q29uc3RydWN0b3IgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBjbGFzcy48L3BhcmFtPlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RydWN0dXJlXCIgb3B0aW9uYWw9XCJ0cnVlXCI+SGVscHMgSURFIGNvZGUgY29tcGxldGlvbiBieSBrbm93aW5nIHRoZSBtZW1iZXJzIHRoYXQgb2JqZWN0cyBjb250YWluIGFuZCBub3QganVzdCB0aGUgaW5kZXhlcy4gQWxzb1xuICAgICAgICAgICAgLy8vIGtub3cgd2hhdCB0eXBlIGVhY2ggbWVtYmVyIGhhcy4gRXhhbXBsZToge25hbWU6IFN0cmluZywgZW1haWxBZGRyZXNzZXM6IFtTdHJpbmddLCBwYXNzd29yZH08L3BhcmFtPlxuICAgICAgICAgICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVRlbXBsYXRlID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyZSBhbmQgaW5zdGFuY2VUZW1wbGF0ZSBpcyBmb3IgSURFIGNvZGUgY29tcGV0aW9uIG9ubHkgd2hpbGUgY29uc3RydWN0b3IucHJvdG90eXBlIGlzIGZvciBhY3R1YWwgaW5oZXJpdGFuY2UuXG4gICAgICAgICAgICAgICAgYXBwbHlTdHJ1Y3R1cmUoaW5zdGFuY2VUZW1wbGF0ZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NoZW1hLmluc3RhbmNlVGVtcGxhdGUgPSBpbnN0YW5jZVRlbXBsYXRlO1xuICAgICAgICAgICAgLy8gTm93LCBzdWJzY3JpYmUgdG8gdGhlIHdoZW4oXCJyZWFkaW5nXCIpIGV2ZW50IHRvIG1ha2UgYWxsIG9iamVjdHMgdGhhdCBjb21lIG91dCBmcm9tIHRoaXMgdGFibGUgaW5oZXJpdCBmcm9tIGdpdmVuIGNsYXNzXG4gICAgICAgICAgICAvLyBubyBtYXR0ZXIgd2hpY2ggbWV0aG9kIHRvIHVzZSBmb3IgcmVhZGluZyAoVGFibGUuZ2V0KCkgb3IgVGFibGUud2hlcmUoLi4uKS4uLiApXG4gICAgICAgICAgICB2YXIgcmVhZEhvb2sgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7IC8vIE5vIHZhbGlkIG9iamVjdC4gKFZhbHVlIGlzIG51bGwpLiBSZXR1cm4gYXMgaXMuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0aGF0IGRlcml2ZXMgZnJvbSBjb25zdHJ1Y3RvcjpcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIC8vIENsb25lIG1lbWJlcnM6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW21dID0gb2JqW21dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcbiAgICAgICAgICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVDbGFzczogZnVuY3Rpb24gKHN0cnVjdHVyZSkge1xuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxuICAgICAgICAgICAgLy8vICAgICBEZWZpbmUgYWxsIG1lbWJlcnMgb2YgdGhlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyB0aGUgdGFibGUuIFRoaXMgd2lsbCBoZWxwIGNvZGUgY29tcGxldGlvbiBvZiB3aGVuIG9iamVjdHMgYXJlIHJlYWQgZnJvbSB0aGUgZGF0YWJhc2VcbiAgICAgICAgICAgIC8vLyAgICAgYXMgd2VsbCBhcyBtYWtpbmcgaXQgcG9zc2libGUgdG8gZXh0ZW5kIHRoZSBwcm90b3R5cGUgb2YgdGhlIHJldHVybmVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0cnVjdHVyZVwiPkhlbHBzIElERSBjb2RlIGNvbXBsZXRpb24gYnkga25vd2luZyB0aGUgbWVtYmVycyB0aGF0IG9iamVjdHMgY29udGFpbiBhbmQgbm90IGp1c3QgdGhlIGluZGV4ZXMuIEFsc29cbiAgICAgICAgICAgIC8vLyBrbm93IHdoYXQgdHlwZSBlYWNoIG1lbWJlciBoYXMuIEV4YW1wbGU6IHtuYW1lOiBTdHJpbmcsIGVtYWlsQWRkcmVzc2VzOiBbU3RyaW5nXSwgcHJvcGVydGllczoge3Nob2VTaXplOiBOdW1iZXJ9fTwvcGFyYW0+XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKERleGllLmRlZmluZUNsYXNzKHN0cnVjdHVyZSksIHN0cnVjdHVyZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1bGtEZWxldGU6IGZ1bmN0aW9uIChrZXlzJCQxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ob29rLmRlbGV0aW5nLmZpcmUgPT09IG5vcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZGJzdG9yZShSRUFEV1JJVEUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlLCB0cmFucykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJ1bGtEZWxldGUoaWRic3RvcmUsIHRyYW5zLCBrZXlzJCQxLCBmYWxzZSwgbm9wKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUoJzppZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hbnlPZihrZXlzJCQxKVxuICAgICAgICAgICAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyB9KTsgLy8gUmVzb2x2ZSB3aXRoIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnVsa1B1dDogZnVuY3Rpb24gKG9iamVjdHMsIGtleXMkJDEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWRic3RvcmUoUkVBRFdSSVRFLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgIGlmICghaWRic3RvcmUua2V5UGF0aCAmJiAhX3RoaXMuc2NoZW1hLnByaW1LZXkuYXV0byAmJiAha2V5cyQkMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa1B1dCgpIHdpdGggbm9uLWluYm91bmQga2V5cyByZXF1aXJlcyBrZXlzIGFycmF5IGluIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaWRic3RvcmUua2V5UGF0aCAmJiBrZXlzJCQxKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrUHV0KCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMkJDEgJiYga2V5cyQkMS5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTsgLy8gQ2FsbGVyIHByb3ZpZGVkIGVtcHR5IGxpc3QuXG4gICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckxpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEJ1bGtFcnJvcihfdGhpcy5uYW1lICsgXCIuYnVsa1B1dCgpOiBcIiArIGVycm9yTGlzdC5sZW5ndGggKyBcIiBvZiBcIiArIG51bU9ianMgKyBcIiBvcGVyYXRpb25zIGZhaWxlZFwiLCBlcnJvckxpc3QpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciByZXEsIGVycm9yTGlzdCA9IFtdLCBlcnJvckhhbmRsZXIsIG51bU9ianMgPSBvYmplY3RzLmxlbmd0aCwgdGFibGUgPSBfdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaG9vay5jcmVhdGluZy5maXJlID09PSBub3AgJiYgX3RoaXMuaG9vay51cGRhdGluZy5maXJlID09PSBub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgQnVsayAobm8gJ2NyZWF0aW5nJyBvciAndXBkYXRpbmcnIGhvb2tzIHRvIGNhcmUgYWJvdXQpXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlciA9IEJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbChlcnJvckxpc3QpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBrZXlzJCQxID8gaWRic3RvcmUucHV0KG9iamVjdHNbaV0sIGtleXMkJDFbaV0pIDogaWRic3RvcmUucHV0KG9iamVjdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBuZWVkIHRvIGNhdGNoIHN1Y2Nlc3Mgb3IgZXJyb3Igb24gdGhlIGxhc3Qgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgSURCIHNwZWMuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gQnVsa0Vycm9ySGFuZGxlckNhdGNoQWxsKGVycm9yTGlzdCwgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudFN1Y2Nlc3NIYW5kbGVyKGRvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVmZmVjdGl2ZUtleXMgPSBrZXlzJCQxIHx8IGlkYnN0b3JlLmtleVBhdGggJiYgb2JqZWN0cy5tYXAoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIGdldEJ5S2V5UGF0aChvLCBpZGJzdG9yZS5rZXlQYXRoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIG1hcCBvZiB7W2tleV06IG9iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdExvb2t1cCA9IGVmZmVjdGl2ZUtleXMgJiYgYXJyYXlUb09iamVjdChlZmZlY3RpdmVLZXlzLCBmdW5jdGlvbiAoa2V5LCBpKSB7IHJldHVybiBrZXkgIT0gbnVsbCAmJiBba2V5LCBvYmplY3RzW2ldXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gIWVmZmVjdGl2ZUtleXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXV0by1pbmNyZW1lbnRlZCBrZXktbGVzcyBvYmplY3RzIG9ubHkgd2l0aG91dCBhbnkga2V5cyBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmJ1bGtBZGQob2JqZWN0cykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2V5cyBwcm92aWRlZC4gRWl0aGVyIGFzIGluYm91bmQgaW4gcHJvdmlkZWQgb2JqZWN0cywgb3IgYXMgYSBrZXlzIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVnaW4gd2l0aCB1cGRhdGluZyB0aG9zZSB0aGF0IGV4aXN0cyBpbiBEQjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLndoZXJlKCc6aWQnKS5hbnlPZihlZmZlY3RpdmVLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgIT0gbnVsbDsgfSkpLm1vZGlmeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iamVjdExvb2t1cFt0aGlzLnByaW1LZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdExvb2t1cFt0aGlzLnByaW1LZXldID0gbnVsbDsgLy8gTWFyayBhcyBcImRvbid0IGFkZCB0aGlzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKE1vZGlmeUVycm9yLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTGlzdCA9IGUuZmFpbHVyZXM7IC8vIE5vIG5lZWQgdG8gY29uY2F0IGhlcmUuIFRoZXNlIGFyZSB0aGUgZmlyc3QgZXJyb3JzIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93LCBsZXQncyBleGFtaW5lIHdoaWNoIGl0ZW1zIGRpZG50IGV4aXN0IHNvIHdlIGNhbiBhZGQgdGhlbTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Jqc1RvQWRkID0gW10sIGtleXNUb0FkZCA9IGtleXMkJDEgJiYgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHMuIFdoeT8gQmVjYXVzZSBpZiBzYW1lIGtleSB3YXMgdXNlZCB0d2ljZSwganVzdCBhZGQgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBlZmZlY3RpdmVLZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBlZmZlY3RpdmVLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgb2JqZWN0TG9va3VwW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ianNUb0FkZC5wdXNoKG9iamVjdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cyQkMSAmJiBrZXlzVG9BZGQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdExvb2t1cFtrZXldID0gbnVsbDsgLy8gTWFyayBhcyBcImRvbnQgYWRkIGFnYWluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaXRlbXMgYXJlIGluIHJldmVyc2Ugb3JkZXIgc28gcmV2ZXJzZSB0aGVtIGJlZm9yZSBhZGRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgaW1wb3J0YW50IGluIG9yZGVyIHRvIGdldCBhdXRvLWluY3JlbWVudGVkIGtleXMgdGhlIHdheSB0aGUgY2FsbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgZXhwZWN0LiBDb3VsZCBoYXZlIHVzZWQgdW5zaGlmdCBpbnN0ZWFkIG9mIHB1c2goKS9yZXZlcnNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0OiBodHRwOi8vanNwZXJmLmNvbS91bnNoaWZ0LXZzLXJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpzVG9BZGQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMkJDEgJiYga2V5c1RvQWRkLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuYnVsa0FkZChvYmpzVG9BZGQsIGtleXNUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChsYXN0QWRkZWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHdpdGgga2V5IG9mIHRoZSBsYXN0IG9iamVjdCBpbiBnaXZlbiBhcmd1bWVudHMgdG8gYnVsa1B1dCgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0RWZmZWN0aXZlS2V5ID0gZWZmZWN0aXZlS2V5c1tlZmZlY3RpdmVLZXlzLmxlbmd0aCAtIDFdOyAvLyBLZXkgd2FzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0RWZmZWN0aXZlS2V5ICE9IG51bGwgPyBsYXN0RWZmZWN0aXZlS2V5IDogbGFzdEFkZGVkS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihkb25lKS5jYXRjaChCdWxrRXJyb3IsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25jYXQgZmFpbHVyZSBmcm9tIE1vZGlmeUVycm9yIGFuZCByZWplY3QgdXNpbmcgb3VyICdkb25lJyBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3QgPSBlcnJvckxpc3QuY29uY2F0KGUuZmFpbHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwibG9ja2VkXCIpOyAvLyBJZiBjYWxsZWQgZnJvbSB0cmFuc2FjdGlvbiBzY29wZSwgbG9jayB0cmFuc2FjdGlvbiB0aWwgYWxsIHN0ZXBzIGFyZSBkb25lLlxuICAgICAgICB9LFxuICAgICAgICBidWxrQWRkOiBmdW5jdGlvbiAob2JqZWN0cywga2V5cyQkMSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBjcmVhdGluZ0hvb2sgPSB0aGlzLmhvb2suY3JlYXRpbmcuZmlyZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZGJzdG9yZShSRUFEV1JJVEUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlLCB0cmFucykge1xuICAgICAgICAgICAgICAgIGlmICghaWRic3RvcmUua2V5UGF0aCAmJiAhc2VsZi5zY2hlbWEucHJpbUtleS5hdXRvICYmICFrZXlzJCQxKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCkgd2l0aCBub24taW5ib3VuZCBrZXlzIHJlcXVpcmVzIGtleXMgYXJyYXkgaW4gc2Vjb25kIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgICAgIGlmIChpZGJzdG9yZS5rZXlQYXRoICYmIGtleXMkJDEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyQkMSAmJiBrZXlzJCQxLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpOyAvLyBDYWxsZXIgcHJvdmlkZWQgZW1wdHkgbGlzdC5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb25lKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBCdWxrRXJyb3Ioc2VsZi5uYW1lICsgXCIuYnVsa0FkZCgpOiBcIiArIGVycm9yTGlzdC5sZW5ndGggKyBcIiBvZiBcIiArIG51bU9ianMgKyBcIiBvcGVyYXRpb25zIGZhaWxlZFwiLCBlcnJvckxpc3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcSwgZXJyb3JMaXN0ID0gW10sIGVycm9ySGFuZGxlciwgc3VjY2Vzc0hhbmRsZXIsIG51bU9ianMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmdIb29rICE9PSBub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHN1YnNjcmliZXJzIHRvIGhvb2soJ2NyZWF0aW5nJylcbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBiZWhhdmUgYXMgZG9jdW1lbnRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBpZGJzdG9yZS5rZXlQYXRoLCBob29rQ3R4O1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIgPSBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0hhbmRsZXIgPSBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB0cnlDYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9va0N0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXMkJDEgJiYga2V5cyQkMVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXSwgZWZmZWN0aXZlS2V5ID0ga2V5cyQkMSA/IGtleSA6IGtleVBhdGggPyBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKSA6IHVuZGVmaW5lZCwga2V5VG9Vc2UgPSBjcmVhdGluZ0hvb2suY2FsbChob29rQ3R4LCBlZmZlY3RpdmVLZXksIG9iaiwgdHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3RpdmVLZXkgPT0gbnVsbCAmJiBrZXlUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBkZWVwQ2xvbmUob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGtleVRvVXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleVRvVXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IGtleSAhPSBudWxsID8gaWRic3RvcmUuYWRkKG9iaiwga2V5KSA6IGlkYnN0b3JlLmFkZChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5faG9va0N0eCA9IGhvb2tDdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBsIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvb2tDdHgub25zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va0N0eC5vbmVycm9yICYmIGhvb2tDdHgub25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBkb25lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIoZG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBCdWxrIChubyAnY3JlYXRpbmcnIGhvb2sgdG8gY2FyZSBhYm91dClcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyID0gQnVsa0Vycm9ySGFuZGxlckNhdGNoQWxsKGVycm9yTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IGtleXMkJDEgPyBpZGJzdG9yZS5hZGQob2JqZWN0c1tpXSwga2V5cyQkMVtpXSkgOiBpZGJzdG9yZS5hZGQob2JqZWN0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG5lZWQgdG8gY2F0Y2ggc3VjY2VzcyBvciBlcnJvciBvbiB0aGUgbGFzdCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBJREIgc3BlYy5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBkb25lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50U3VjY2Vzc0hhbmRsZXIoZG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgICAgICAvLy8gICBBZGQgYW4gb2JqZWN0IHRvIHRoZSBkYXRhYmFzZS4gSW4gY2FzZSBhbiBvYmplY3Qgd2l0aCBzYW1lIHByaW1hcnkga2V5IGFscmVhZHkgZXhpc3RzLCB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9ialwiIHR5cGU9XCJPYmplY3RcIj5BIGphdmFzY3JpcHQgb2JqZWN0IHRvIGluc2VydDwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlcIiBvcHRpb25hbD1cInRydWVcIj5QcmltYXJ5IGtleTwvcGFyYW0+XG4gICAgICAgICAgICB2YXIgY3JlYXRpbmdIb29rID0gdGhpcy5ob29rLmNyZWF0aW5nLmZpcmU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWRic3RvcmUoUkVBRFdSSVRFLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSwgdHJhbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9va0N0eCA9IHsgb25zdWNjZXNzOiBudWxsLCBvbmVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nSG9vayAhPT0gbm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZmZlY3RpdmVLZXkgPSAoa2V5ICE9IG51bGwpID8ga2V5IDogKGlkYnN0b3JlLmtleVBhdGggPyBnZXRCeUtleVBhdGgob2JqLCBpZGJzdG9yZS5rZXlQYXRoKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlUb1VzZSA9IGNyZWF0aW5nSG9vay5jYWxsKGhvb2tDdHgsIGVmZmVjdGl2ZUtleSwgb2JqLCB0cmFucyk7IC8vIEFsbG93IHN1YnNjcmliZXJzIHRvIHdoZW4oXCJjcmVhdGluZ1wiKSB0byBnZW5lcmF0ZSB0aGUga2V5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWZmZWN0aXZlS2V5ID09IG51bGwgJiYga2V5VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkYnN0b3JlLmtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwgaWRic3RvcmUua2V5UGF0aCwga2V5VG9Vc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleVRvVXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBrZXkgIT0gbnVsbCA/IGlkYnN0b3JlLmFkZChvYmosIGtleSkgOiBpZGJzdG9yZS5hZGQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLl9ob29rQ3R4ID0gaG9va0N0eDtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBob29rZWRFdmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIHR3byBsaW5lcyBpbiBuZXh0IG1ham9yIHJlbGVhc2UgKDIuMD8pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIG5vIGdvb2QgcHJhY3RpY2UgdG8gaGF2ZSBzaWRlIGVmZmVjdHMgb24gcHJvdmlkZWQgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBpZGJzdG9yZS5rZXlQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rQ3R4Lm9uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBob29rQ3R4Lm9uZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dDogZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxuICAgICAgICAgICAgLy8vICAgQWRkIGFuIG9iamVjdCB0byB0aGUgZGF0YWJhc2UgYnV0IGluIGNhc2UgYW4gb2JqZWN0IHdpdGggc2FtZSBwcmltYXJ5IGtleSBhbHJlYWQgZXhpc3RzLCB0aGUgZXhpc3Rpbmcgb25lIHdpbGwgZ2V0IHVwZGF0ZWQuXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib2JqXCIgdHlwZT1cIk9iamVjdFwiPkEgamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zZXJ0IG9yIHVwZGF0ZTwvcGFyYW0+XG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlcIiBvcHRpb25hbD1cInRydWVcIj5QcmltYXJ5IGtleTwvcGFyYW0+XG4gICAgICAgICAgICB2YXIgY3JlYXRpbmdIb29rID0gdGhpcy5ob29rLmNyZWF0aW5nLmZpcmUsIHVwZGF0aW5nSG9vayA9IHRoaXMuaG9vay51cGRhdGluZy5maXJlO1xuICAgICAgICAgICAgaWYgKGNyZWF0aW5nSG9vayAhPT0gbm9wIHx8IHVwZGF0aW5nSG9vayAhPT0gbm9wKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBQZW9wbGUgbGlzdGVucyB0byB3aGVuKFwiY3JlYXRpbmdcIikgb3Igd2hlbihcInVwZGF0aW5nXCIpIGV2ZW50cyFcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGtub3cgd2hldGhlciB0aGUgcHV0IG9wZXJhdGlvbiByZXN1bHRzIGluIGFuIENSRUFURSBvciBVUERBVEUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgZWZmZWN0aXZlS2V5ID0gKGtleSAhPT0gdW5kZWZpbmVkKSA/IGtleSA6IChrZXlQYXRoICYmIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0aXZlS2V5ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvYmopO1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGtleSBpcyBvcHRpb25hbCwgbWFrZSBzdXJlIHdlIGdldCBpdCBmcm9tIG9iaiBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBQcmltYXJ5IGtleSBleGlzdC4gTG9jayB0cmFuc2FjdGlvbiBhbmQgdHJ5IG1vZGlmeWluZyBleGlzdGluZy4gSWYgbm90aGluZyBtb2RpZmllZCwgY2FsbCBhZGQoKS5cbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBvYmogYmVmb3JlIHRoaXMgYXN5bmMgY2FsbC4gSWYgY2FsbGVyIG1vZGlmaWVzIG9iaiB0aGUgbGluZSBhZnRlciBwdXQoKSwgdGhlIElEQiBzcGVjIHJlcXVpcmVzIHRoYXQgaXQgc2hvdWxkIG5vdCBhZmZlY3Qgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFucyhSRUFEV1JJVEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhlZmZlY3RpdmVLZXkpLm1vZGlmeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGlzdGluZyB2YWx1ZSB3aXRoIG91ciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENSVUQgZXZlbnQgZmlyaW5nIGhhbmRsZWQgaW4gQ29sbGVjdGlvbi5tb2RpZnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIGNvdW50ID09PSAwID8gX3RoaXMuYWRkKG9iaiwga2V5KSA6IGVmZmVjdGl2ZUtleTsgfSk7XG4gICAgICAgICAgICAgICAgfSwgXCJsb2NrZWRcIik7IC8vIExvY2sgbmVlZGVkIGJlY2F1c2Ugb3BlcmF0aW9uIGlzIHNwbGl0dGVkIGludG8gbW9kaWZ5KCkgYW5kIGFkZCgpLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzdGFuZGFyZCBJREIgcHV0KCkgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZGJzdG9yZShSRUFEV1JJVEUsIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBrZXkgIT09IHVuZGVmaW5lZCA/IGlkYnN0b3JlLnB1dChvYmosIGtleSkgOiBpZGJzdG9yZS5wdXQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGlkYnN0b3JlLmtleVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBldi50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5XCI+UHJpbWFyeSBrZXkgb2YgdGhlIG9iamVjdCB0byBkZWxldGU8L3BhcmFtPlxuICAgICAgICAgICAgaWYgKHRoaXMuaG9vay5kZWxldGluZy5zdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBQZW9wbGUgbGlzdGVucyB0byB3aGVuKFwiZGVsZXRpbmdcIikgZXZlbnQuIE11c3QgaW1wbGVtZW50IGRlbGV0ZSB1c2luZyBDb2xsZWN0aW9uLmRlbGV0ZSgpIHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGNhbGwgdGhlIENSVUQgZXZlbnQuIE9ubHkgQ29sbGVjdGlvbi5kZWxldGUoKSB3aWxsIGtub3cgd2hldGhlciBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkuZGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBvbmUgbGlzdGVucy4gVXNlIHN0YW5kYXJkIElEQiBkZWxldGUoKSBtZXRob2QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkYnN0b3JlKFJFQURXUklURSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGlkYnN0b3JlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvb2suZGVsZXRpbmcuc3Vic2NyaWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gUGVvcGxlIGxpc3RlbnMgdG8gd2hlbihcImRlbGV0aW5nXCIpIGV2ZW50LiBNdXN0IGltcGxlbWVudCBkZWxldGUgdXNpbmcgQ29sbGVjdGlvbi5kZWxldGUoKSB0aGF0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBDUlVEIGV2ZW50LiBPbmx5IENvbGxlY3Rpb24uZGVsZXRlKCkgd2lsbCBrbm93cyB3aGljaCBvYmplY3RzIHRoYXQgYXJlIGFjdHVhbGx5IGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuZGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWRic3RvcmUoUkVBRFdSSVRFLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRic3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWNhdGlvbnMgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkobW9kaWZpY2F0aW9ucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiTW9kaWZpY2F0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShrZXlPck9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QgdG8gbW9kaWZ5LiBBbHNvIG1vZGlmeSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpY2F0aW9uczpcbiAgICAgICAgICAgICAgICBrZXlzKG1vZGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCBrZXlQYXRoLCBtb2RpZmljYXRpb25zW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJHaXZlbiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBpdHMgcHJpbWFyeSBrZXlcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXkpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGtleSB0byBtb2RpZnlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFRyYW5zYWN0aW9uIENsYXNzXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgIC8vLyAgICBUcmFuc2FjdGlvbiBjbGFzcy4gUmVwcmVzZW50cyBhIGRhdGFiYXNlIHRyYW5zYWN0aW9uLiBBbGwgb3BlcmF0aW9ucyBvbiBkYiBnb2VzIHRocm91Z2ggYSBUcmFuc2FjdGlvbi5cbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibW9kZVwiIHR5cGU9XCJTdHJpbmdcIj5Bbnkgb2YgXCJyZWFkd3JpdGVcIiBvciBcInJlYWRvbmx5XCI8L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdG9yZU5hbWVzXCIgdHlwZT1cIkFycmF5XCI+QXJyYXkgb2YgdGFibGUgbmFtZXMgdG8gb3BlcmF0ZSBvbjwvcGFyYW0+XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgICAgdGhpcy5pZGJ0cmFucyA9IG51bGw7XG4gICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuICAgICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWl0aW5nUXVldWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zcGluQ291bnQgPSAwOyAvLyBKdXN0IGZvciBkZWJ1Z2dpbmcgd2FpdEZvcigpXG4gICAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHdhc0FjdGl2ZSA9IF90aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMub24uZXJyb3IuZmlyZShlKTtcbiAgICAgICAgICAgIF90aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Ll9yZWplY3QoZSkgOlxuICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiBfdGhpcy5pZGJ0cmFucyAmJiBfdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTsgLy8gSW5kaWNhdGUgd2UgYWN0dWFsbHkgRE8gTk9UIGNhdGNoIHRoaXMgZXJyb3IuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcyhUcmFuc2FjdGlvbi5wcm90b3R5cGUsIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVHJhbnNhY3Rpb24gUHJvdGVjdGVkIE1ldGhvZHMgKG5vdCByZXF1aXJlZCBieSBBUEkgdXNlcnMsIGJ1dCBuZWVkZWQgaW50ZXJuYWxseSBhbmQgZXZlbnR1YWxseSBieSBkZXhpZSBleHRlbnNpb25zKVxuICAgICAgICAvL1xuICAgICAgICBfbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTsgLy8gTG9ja2luZyBhbmQgdW5sb2NraW5nIHJldWlyZXMgdG8gYmUgd2l0aGluIGEgUFNEIHNjb3BlLlxuICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHNldCBhbGwgcmVxdWVzdHMgaW50byBhIHBlbmRpbmcgcXVldWUgaWYgdGhleSBhcmUgY2FsbGVkIGJlZm9yZSBkYXRhYmFzZSBpcyByZWFkeS5cbiAgICAgICAgICAgICsrdGhpcy5fcmVjdWxvY2s7IC8vIFJlY3Vyc2l2ZSByZWFkL3dyaXRlIGxvY2sgcGF0dGVybiB1c2luZyBQU0QgKFByb21pc2UgU3BlY2lmaWMgRGF0YSkgaW5zdGVhZCBvZiBUTFMgKFRocmVhZCBMb2NhbCBTdG9yYWdlKVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlY3Vsb2NrID09PSAxICYmICFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF91bmxvY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICAgICAgICAgIGlmICgtLXRoaXMuX3JlY3Vsb2NrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlUFNEKGZuQW5kUFNEWzFdLCBmbkFuZFBTRFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfbG9ja2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgYW55IHdyaXRlLWxvY2sgaXMgYXBwbGllZCBvbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgLy8gVG8gc2ltcGxpZnkgdGhlIERleGllIEFQSSBmb3IgZXh0ZW5zaW9uIGltcGxlbWVudGF0aW9ucywgd2Ugc3VwcG9ydCByZWN1cnNpdmUgbG9ja3MuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSB1c2luZyBcIlByb21pc2UgU3BlY2lmaWMgRGF0YVwiIChQU0QpLlxuICAgICAgICAgICAgLy8gUFNEIGRhdGEgaXMgYm91bmQgdG8gYSBQcm9taXNlIGFuZCBhbnkgY2hpbGQgUHJvbWlzZSBlbWl0dGVkIHRocm91Z2ggdGhlbigpIG9yIHJlc29sdmUoIG5ldyBQcm9taXNlKCkgKS5cbiAgICAgICAgICAgIC8vIFBTRCBpcyBsb2NhbCB0byBjb2RlIGV4ZWN1dGluZyBvbiB0b3Agb2YgdGhlIGNhbGwgc3RhY2tzIG9mIGFueSBvZiBhbnkgY29kZSBleGVjdXRlZCBieSBQcm9taXNlKCk6XG4gICAgICAgICAgICAvLyAgICAgICAgICogY2FsbGJhY2sgZ2l2ZW4gdG8gdGhlIFByb21pc2UoKSBjb25zdHJ1Y3RvciAgKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3Qpey4uLn0pXG4gICAgICAgICAgICAvLyAgICAgICAgICogY2FsbGJhY2tzIGdpdmVuIHRvIHRoZW4oKS9jYXRjaCgpL2ZpbmFsbHkoKSBtZXRob2RzIChmdW5jdGlvbiAodmFsdWUpey4uLn0pXG4gICAgICAgICAgICAvLyBJZiBjcmVhdGluZyBhIG5ldyBpbmRlcGVuZGFudCBQcm9taXNlIGluc3RhbmNlIGZyb20gd2l0aGluIGEgUHJvbWlzZSBjYWxsIHN0YWNrLCB0aGUgbmV3IFByb21pc2Ugd2lsbCBkZXJpdmUgdGhlIFBTRCBmcm9tIHRoZSBjYWxsIHN0YWNrIG9mIHRoZSBwYXJlbnQgUHJvbWlzZS5cbiAgICAgICAgICAgIC8vIERlcml2YXRpb24gaXMgZG9uZSBzbyB0aGF0IHRoZSBpbm5lciBQU0QgX19wcm90b19fIHBvaW50cyB0byB0aGUgb3V0ZXIgUFNELlxuICAgICAgICAgICAgLy8gUFNELmxvY2tPd25lckZvciB3aWxsIHBvaW50IHRvIGN1cnJlbnQgdHJhbnNhY3Rpb24gb2JqZWN0IGlmIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIFBTRCBzY29wZSBvd25zIHRoZSBsb2NrLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Vsb2NrICYmIFBTRC5sb2NrT3duZXJGb3IgIT09IHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGlkYnRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuICAgICAgICAgICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRiT3BlbkVycm9yICYmIGRiT3BlbkVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9ycyB3aGVyZSBpdCBpcyBubyBkaWZmZXJlbmNlIHdoZXRoZXIgaXQgd2FzIGNhdXNlZCBieSB0aGUgdXNlciBvcGVyYXRpb24gb3IgYW4gZWFybGllciBjYWxsIHRvIGRiLm9wZW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvcnMgd2hlcmUgaXQgaXMgbm8gZGlmZmVyZW5jZSB3aGV0aGVyIGl0IHdhcyBjYXVzZWQgYnkgdGhlIHVzZXIgb3BlcmF0aW9uIG9yIGFuIGVhcmxpZXIgY2FsbCB0byBkYi5vcGVuKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoZGJPcGVuRXJyb3IubWVzc2FnZSwgZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBpdCBjbGVhciB0aGF0IHRoZSB1c2VyIG9wZXJhdGlvbiB3YXMgbm90IHdoYXQgY2F1c2VkIHRoZSBlcnJvciAtIHRoZSBlcnJvciBoYWQgb2NjdXJyZWQgZWFybGllciBvbiBkYi5vcGVuKCkhXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5PcGVuRmFpbGVkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLl9jb21wbGV0aW9uLl9zdGF0ZSA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZGJ0cmFucyA9IHRoaXMuaWRidHJhbnMgPSBpZGJ0cmFucyB8fCBpZGJkYi50cmFuc2FjdGlvbihzYWZhcmlNdWx0aVN0b3JlRml4KHRoaXMuc3RvcmVOYW1lcyksIHRoaXMubW9kZSk7XG4gICAgICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7IC8vIFByb2hpYml0IGRlZmF1bHQgYnViYmxpbmcgdG8gd2luZG93LmVycm9yXG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdChpZGJ0cmFucy5lcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgJiYgX3RoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYnRyYW5zLm9uY29tcGxldGUgPSB3cmFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3Byb21pc2U6IGZ1bmN0aW9uIChtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBSRUFEV1JJVEUgJiYgdGhpcy5tb2RlICE9PSBSRUFEV1JJVEUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcC5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91bmxvY2soKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfcm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgb3BlcmF0ZSBvbiB0aGUgcm9vdCB0cmFuc2FjdGlvbiAoaW4gY2FzZSB0aGlzIGlzIGEgc3ViIHN0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdCgpO1xuICAgICAgICAgICAgLy8gRm9yIHN0YWJpbGl0eSByZWFzb25zLCBjb252ZXJ0IHBhcmFtZXRlciB0byBwcm9taXNlIG5vIG1hdHRlciB3aGF0IHR5cGUgaXMgcGFzc2VkIHRvIHdhaXRGb3IoKS5cbiAgICAgICAgICAgIC8vIChXZSBtdXN0IGJlIGFibGUgdG8gY2FsbCAudGhlbigpIG9uIGl0LilcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgY2FsbGVkIHdhaXRGb3IoKS4gV2FpdCBmb3IgYm90aCB0byBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb21pc2U7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgbm90IGluIHdhaXRpbmcgc3RhdGUuIFN0YXJ0IHdhaXRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgaW50ZXJhY3Rpbmcgd2l0aCBpbmRleGVkREIgdW50aWwgcHJvbWlzZSBjb21wbGV0ZXM6XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICAgICAgICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDsgLy8gRm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldCgtSW5maW5pdHkpLm9uc3VjY2VzcyA9IHNwaW47XG4gICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50V2FpdFByb21pc2UgPSByb290Ll93YWl0aW5nRm9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByb290Ll93YWl0aW5nUXVldWUucHVzaCh3cmFwKHJlamVjdC5iaW5kKG51bGwsIGVycikpKTsgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG9uZSBhZGRlZCBhIHdhaXQgYWZ0ZXIgdXMuIFNhZmUgdG8gc3RvcCB0aGUgc3Bpbm5pbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRyYW5zYWN0aW9uIFB1YmxpYyBQcm9wZXJ0aWVzIGFuZCBNZXRob2RzXG4gICAgICAgIC8vXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSAmJiB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICB0YWJsZXM6IHtcbiAgICAgICAgICAgIGdldDogZGVwcmVjYXRlZChcIlRyYW5zYWN0aW9uLnRhYmxlc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxUYWJsZXM7IH0pXG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gZGIudGFibGUobmFtZSk7IC8vIERvbid0IGNoZWNrIHRoYXQgdGFibGUgaXMgcGFydCBvZiB0cmFuc2FjdGlvbi4gSXQgbXVzdCBmYWlsIGxhemlseSFcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGUobmFtZSwgdGFibGUuc2NoZW1hLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFdoZXJlQ2xhdXNlXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGFibGUsIGluZGV4LCBvckNvbGxlY3Rpb24pIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGFibGVcIiB0eXBlPVwiVGFibGVcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvckNvbGxlY3Rpb25cIiB0eXBlPVwiQ29sbGVjdGlvblwiIG9wdGlvbmFsPVwidHJ1ZVwiPjwvcGFyYW0+XG4gICAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcbiAgICAgICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvcHMoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdoZXJlQ2xhdXNlIHByaXZhdGUgbWV0aG9kc1xuICAgICAgICBmdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UgaW5zdGFuY2VvZiBXaGVyZUNsYXVzZSA/XG4gICAgICAgICAgICAgICAgbmV3IENvbGxlY3Rpb24oY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uX2N0eC5lcnJvciA9IFQgPyBuZXcgVChlcnIpIDogbmV3IFR5cGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoXCJcIik7IH0pLmxpbWl0KDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID8gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9VcHBlckNhc2UoKTsgfSA6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvTG93ZXJDYXNlKCk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG93ZXJGYWN0b3J5KGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b0xvd2VyQ2FzZSgpOyB9IDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9VcHBlckNhc2UoKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihrZXkubGVuZ3RoLCBsb3dlck5lZWRsZS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGxscCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsd3JLZXlDaGFyID0gbG93ZXJLZXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyB1cHBlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsbHAgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgbGxwID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IGtleS5sZW5ndGggJiYgZGlyID09PSBcInByZXZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5lZWRsZXNcIiB0eXBlPVwiQXJyYXlcIiBlbGVtZW50VHlwZT1cIlN0cmluZ1wiPjwvcGFyYW0+XG4gICAgICAgICAgICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LCBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIW5lZWRsZXMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJzsgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgICAgICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpIH07XG4gICAgICAgICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuICAgICAgICAgICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlyO1xuICAgICAgICAgICAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdERpcmVjdGlvbihcIm5leHRcIik7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKHVwcGVyTmVlZGxlc1swXSwgbG93ZXJOZWVkbGVzW25lZWRsZXNMZW4gLSAxXSArIHN1ZmZpeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXZlbnQgb25seXMgb2NjdXIgYmVmb3JlIGZpbHRlciBpcyBjYWxsZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICAgICAgICAgaW5pdERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcbiAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY3Vyc29yXCIgdHlwZT1cIklEQkN1cnNvclwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWR2YW5jZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzb2x2ZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQb3NzaWJsZU5lZWRsZTsgaSA8IG5lZWRsZXNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FzaW5nID09PSBudWxsICYmIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UG9zc2libGVOZWVkbGUgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBjYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICsgbmV4dEtleVN1ZmZpeCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBXaGVyZUNsYXVzZSBwdWJsaWMgbWV0aG9kc1xuICAgICAgICAvL1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmV0d2VlbjogZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVkZUxvd2VyLCBpbmNsdWRlVXBwZXIpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgICAgICAgICAgLy8vICAgICBGaWx0ZXIgb3V0IHJlY29yZHMgd2hvc2Ugd2hlcmUtZmllbGQgbGF5cyBiZXR3ZWVuIGdpdmVuIGxvd2VyIGFuZCB1cHBlciB2YWx1ZXMuIEFwcGxpZXMgdG8gU3RyaW5ncywgTnVtYmVycyBhbmQgRGF0ZXMuXG4gICAgICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb3dlclwiPjwvcGFyYW0+XG4gICAgICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidXBwZXJcIj48L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluY2x1ZGVMb3dlclwiIG9wdGlvbmFsPVwidHJ1ZVwiPldoZXRoZXIgaXRlbXMgdGhhdCBlcXVhbHMgbG93ZXIgc2hvdWxkIGJlIGluY2x1ZGVkLiBEZWZhdWx0IHRydWUuPC9wYXJhbT5cbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmNsdWRlVXBwZXJcIiBvcHRpb25hbD1cInRydWVcIj5XaGV0aGVyIGl0ZW1zIHRoYXQgZXF1YWxzIHVwcGVyIHNob3VsZCBiZSBpbmNsdWRlZC4gRGVmYXVsdCBmYWxzZS48L3BhcmFtPlxuICAgICAgICAgICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwiQ29sbGVjdGlvblwiPjwvcmV0dXJucz5cbiAgICAgICAgICAgICAgICBpbmNsdWRlTG93ZXIgPSBpbmNsdWRlTG93ZXIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7IC8vIERlZmF1bHQgdG8gZmFsc2VcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNtcChsb3dlciwgdXBwZXIpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpOyAvLyBXb3JrYXJvdW5kIGZvciBpZGlvdGljIFczQyBTcGVjaWZpY2F0aW9uIHRoYXQgRGF0YUVycm9yIG11c3QgYmUgdGhyb3duIGlmIGxvd2VyID4gdXBwZXIuIFRoZSBuYXR1cmFsIHJlc3VsdCB3b3VsZCBiZSB0byByZXR1cm4gYW4gZW1wdHkgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLm9ubHkodmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYm92ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQodmFsdWUsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYm92ZU9yRXF1YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBJREJLZXlSYW5nZS5sb3dlckJvdW5kKHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVsb3c6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKHZhbHVlLCB0cnVlKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVsb3dPckVxdWFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gSURCS2V5UmFuZ2UudXBwZXJCb3VuZCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdHJcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhcnRzV2l0aElnbm9yZUNhc2U6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdHJcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgZnVuY3Rpb24gKHgsIGEpIHsgcmV0dXJuIHguaW5kZXhPZihhWzBdKSA9PT0gMDsgfSwgW3N0cl0sIG1heFN0cmluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXF1YWxzSWdub3JlQ2FzZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0clwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsIGZ1bmN0aW9uICh4LCBhKSB7IHJldHVybiB4ID09PSBhWzBdOyB9LCBbc3RyXSwgXCJcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW55T2ZJZ25vcmVDYXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkgeyByZXR1cm4gYS5pbmRleE9mKHgpICE9PSAtMTsgfSwgc2V0LCBcIlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCBmdW5jdGlvbiAoeCwgYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5pbmRleE9mKG4pID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBzZXQsIG1heFN0cmluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW55T2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENvbGxlY3Rpb24odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gSURCS2V5UmFuZ2UuYm91bmQoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKTsgfSk7XG4gICAgICAgICAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/IGFzY2VuZGluZyA6IGRlc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnNvciBoYXMgcGFzc2VkIGJleW9uZCB0aGlzIGtleS4gQ2hlY2sgbmV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvci5rZXkgbm90IHlldCBhdCBzZXRbaV0uIEZvcndhcmQgY3Vyc29yIHRvIHRoZSBuZXh0IGtleSB0byBodW50IGZvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUoc2V0W2ldKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3RFcXVhbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIG1heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub25lT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7IC8vIFJldHVybiBlbnRpcmUgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXQuc29ydChhc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBbXCJhXCIsXCJiXCIsXCJjXCJdIHRvIGEgc2V0IG9mIHJhbmdlcyBmb3IgYmV0d2Vlbi9hYm92ZS9iZWxvdzogW1ttaW5LZXksXCJhXCJdLCBbXCJhXCIsXCJiXCJdLCBbXCJiXCIsXCJjXCJdLCBbXCJjXCIsbWF4S2V5XV1cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gc2V0LnJlZHVjZShmdW5jdGlvbiAocmVzLCB2YWwpIHsgcmV0dXJuIHJlcyA/IHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOiBbW21pbktleSwgdmFsXV07IH0sIG51bGwpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCBtYXhLZXldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIEZpbHRlciBvdXQgdmFsdWVzIHdpdGhpbmcgZ2l2ZW4gc2V0IG9mIHJhbmdlcy5cbiAgICAgICAgICAgICogRXhhbXBsZSwgZ2l2ZSBjaGlsZHJlbiBhbmQgZWxkZXJzIGEgcmViYXRlIG9mIDUwJTpcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogICBkYi5mcmllbmRzLndoZXJlKCdhZ2UnKS5pbkFueVJhbmdlKFtbMCwxOF0sWzY1LEluZmluaXR5XV0pLm1vZGlmeSh7UmViYXRlOiAxLzJ9KTtcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxEYXRlfEFycmF5KVtdW119IHJhbmdlc1xuICAgICAgICAgICAgKiBAcGFyYW0ge3tpbmNsdWRlTG93ZXJzOiBib29sZWFuLCBpbmNsdWRlVXBwZXJzOiBib29sZWFufX0gb3B0aW9uc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluQW55UmFuZ2U6IGZ1bmN0aW9uIChyYW5nZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcy5ldmVyeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiYgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJiBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcIkZpcnN0IGFyZ3VtZW50IHRvIGluQW55UmFuZ2UoKSBtdXN0IGJlIGFuIEFycmF5IG9mIHR3by12YWx1ZSBBcnJheXMgW2xvd2VyLHVwcGVyXSB3aGVyZSB1cHBlciBtdXN0IG5vdCBiZSBsb3dlciB0aGFuIGxvd2VyXCIsIGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZVVwcGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlVXBwZXJzID09PSB0cnVlOyAvLyBEZWZhdWx0IHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkUmFuZ2UocmFuZ2VzLCBuZXdSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG4gICAgICAgICAgICAgICAgLy8gSm9pbiBvdmVybGFwcGluZyByYW5nZXNcbiAgICAgICAgICAgICAgICB2YXIgc2V0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHJhbmdlcy5yZWR1Y2UoYWRkUmFuZ2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGtleUlzQmV5b25kQ3VycmVudEVudHJ5ID0gaW5jbHVkZVVwcGVycyA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFzY2VuZGluZyhrZXksIHNldFtpXVsxXSkgPiAwOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYXNjZW5kaW5nKGtleSwgc2V0W2ldWzFdKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIHZhciBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W2ldWzBdKSA+IDA7IH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZXNjZW5kaW5nKGtleSwgc2V0W2ldWzBdKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKHNldFswXVswXSwgc2V0W3NldC5sZW5ndGggLSAxXVsxXSwgIWluY2x1ZGVMb3dlcnMsICFpbmNsdWRlVXBwZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnNvciBoYXMgcGFzc2VkIGJleW9uZCB0aGlzIGtleS4gQ2hlY2sgbmV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjbXAoa2V5LCBzZXRbaV1bMV0pID09PSAwIHx8IGNtcChrZXksIHNldFtpXVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGVVcHBlciBvciBpbmNsdWRlTG93ZXIgaXMgZmFsc2Ugc28ga2V5V2l0aGluQ3VycmVudFJhbmdlKCkgcmV0dXJucyBmYWxzZSBldmVuIHRob3VnaCB3ZSBhcmUgYXQgcmFuZ2UgYm9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBrZXkgYnV0IGRvbid0IGluY2x1ZGUgdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJzb3Iua2V5IG5vdCB5ZXQgYXQgc2V0W2ldLiBGb3J3YXJkIGN1cnNvciB0byB0aGUgbmV4dCBrZXkgdG8gaHVudCBmb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydHNXaXRoQW55T2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICghc2V0LmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyBDb2xsZWN0aW9uIENsYXNzXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwga2V5UmFuZ2VHZW5lcmF0b3IpIHtcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxuICAgICAgICAvLy9cbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2hlcmVDbGF1c2VcIiB0eXBlPVwiV2hlcmVDbGF1c2VcIj5XaGVyZSBjbGF1c2UgaW5zdGFuY2U8L3BhcmFtPlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlSYW5nZUdlbmVyYXRvclwiIHZhbHVlPVwiZnVuY3Rpb24oKXsgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKDAsMSk7fVwiIG9wdGlvbmFsPVwidHJ1ZVwiPjwvcGFyYW0+XG4gICAgICAgIHZhciBrZXlSYW5nZSA9IG51bGwsIGVycm9yID0gbnVsbDtcbiAgICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB2YXIgd2hlcmVDdHggPSB3aGVyZUNsYXVzZS5fY3R4LCB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG4gICAgICAgICAgICBpc1ByaW1LZXk6ICghd2hlcmVDdHguaW5kZXggfHwgKHRhYmxlLnNjaGVtYS5wcmltS2V5LmtleVBhdGggJiYgd2hlcmVDdHguaW5kZXggPT09IHRhYmxlLnNjaGVtYS5wcmltS2V5Lm5hbWUpKSxcbiAgICAgICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAgICAgIGtleXNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcjogXCJuZXh0XCIsXG4gICAgICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgICAgICBhbGdvcml0aG06IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICBqdXN0TGltaXQ6IHRydWUsXG4gICAgICAgICAgICBpc01hdGNoOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuICAgICAgICAgICAgdmFsdWVNYXBwZXI6IHRhYmxlLmhvb2sucmVhZGluZy5maXJlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZShjdHgsIGlnbm9yZUxpbWl0RmlsdGVyKSB7XG4gICAgICAgIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAgICAgICAoaWdub3JlTGltaXRGaWx0ZXIgPyBjdHguanVzdExpbWl0IDogIWN0eC5yZXBsYXlGaWx0ZXIpO1xuICAgIH1cbiAgICBwcm9wcyhDb2xsZWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBDb2xsZWN0aW9uIFByaXZhdGUgRnVuY3Rpb25zXG4gICAgICAgIC8vXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZpbHRlcihjdHgsIGZuKSB7XG4gICAgICAgICAgICBjdHguZmlsdGVyID0gY29tYmluZShjdHguZmlsdGVyLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyKGN0eCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSBjdHgucmVwbGF5RmlsdGVyO1xuICAgICAgICAgICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKTsgfSA6IGZhY3Rvcnk7XG4gICAgICAgICAgICBjdHguanVzdExpbWl0ID0gaXNMaW1pdEZpbHRlciAmJiAhY3VycjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG4gICAgICAgICAgICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHBhcmFtIGN0eCB7XG4gICAgICAgICAqICAgICAgaXNQcmltS2V5OiBib29sZWFuLFxuICAgICAgICAgKiAgICAgIHRhYmxlOiBUYWJsZSxcbiAgICAgICAgICogICAgICBpbmRleDogc3RyaW5nXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQHBhcmFtIHN0b3JlIElEQk9iamVjdFN0b3JlXG4gICAgICAgICAqKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0SW5kZXhPclN0b3JlKGN0eCwgc3RvcmUpIHtcbiAgICAgICAgICAgIGlmIChjdHguaXNQcmltS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZTtcbiAgICAgICAgICAgIHZhciBpbmRleFNwZWMgPSBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpbmRleFNwZWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIHN0b3JlLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5pbmRleChpbmRleFNwZWMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBwYXJhbSBjdHgge1xuICAgICAgICAgKiAgICAgIGlzUHJpbUtleTogYm9vbGVhbixcbiAgICAgICAgICogICAgICB0YWJsZTogVGFibGUsXG4gICAgICAgICAqICAgICAgaW5kZXg6IHN0cmluZyxcbiAgICAgICAgICogICAgICBrZXlzT25seTogYm9vbGVhbixcbiAgICAgICAgICogICAgICByYW5nZT86IElEQktleVJhbmdlLFxuICAgICAgICAgKiAgICAgIGRpcjogXCJuZXh0XCIgfCBcInByZXZcIlxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eCwgc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBpZHhPclN0b3JlID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgc3RvcmUpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5rZXlzT25seSAmJiAnb3BlbktleUN1cnNvcicgaW4gaWR4T3JTdG9yZSA/XG4gICAgICAgICAgICAgICAgaWR4T3JTdG9yZS5vcGVuS2V5Q3Vyc29yKGN0eC5yYW5nZSB8fCBudWxsLCBjdHguZGlyICsgY3R4LnVuaXF1ZSkgOlxuICAgICAgICAgICAgICAgIGlkeE9yU3RvcmUub3BlbkN1cnNvcihjdHgucmFuZ2UgfHwgbnVsbCwgY3R4LmRpciArIGN0eC51bmlxdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXIoY3R4LCBmbiwgcmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICAgICAgICAgICAgaWYgKCFjdHgub3IpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBpZGJzdG9yZSksIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sIHJlc29sdmUsIHJlamVjdCwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZWJvdGgoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytyZXNvbHZlZCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7IC8vIFNlZW1zIGxpa2Ugd2UganVzdCBzdXBwb3J0IG9yIGJ0d24gbWF4IDIgZXhwcmVzc2lvbnMsIGJ1dCB0aGVyZSBhcmUgbm8gbGltaXQgYmVjYXVzZSB3ZSBkbyByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5pb24oaXRlbSwgY3Vyc29yLCBhZHZhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlYm90aCwgcmVqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duKHNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgcmVzb2x2ZWJvdGgsIHJlamVjdCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBpZGJzdG9yZSksIGN0eC5hbGdvcml0aG0sIHVuaW9uLCByZXNvbHZlYm90aCwgcmVqZWN0LCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcik7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENvbGxlY3Rpb24gUHJvdGVjdGVkIEZ1bmN0aW9uc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIF9yZWFkOiBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICAgICAgICAgICAgICAgIGN0eC50YWJsZS5faWRic3RvcmUoUkVBRE9OTFksIGZuKS50aGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfd3JpdGU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgICAgICAgICBjdHgudGFibGUuX2lkYnN0b3JlKFJFQURXUklURSwgZm4sIFwibG9ja2VkXCIpOyAvLyBXaGVuIGRvaW5nIHdyaXRlIG9wZXJhdGlvbnMgb24gY29sbGVjdGlvbnMsIGFsd2F5cyBsb2NrIHRoZSBvcGVyYXRpb24gc28gdGhhdCB1cGNvbWluZyBvcGVyYXRpb25zIGdldHMgcXVldWVkLlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hZGRBbGdvcml0aG06IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgY3R4LmFsZ29yaXRobSA9IGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZm4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pdGVyYXRlOiBmdW5jdGlvbiAoZm4sIHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCByZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKHByb3BzJCQxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksIGN0eCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMkJDEpXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChjdHgsIHByb3BzJCQxKTtcbiAgICAgICAgICAgICAgICBydi5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBDb2xsZWN0aW9uIFB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyKGN0eCwgZm4sIHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvdW50OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcGxhaW4ga2V5IHJhbmdlLiBXZSBjYW4gdXNlIHRoZSBjb3VudCgpIG1ldGhvZCBpZiB0aGUgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IChjdHgucmFuZ2UgPyBpZHguY291bnQoY3R4LnJhbmdlKSA6IGlkeC5jb3VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKE1hdGgubWluKGUudGFyZ2V0LnJlc3VsdCwgY3R4LmxpbWl0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGdvcml0aG1zLCBmaWx0ZXJzIG9yIGV4cHJlc3Npb25zIGFyZSBhcHBsaWVkLiBOZWVkIHRvIGNvdW50IG1hbnVhbGx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcihjdHgsIGZ1bmN0aW9uICgpIHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCBmdW5jdGlvbiAoKSB7IHJlc29sdmUoY291bnQpOyB9LCByZWplY3QsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0Qnk6IGZ1bmN0aW9uIChrZXlQYXRoLCBjYikge1xuICAgICAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImtleVBhdGhcIiB0eXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXlQYXRoLnNwbGl0KCcuJykucmV2ZXJzZSgpLCBsYXN0UGFydCA9IHBhcnRzWzBdLCBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtsYXN0UGFydF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvcmRlciA9IHRoaXMuX2N0eC5kaXIgPT09IFwibmV4dFwiID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFWYWwgPCBiVmFsID8gLW9yZGVyIDogYVZhbCA+IGJWYWwgPyBvcmRlciA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCAmJiBjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBvcHRpbWF0aW9uIGlmIHdlIGNvdWxkIHVzZSBJREJPYmplY3RTdG9yZS5nZXRBbGwoKSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGluZ0hvb2sgPSBjdHgudGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4T3JTdG9yZSA9IGdldEluZGV4T3JTdG9yZShjdHgsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBjdHgubGltaXQgPCBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4T3JTdG9yZS5nZXRBbGwoY3R4LnJhbmdlLCBjdHgubGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhPclN0b3JlLmdldEFsbChjdHgucmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSByZWFkaW5nSG9vayA9PT0gbWlycm9yID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN1Y2Nlc3NIYW5kbGVyKHJlc29sdmUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN1Y2Nlc3NIYW5kbGVyKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzLm1hcChyZWFkaW5nSG9vaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgYXJyYXkgdGhyb3VnaCBhIGN1cnNvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyKGN0eCwgZnVuY3Rpb24gKGl0ZW0pIHsgYS5wdXNoKGl0ZW0pOyB9LCBmdW5jdGlvbiBhcnJheUNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QsIGlkYnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgY3R4Lm9mZnNldCArPSBvZmZzZXQ7IC8vIEZvciBjb3VudCgpXG4gICAgICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAoLS1vZmZzZXRMZWZ0IDwgMCk7IH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW1pdDogZnVuY3Rpb24gKG51bVJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpOyAvLyBGb3IgY291bnQoKVxuICAgICAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3NMZWZ0ID0gbnVtUm93cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTsgLy8gU3RvcCBhZnRlciB0aGlzIGl0ZW0gaGFzIGJlZW4gaW5jbHVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3dzTGVmdCA+PSAwOyAvLyBJZiBudW1Sb3dzIGlzIGFscmVhZHkgYmVsb3cgMCwgcmV0dXJuIGZhbHNlIGJlY2F1c2UgdGhlbiAwIHdhcyBwYXNzZWQgdG8gbnVtUm93cyBpbml0aWFsbHkuIE90aGVyd2lzZSB3ZSB3b3VsZG50IGNvbWUgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnRpbDogZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uLCBiSW5jbHVkZVN0b3BFbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiSW5jbHVkZVN0b3BFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJqc0Z1bmN0aW9uRmlsdGVyXCIgdHlwZT1cIkZ1bmN0aW9uXCI+ZnVuY3Rpb24odmFsKXtyZXR1cm4gdHJ1ZS9mYWxzZX08L3BhcmFtPlxuICAgICAgICAgICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gbWF0Y2ggZmlsdGVycyBub3QgdXNlZCBpbiBEZXhpZS5qcyBidXQgY2FuIGJlIHVzZWQgYnkgM3JkIHBhcnQgbGlicmFyaWVzIHRvIHRlc3QgYVxuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24gZm9yIGEgbWF0Y2ggd2l0aG91dCBxdWVyeWluZyBEQi4gVXNlZCBieSBEZXhpZS5PYnNlcnZhYmxlLlxuICAgICAgICAgICAgICAgIGFkZE1hdGNoRmlsdGVyKHRoaXMuX2N0eCwgZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuZDogZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcjogZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXNjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVhY2hLZXk6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5rZXksIGN1cnNvcik7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVhY2hVbmlxdWVLZXk6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2hLZXkoY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVhY2hQcmltYXJ5S2V5OiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yKTsgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5czogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5rZXkpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmltYXJ5S2V5czogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzR2V0QWxsICYmIGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgb3B0aW1hdGlvbiBpZiB3ZSBjb3VsZCB1c2UgSURCT2JqZWN0U3RvcmUuZ2V0QWxsS2V5cygpIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIElEQktleVJhbmdlLmdldEFsbEtleXMoKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHhPclN0b3JlID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgaWRic3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IGN0eC5saW1pdCA8IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhPclN0b3JlLmdldEFsbEtleXMoY3R4LnJhbmdlLCBjdHgubGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhPclN0b3JlLmdldEFsbEtleXMoY3R4LnJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnRTdWNjZXNzSGFuZGxlcihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmlxdWVLZXlzOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXJzdEtleTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkua2V5cyhmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdEtleTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0S2V5KGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXN0aW5jdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIGlkeCA9IGN0eC5pbmRleCAmJiBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghaWR4IHx8ICFpZHgubXVsdGkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBkaXN0aW5jdCgpIG9ubHkgbWFrZXMgZGlmZmVyZW5jaWVzIG9uIG11bHRpRW50cnkgaW5kZXhlcy5cbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0ge307XG4gICAgICAgICAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTsgLy8gQ29udmVydHMgYW55IERhdGUgdG8gU3RyaW5nLCBTdHJpbmcgdG8gU3RyaW5nLCBOdW1iZXIgdG8gU3RyaW5nIGFuZCBBcnJheSB0byBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFtzdHJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTWV0aG9kcyB0aGF0IG11dGF0ZSBzdG9yYWdlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbW9kaWZ5OiBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgY3R4ID0gdGhpcy5fY3R4LCBob29rID0gY3R4LnRhYmxlLmhvb2ssIHVwZGF0aW5nSG9vayA9IGhvb2sudXBkYXRpbmcuZmlyZSwgZGVsZXRpbmdIb29rID0gaG9vay5kZWxldGluZy5maXJlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBpZGJzdG9yZSwgdHJhbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmeWVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZXMgaXMgYSBmdW5jdGlvbiB0aGF0IG1heSB1cGRhdGUsIGFkZCBvciBkZWxldGUgcHJvcHRlcnRpZXMgb3IgZXZlbiByZXF1aXJlIGEgZGVsZXRpb24gdGhlIG9iamVjdCBpdHNlbGYgKGRlbGV0ZSB0aGlzLml0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRpbmdIb29rID09PSBub3AgJiYgZGVsZXRpbmdIb29rID09PSBub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb29uZSBjYXJlcyBhYm91dCB3aGF0IGlzIGJlaW5nIGNoYW5nZWQuIEp1c3QgbGV0IHRoZSBtb2RpZmllciBmdW5jdGlvbiBiZSB0aGUgZ2l2ZW4gYXJndW1lbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVvcGxlIHdhbnQgdG8ga25vdyBleGFjdGx5IHdoYXQgaXMgYmVpbmcgbW9kaWZpZWQgb3IgZGVsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQgbW9kaWZ5ZXIgYmUgYSBwcm94eSBmdW5jdGlvbiB0aGF0IGZpbmRzIG91dCB3aGF0IGNoYW5nZXMgdGhlIGNhbGxlciBpcyBhY3R1YWxseSBkb2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjYWxsIHRoZSBob29rcyBhY2NvcmRpbmdseSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnSXRlbSA9IGRlZXBDbG9uZShpdGVtKTsgLy8gQ2xvbmUgdGhlIGl0ZW0gZmlyc3Qgc28gd2UgY2FuIGNvbXBhcmUgbGF0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcy5jYWxsKHRoaXMsIGl0ZW0sIHRoaXMpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gQ2FsbCB0aGUgcmVhbCBtb2RpZnllciBmdW5jdGlvbiAoSWYgaXQgcmV0dXJucyBmYWxzZSBleHBsaWNpdGVseSwgaXQgbWVhbnMgaXQgZG9udCB3YW50IHRvIG1vZGlmeSBhbnl0aW5nIG9uIHRoaXMgb2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc093bih0aGlzLCBcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhbCBtb2RpZnllciBmdW5jdGlvbiByZXF1ZXN0cyBhIGRlbGV0aW9uIG9mIHRoZSBvYmplY3QuIEluZm9ybSB0aGUgZGVsZXRpbmdIb29rIHRoYXQgYSBkZWxldGlvbiBpcyB0YWtpbmcgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGluZ0hvb2suY2FsbCh0aGlzLCB0aGlzLnByaW1LZXksIGl0ZW0sIHRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGRlbGV0aW9uLiBDaGVjayB3aGF0IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYob3JpZ0l0ZW0sIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxDaGFuZ2VzID0gdXBkYXRpbmdIb29rLmNhbGwodGhpcywgb2JqZWN0RGlmZiwgdGhpcy5wcmltS2V5LCBvcmlnSXRlbSwgdHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9vayB3YW50IHRvIGFwcGx5IGFkZGl0aW9uYWwgbW9kaWZpY2F0aW9ucy4gTWFrZSBzdXJlIHRvIGZ1bGxmaWxsIHRoZSB3aWxsIG9mIHRoZSBob29rLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMoYWRkaXRpb25hbENoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIGFkZGl0aW9uYWxDaGFuZ2VzW2tleVBhdGhdKTsgLy8gQWRkaW5nIHtrZXlQYXRoOiB1bmRlZmluZWR9IG1lYW5zIHRoYXQgdGhlIGtleVBhdGggc2hvdWxkIGJlIGRlbGV0ZWQuIEhhbmRsZWQgYnkgc2V0QnlLZXlQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0aW5nSG9vayA9PT0gbm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGlzIGEgc2V0IG9mIHtrZXlQYXRoOiB2YWx1ZX0gYW5kIG5vIG9uZSBpcyBsaXN0ZW5pbmcgdG8gdGhlIHVwZGF0aW5nIGhvb2suXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUtleXMgPSBrZXlQYXRocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGtleVBhdGhzW2ldLCB2YWwgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoLCB2YWwpOyAvLyBBZGRpbmcge2tleVBhdGg6IHVuZGVmaW5lZH0gbWVhbnMgdGhhdCB0aGUga2V5UGF0aCBzaG91bGQgYmUgZGVsZXRlZC4gSGFuZGxlZCBieSBzZXRCeUtleVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbnl0aGluZ01vZGlmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgaXMgYSBzZXQgb2Yge2tleVBhdGg6IHZhbHVlfSBhbmQgcGVvcGxlIGFyZSBsaXN0ZW5pbmcgdG8gdGhlIHVwZGF0aW5nIGhvb2sgc28gd2UgbmVlZCB0byBjYWxsIGl0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgaXQgdG8gYWRkIGFkZGl0aW9uYWwgbW9kaWZpY2F0aW9ucyB0byBtYWtlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdDaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBzaGFsbG93Q2xvbmUob3JpZ0NoYW5nZXMpOyAvLyBMZXQncyB3b3JrIHdpdGggYSBjbG9uZSBvZiB0aGUgY2hhbmdlcyBrZXlQYXRoL3ZhbHVlIHNldCBzbyB0aGF0IHdlIGNhbiByZXN0b3JlIGl0IGluIGNhc2UgYSBob29rIGV4dGVuZHMgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbENoYW5nZXMgPSB1cGRhdGluZ0hvb2suY2FsbCh0aGlzLCBjaGFuZ2VzLCB0aGlzLnByaW1LZXksIGRlZXBDbG9uZShpdGVtKSwgdHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKGNoYW5nZXMsIGFkZGl0aW9uYWxDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzKGNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCkgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHNoYWxsb3dDbG9uZShvcmlnQ2hhbmdlcyk7IC8vIFJlc3RvcmUgb3JpZ2luYWwgY2hhbmdlcyBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWxLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbW9kaWZ5SXRlbShpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltS2V5OiBjdXJzb3IucHJpbWFyeUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbnN1Y2Nlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uZXJyb3IoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbEtleXMucHVzaCh0aGlzQ29udGV4dC5wcmltS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENhdGNoIHRoZXNlIGVycm9ycyBhbmQgbGV0IGEgZmluYWwgcmVqZWN0aW9uIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byBhYm9ydCBlbnRpcmUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnllci5jYWxsKHRoaXNDb250ZXh0LCBpdGVtLCB0aGlzQ29udGV4dCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJEZWxldGUgPSAhaGFzT3duKHRoaXNDb250ZXh0LCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gKGJEZWxldGUgPyBjdXJzb3IuZGVsZXRlKCkgOiBjdXJzb3IudXBkYXRlKHRoaXNDb250ZXh0LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5faG9va0N0eCA9IHRoaXNDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlcihvbmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytzdWNjZXNzQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9uZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpc0NvbnRleHQub25zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9vayB3aWxsIGV4cGVjdCBlaXRoZXIgb25lcnJvciBvciBvbnN1Y2Nlc3MgdG8gYWx3YXlzIGJlIGNhbGxlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQ29udGV4dC5vbnN1Y2Nlc3ModGhpc0NvbnRleHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvUmVqZWN0KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsS2V5cy5wdXNoKGN1cnJlbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsS2V5cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRmluaXNoZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uQ29tcGxldGUgJiYgc3VjY2Vzc0NvdW50ICsgZmFpbHVyZXMubGVuZ3RoID09PSBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1JlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdWNjZXNzQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvbmUoKS5yYXcoKS5faXRlcmF0ZShtb2RpZnlJdGVtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25Db21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGRvUmVqZWN0LCBpZGJzdG9yZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIHJhbmdlID0gY3R4LnJhbmdlLCBkZWxldGluZ0hvb2sgPSBjdHgudGFibGUuaG9vay5kZWxldGluZy5maXJlLCBoYXNEZWxldGVIb29rID0gZGVsZXRpbmdIb29rICE9PSBub3A7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNEZWxldGVIb29rICYmXG4gICAgICAgICAgICAgICAgICAgIGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICAgICAgICgoY3R4LmlzUHJpbUtleSAmJiAhaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UpIHx8ICFyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5IHVzZSBJREJPYmplY3RTdG9yZS5kZWxldGUoSURCS2V5UmFuZ2UpIGluIHRoaXMgY2FzZSAoSXNzdWUgIzIwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNocm9taXVtLCB0aGlzIGlzIHRoZSB3YXkgbW9zdCBvcHRpbWl6ZWQgdmVyc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIElFL0VkZ2UsIHRoaXMgY291bGQgaGFuZyB0aGUgaW5kZXhlZERCIGVuZ2luZSBhbmQgbWFrZSBvcGVyYXRpbmcgc3lzdGVtIGluc3RhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIChodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kZmFobGFuZGVyLzVhMzkzMjhmMDI5ZGUxODIyMmNmMjEyNWQ1NmMzOGY3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgaWRic3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91ciBBUEkgY29udHJhY3QgaXMgdG8gcmV0dXJuIGEgY291bnQgb2YgZGVsZXRlZCBpdGVtcywgc28gd2UgaGF2ZSB0byBjb3VudCgpIGJlZm9yZSBkZWxldGUoKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCksIGNvdW50UmVxID0gKHJhbmdlID8gaWRic3RvcmUuY291bnQocmFuZ2UpIDogaWRic3RvcmUuY291bnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudFJlcS5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50UmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBjb3VudFJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsUmVxID0gKHJhbmdlID8gaWRic3RvcmUuZGVsZXRlKHJhbmdlKSA6IGlkYnN0b3JlLmNsZWFyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxSZXEub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbFJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKGNvdW50KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB2ZXJzaW9uIHRvIHVzZSB3aGVuIGNvbGxlY3Rpb24gaXMgbm90IGEgdmFuaWxsYSBJREJLZXlSYW5nZSBvbiB0aGUgcHJpbWFyeSBrZXkuXG4gICAgICAgICAgICAgICAgLy8gRGl2aWRlIGludG8gY2h1bmtzIHRvIG5vdCBzdGFydmUgUkFNLlxuICAgICAgICAgICAgICAgIC8vIElmIGhhcyBkZWxldGUgaG9vaywgd2Ugd2lsbCBoYXZlIHRvIGNvbGxlY3Qgbm90IGp1c3Qga2V5cyBidXQgYWxzbyBvYmplY3RzLCBzbyBpdCB3aWxsIHVzZVxuICAgICAgICAgICAgICAgIC8vIG1vcmUgbWVtb3J5IGFuZCBuZWVkIGxvd2VyIGNodW5rIHNpemUuXG4gICAgICAgICAgICAgICAgdmFyIENIVU5LU0laRSA9IGhhc0RlbGV0ZUhvb2sgPyAyMDAwIDogMTAwMDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIGlkYnN0b3JlLCB0cmFucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25lIGNvbGxlY3Rpb24gYW5kIGNoYW5nZSBpdHMgdGFibGUgYW5kIHNldCBhIGxpbWl0IG9mIENIVU5LU0laRSBvbiB0aGUgY2xvbmVkIENvbGxlY3Rpb24gaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzT25seTogIWN0eC5pc01hdGNoICYmICFoYXNEZWxldGVIb29rXG4gICAgICAgICAgICAgICAgICAgIH0pIC8vIGxvYWQganVzdCBrZXlzICh1bmxlc3MgZmlsdGVyKCkgb3IgYW5kKCkgb3IgZGVsZXRlSG9vayBoYXMgc3Vic2NyaWJlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGlzdGluY3QoKSAvLyBJbiBjYXNlIG11bHRpRW50cnkgaXMgdXNlZCwgbmV2ZXIgZGVsZXRlIHNhbWUga2V5IHR3aWNlIGJlY2F1c2UgcmVzdWx0aW5nIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAubGltaXQoQ0hVTktTSVpFKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhdygpOyAvLyBEb24ndCBmaWx0ZXIgdGhyb3VnaCByZWFkaW5nLWhvb2tzIChsaWtlIG1hcHBlZCBjbGFzc2VzIGV0YylcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXNPclR1cGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBnb25uYSBkbyB0aGluZ3Mgb24gYXMgbWFueSBjaHVua3MgdGhhdCBhcmUgbmVlZGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcmVjdXJzaW9uIG9mIG5leHRDaHVuayBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaHVuayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaChoYXNEZWxldGVIb29rID8gZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21lYm9keSBzdWJzY3JpYmVzIHRvIGhvb2soJ2RlbGV0aW5nJykuIENvbGxlY3QgYWxsIHByaW1hcnkga2V5cyBhbmQgdGhlaXIgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgaG9vayBjYW4gYmUgY2FsbGVkIHdpdGggaXRzIHZhbHVlcyBpbiBidWxrRGVsZXRlKCkuXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzT3JUdXBsZXMucHVzaChbY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvci52YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBvbmUgc3Vic2NyaWJlcyB0byBob29rKCdkZWxldGluZycpLiBDb2xsZWN0IG9ubHkgcHJpbWFyeSBrZXlzOlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5c09yVHVwbGVzLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9taXVtIGRlbGV0ZXMgZmFzdGVyIHdoZW4gZG9pbmcgaXQgaW4gc29ydCBvcmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RlbGV0ZUhvb2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXNPclR1cGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhc2NlbmRpbmcoYVswXSwgYlswXSk7IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzT3JUdXBsZXMuc29ydChhc2NlbmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1bGtEZWxldGUoaWRic3RvcmUsIHRyYW5zLCBrZXlzT3JUdXBsZXMsIGhhc0RlbGV0ZUhvb2ssIGRlbGV0aW5nSG9vayk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0ga2V5c09yVHVwbGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ291bnQgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzT3JUdXBsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCA8IENIVU5LU0laRSA/IHRvdGFsQ291bnQgOiBuZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV4dENodW5rKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSGVscCBmdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvL1xuICAgIC8vXG4gICAgZnVuY3Rpb24gbG93ZXJWZXJzaW9uRmlyc3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5fY2ZnLnZlcnNpb24gLSBiLl9jZmcudmVyc2lvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QXBpT25QbGFjZShvYmpzLCB0YWJsZU5hbWVzLCBkYnNjaGVtYSkge1xuICAgICAgICB0YWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgICAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIGlmICghKHRhYmxlTmFtZSBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IFRyYW5zYWN0aW9uLnByb3RvdHlwZSB8fCBvYmogaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqIGlzIGEgVHJhbnNhY3Rpb24gcHJvdG90eXBlIChvciBwcm90b3R5cGUgb2YgYSBzdWJjbGFzcyB0byBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIEFQSSBhIGdldHRlciB0aGF0IHJldHVybnMgdGhpcy50YWJsZSh0YWJsZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50YWJsZSh0YWJsZU5hbWUpOyB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgd2lsbCBub3QgYmUgYm91bmQgdG8gYSB0cmFuc2FjdGlvbiAod2lsbCB1c2UgRGV4aWUuY3VycmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkob2Jqcykge1xuICAgICAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIFRhYmxlKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdGVyYXRlKHJlcSwgZmlsdGVyLCBmbiwgcmVzb2x2ZSwgcmVqZWN0LCB2YWx1ZU1hcHBlcikge1xuICAgICAgICAvLyBBcHBseSB2YWx1ZU1hcHBlciAoaG9vaygncmVhZGluZycpIG9yIG1hcHBwZWQgY2xhc3MpXG4gICAgICAgIHZhciBtYXBwZWRGbiA9IHZhbHVlTWFwcGVyID8gZnVuY3Rpb24gKHgsIGMsIGEpIHsgcmV0dXJuIGZuKHZhbHVlTWFwcGVyKHgpLCBjLCBhKTsgfSA6IGZuO1xuICAgICAgICAvLyBXcmFwIGZuIHdpdGggUFNEIGFuZCBtaWNyb3RpY2sgc3R1ZmYgZnJvbSBQcm9taXNlLlxuICAgICAgICB2YXIgd3JhcHBlZEZuID0gd3JhcChtYXBwZWRGbiwgcmVqZWN0KTtcbiAgICAgICAgaWYgKCFyZXEub25lcnJvcilcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB0cnljYXRjaGVyKGZ1bmN0aW9uIGZpbHRlcl9yZWNvcmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKCk7IH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIoY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgYyA9IGFkdmFuY2VyOyB9LCByZXNvbHZlLCByZWplY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBmdW5jdGlvbiAoYWR2YW5jZXIpIHsgYyA9IGFkdmFuY2VyOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gdHJ5Y2F0Y2hlcihmdW5jdGlvbiBmaWx0ZXJfcmVjb3JkKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZSgpOyB9O1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGZ1bmN0aW9uIChhZHZhbmNlcikgeyBjID0gYWR2YW5jZXI7IH0pO1xuICAgICAgICAgICAgICAgICAgICBjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUluZGV4U3ludGF4KGluZGV4ZXMpIHtcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhlc1wiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cIkFycmF5XCIgZWxlbWVudFR5cGU9XCJJbmRleFNwZWNcIj48L3JldHVybnM+XG4gICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICBpbmRleGVzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXgudHJpbSgpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpOyAvLyBSZW1vdmUgXCImXCIsIFwiKytcIiBhbmQgXCIqXCJcbiAgICAgICAgICAgIC8vIExldCBrZXlQYXRoIG9mIFwiW2ErYl1cIiBiZSBbXCJhXCIsXCJiXCJdOlxuICAgICAgICAgICAgdmFyIGtleVBhdGggPSAvXlxcWy8udGVzdChuYW1lKSA/IG5hbWUubWF0Y2goL15cXFsoLiopXFxdJC8pWzFdLnNwbGl0KCcrJykgOiBuYW1lO1xuICAgICAgICAgICAgcnYucHVzaChuZXcgSW5kZXhTcGVjKG5hbWUsIGtleVBhdGggfHwgbnVsbCwgL1xcJi8udGVzdChpbmRleCksIC9cXCovLnRlc3QoaW5kZXgpLCAvXFwrXFwrLy50ZXN0KGluZGV4KSwgaXNBcnJheShrZXlQYXRoKSwgL1xcLi8udGVzdChpbmRleCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY21wKGtleTEsIGtleTIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ZWREQi5jbXAoa2V5MSwga2V5Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1pbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heChhLCBiKSB7XG4gICAgICAgIHJldHVybiBjbXAoYSwgYikgPiAwID8gYSA6IGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBpbmRleGVkREIuY21wKGEsIGIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ZWREQi5jbXAoYiwgYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tYmluZShmaWx0ZXIxLCBmaWx0ZXIyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIxID9cbiAgICAgICAgICAgIGZpbHRlcjIgP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcjEuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBmaWx0ZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gOlxuICAgICAgICAgICAgICAgIGZpbHRlcjEgOlxuICAgICAgICAgICAgZmlsdGVyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEdsb2JhbFNjaGVtYSgpIHtcbiAgICAgICAgZGIudmVybm8gPSBpZGJkYi52ZXJzaW9uIC8gMTA7XG4gICAgICAgIGRiLl9kYlNjaGVtYSA9IGdsb2JhbFNjaGVtYSA9IHt9O1xuICAgICAgICBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgICAgICAgaWYgKGRiU3RvcmVOYW1lcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIERhdGFiYXNlIGNvbnRhaW5zIG5vIHN0b3Jlcy5cbiAgICAgICAgdmFyIHRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChkYlN0b3JlTmFtZXMpLCAncmVhZG9ubHknKTtcbiAgICAgICAgZGJTdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKSwga2V5UGF0aCA9IHN0b3JlLmtleVBhdGgsIGRvdHRlZCA9IGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnICYmIGtleVBhdGguaW5kZXhPZignLicpICE9PSAtMTtcbiAgICAgICAgICAgIHZhciBwcmltS2V5ID0gbmV3IEluZGV4U3BlYyhrZXlQYXRoLCBrZXlQYXRoIHx8IFwiXCIsIGZhbHNlLCBmYWxzZSwgISFzdG9yZS5hdXRvSW5jcmVtZW50LCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJywgZG90dGVkKTtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRiaW5kZXggPSBzdG9yZS5pbmRleChzdG9yZS5pbmRleE5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgICAgICAgICAgICBkb3R0ZWQgPSBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBrZXlQYXRoLmluZGV4T2YoJy4nKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbmV3IEluZGV4U3BlYyhpZGJpbmRleC5uYW1lLCBrZXlQYXRoLCAhIWlkYmluZGV4LnVuaXF1ZSwgISFpZGJpbmRleC5tdWx0aUVudHJ5LCBmYWxzZSwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycsIGRvdHRlZCk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsb2JhbFNjaGVtYVtzdG9yZU5hbWVdID0gbmV3IFRhYmxlU2NoZW1hKHN0b3JlTmFtZSwgcHJpbUtleSwgaW5kZXhlcywge30pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0QXBpT25QbGFjZShbYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhzY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgICAgIC8vLyA8c3VtbWFyeT5cbiAgICAgICAgLy8vIElzc3VlICMzMCBQcm9ibGVtIHdpdGggZXhpc3RpbmcgZGIgLSBhZGp1c3QgdG8gZXhpc3RpbmcgaW5kZXggbmFtZXMgd2hlbiBtaWdyYXRpbmcgZnJvbSBub24tZGV4aWUgZGJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NoZW1hXCIgdHlwZT1cIk9iamVjdFwiPk1hcCBiZXR3ZWVuIG5hbWUgYW5kIFRhYmxlU2NoZW1hPC9wYXJhbT5cbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaWRidHJhbnNcIiB0eXBlPVwiSURCVHJhbnNhY3Rpb25cIj48L3BhcmFtPlxuICAgICAgICB2YXIgc3RvcmVOYW1lcyA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgaGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhOYW1lID0gc3RvcmUuaW5kZXhOYW1lc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IHN0b3JlLmluZGV4KGluZGV4TmFtZSkua2V5UGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYVtzdG9yZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4U3BlYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgd2l0aCBnZXRBbGwoKSBvbiBTYWZhcmkgdmVyPDYwNCBvbiBXb3JrZXJzIG9ubHksIHNlZSBkaXNjdXNzaW9uIGZvbGxvd2luZyBQUiAjNTc5XG4gICAgICAgIGlmICgvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiYgX2dsb2JhbCBpbnN0YW5jZW9mIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICAgICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIHtcbiAgICAgICAgICAgIGhhc0dldEFsbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpcmVPbkJsb2NrZWQoZXYpIHtcbiAgICAgICAgZGIub24oXCJibG9ja2VkXCIpLmZpcmUoZXYpO1xuICAgICAgICAvLyBXb3JrYXJvdW5kIChub3QgZnVsbHkqKSBmb3IgbWlzc2luZyBcInZlcnNpb25jaGFuZ2VcIiBldmVudCBpbiBJRSxFZGdlIGFuZCBTYWZhcmk6XG4gICAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm5hbWUgPT09IGRiLm5hbWUgJiYgYyAhPT0gZGIgJiYgIWMuX3ZjRmlyZWQ7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTsgfSk7XG4gICAgfVxuICAgIGV4dGVuZCh0aGlzLCB7XG4gICAgICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gICAgICAgIFRhYmxlOiBUYWJsZSxcbiAgICAgICAgVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLFxuICAgICAgICBWZXJzaW9uOiBWZXJzaW9uLFxuICAgICAgICBXaGVyZUNsYXVzZTogV2hlcmVDbGF1c2VcbiAgICB9KTtcbiAgICBpbml0KCk7XG4gICAgYWRkb25zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGZuKGRiKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBbcGFyc2VUeXBlKHR5cGVbMF0pXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSAmJiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIHJ2ID0ge307XG4gICAgICAgIGFwcGx5U3RydWN0dXJlKHJ2LCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlTdHJ1Y3R1cmUob2JqLCBzdHJ1Y3R1cmUpIHtcbiAgICBrZXlzKHN0cnVjdHVyZSkuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlVHlwZShzdHJ1Y3R1cmVbbWVtYmVyXSk7XG4gICAgICAgIG9ialttZW1iZXJdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSkge1xuICAgIC8vIHdyYXAoKSBpcyBuZWVkZWQgd2hlbiBjYWxsaW5nIGhvb2tzIGJlY2F1c2UgdGhlIHJhcmUgc2NlbmFyaW8gb2Y6XG4gICAgLy8gICogaG9vayBkb2VzIGEgZGIgb3BlcmF0aW9uIHRoYXQgZmFpbHMgaW1tZWRpYXRlbHkgKElEQiB0aHJvd3MgZXhjZXB0aW9uKVxuICAgIC8vICAgIEZvciBjYWxsaW5nIGRiIG9wZXJhdGlvbnMgb24gY29ycmVjdCB0cmFuc2FjdGlvbiwgd3JhcCBtYWtlcyBzdXJlIHRvIHNldCBQU0QgY29ycmVjdGx5LlxuICAgIC8vICAgIHdyYXAoKSB3aWxsIGFsc28gZXhlY3V0ZSBpbiBhIHZpcnR1YWwgdGljay5cbiAgICAvLyAgKiBJZiBub3Qgd3JhcHBlZCBpbiBhIHZpcnR1YWwgdGljaywgZGlyZWN0IGV4Y2VwdGlvbiB3aWxsIGxhdW5jaCBhIG5ldyBwaHlzaWNhbCB0aWNrLlxuICAgIC8vICAqIElmIHRoaXMgd2FzIHRoZSBsYXN0IGV2ZW50IGluIHRoZSBidWxrLCB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgYWZ0ZXIgYSBwaHlzaWNhbCB0aWNrXG4gICAgLy8gICAgYW5kIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGhhdmUgY29tbWl0dGVkIGFscmVhZHkuXG4gICAgLy8gSWYgbm8gaG9vaywgdGhlIHZpcnR1YWwgdGljayB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSByZWplY3QoKS9yZXNvbHZlIG9mIHRoZSBmaW5hbCBwcm9taXNlLFxuICAgIC8vIGJlY2F1c2UgaXQgaXMgYWx3YXlzIG1hcmtlZCB3aXRoIF9saWIgPSB0cnVlIHdoZW4gY3JlYXRlZCB1c2luZyBUcmFuc2FjdGlvbi5fcHJvbWlzZSgpLlxuICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcmVxID0gZXZlbnQudGFyZ2V0LCBjdHggPSByZXEuX2hvb2tDdHgsIC8vIENvbnRhaW5zIHRoZSBob29rIGVycm9yIGhhbmRsZXIuIFB1dCBoZXJlIGluc3RlYWQgb2YgY2xvc3VyZSB0byBib29zdCBwZXJmb3JtYW5jZS5cbiAgICAgICAgcmVzdWx0ID0gY3R4LnZhbHVlIHx8IHJlcS5yZXN1bHQsIC8vIFBhc3MgdGhlIG9iamVjdCB2YWx1ZSBvbiB1cGRhdGVzLiBUaGUgcmVzdWx0IGZyb20gSURCIGlzIHRoZSBwcmltYXJ5IGtleS5cbiAgICAgICAgaG9va1N1Y2Nlc3NIYW5kbGVyID0gY3R4ICYmIGN0eC5vbnN1Y2Nlc3M7XG4gICAgICAgIGhvb2tTdWNjZXNzSGFuZGxlciAmJiBob29rU3VjY2Vzc0hhbmRsZXIocmVzdWx0KTtcbiAgICAgICAgcmVzb2x2ZSAmJiByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgcmVzb2x2ZSk7XG59XG5mdW5jdGlvbiBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KSB7XG4gICAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSkge1xuICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaG9va2VkRXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBTZWUgY29tbWVudCBvbiBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKCkgd2h5IHdyYXAoKSBpcyBuZWVkZWQgb25seSB3aGVuIHN1cHBvcnRpbmcgaG9va3MuXG4gICAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQsIGVyciA9IHJlcS5lcnJvciwgY3R4ID0gcmVxLl9ob29rQ3R4LCAvLyBDb250YWlucyB0aGUgaG9vayBlcnJvciBoYW5kbGVyLiBQdXQgaGVyZSBpbnN0ZWFkIG9mIGNsb3N1cmUgdG8gYm9vc3QgcGVyZm9ybWFuY2UuXG4gICAgICAgIGhvb2tFcnJvckhhbmRsZXIgPSBjdHggJiYgY3R4Lm9uZXJyb3I7XG4gICAgICAgIGhvb2tFcnJvckhhbmRsZXIgJiYgaG9va0Vycm9ySGFuZGxlcihlcnIpO1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgY2FsbE5leHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBpdGVyYXRvci5uZXh0KHJlc3VsdCk7IH0sIGRvVGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGl0ZXJhdG9yLnRocm93KGVycm9yKTsgfSwgb25TdWNjZXNzID0gc3RlcChjYWxsTmV4dCksIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuICAgIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksIHZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG4gICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkodmFsdWUpID8gUHJvbWlzZS5hbGwodmFsdWUpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSA6IG9uU3VjY2Vzcyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc3RlcChjYWxsTmV4dCkoKTtcbn1cbi8vXG4vLyBJbmRleFNwZWMgc3RydWN0XG4vL1xuZnVuY3Rpb24gSW5kZXhTcGVjKG5hbWUsIGtleVBhdGgsIHVuaXF1ZSwgbXVsdGksIGF1dG8sIGNvbXBvdW5kLCBkb3R0ZWQpIHtcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJuYW1lXCIgdHlwZT1cIlN0cmluZ1wiPjwvcGFyYW0+XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5UGF0aFwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgIC8vLyA8cGFyYW0gbmFtZT1cInVuaXF1ZVwiIHR5cGU9XCJCb29sZWFuXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJtdWx0aVwiIHR5cGU9XCJCb29sZWFuXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJhdXRvXCIgdHlwZT1cIkJvb2xlYW5cIj48L3BhcmFtPlxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbXBvdW5kXCIgdHlwZT1cIkJvb2xlYW5cIj48L3BhcmFtPlxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImRvdHRlZFwiIHR5cGU9XCJCb29sZWFuXCI+PC9wYXJhbT5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMua2V5UGF0aCA9IGtleVBhdGg7XG4gICAgdGhpcy51bmlxdWUgPSB1bmlxdWU7XG4gICAgdGhpcy5tdWx0aSA9IG11bHRpO1xuICAgIHRoaXMuYXV0byA9IGF1dG87XG4gICAgdGhpcy5jb21wb3VuZCA9IGNvbXBvdW5kO1xuICAgIHRoaXMuZG90dGVkID0gZG90dGVkO1xuICAgIHZhciBrZXlQYXRoU3JjID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IGtleVBhdGggJiYgKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKTtcbiAgICB0aGlzLnNyYyA9ICh1bmlxdWUgPyAnJicgOiAnJykgKyAobXVsdGkgPyAnKicgOiAnJykgKyAoYXV0byA/IFwiKytcIiA6IFwiXCIpICsga2V5UGF0aFNyYztcbn1cbi8vXG4vLyBUYWJsZVNjaGVtYSBzdHJ1Y3Rcbi8vXG5mdW5jdGlvbiBUYWJsZVNjaGVtYShuYW1lLCBwcmltS2V5LCBpbmRleGVzLCBpbnN0YW5jZVRlbXBsYXRlKSB7XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwibmFtZVwiIHR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICAgIC8vLyA8cGFyYW0gbmFtZT1cInByaW1LZXlcIiB0eXBlPVwiSW5kZXhTcGVjXCI+PC9wYXJhbT5cbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleGVzXCIgdHlwZT1cIkFycmF5XCIgZWxlbWVudFR5cGU9XCJJbmRleFNwZWNcIj48L3BhcmFtPlxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImluc3RhbmNlVGVtcGxhdGVcIiB0eXBlPVwiT2JqZWN0XCI+PC9wYXJhbT5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJpbUtleSA9IHByaW1LZXkgfHwgbmV3IEluZGV4U3BlYygpO1xuICAgIHRoaXMuaW5kZXhlcyA9IGluZGV4ZXMgfHwgW25ldyBJbmRleFNwZWMoKV07XG4gICAgdGhpcy5pbnN0YW5jZVRlbXBsYXRlID0gaW5zdGFuY2VUZW1wbGF0ZTtcbiAgICB0aGlzLm1hcHBlZENsYXNzID0gbnVsbDtcbiAgICB0aGlzLmlkeEJ5TmFtZSA9IGFycmF5VG9PYmplY3QoaW5kZXhlcywgZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBbaW5kZXgubmFtZSwgaW5kZXhdOyB9KTtcbn1cbmZ1bmN0aW9uIHNhZmFyaU11bHRpU3RvcmVGaXgoc3RvcmVOYW1lcykge1xuICAgIHJldHVybiBzdG9yZU5hbWVzLmxlbmd0aCA9PT0gMSA/IHN0b3JlTmFtZXNbMF0gOiBzdG9yZU5hbWVzO1xufVxuZnVuY3Rpb24gZ2V0TmF0aXZlR2V0RGF0YWJhc2VOYW1lc0ZuKGluZGV4ZWREQikge1xuICAgIHZhciBmbiA9IGluZGV4ZWREQiAmJiAoaW5kZXhlZERCLmdldERhdGFiYXNlTmFtZXMgfHwgaW5kZXhlZERCLndlYmtpdEdldERhdGFiYXNlTmFtZXMpO1xuICAgIHJldHVybiBmbiAmJiBmbi5iaW5kKGluZGV4ZWREQik7XG59XG4vLyBFeHBvcnQgRXJyb3IgY2xhc3Nlc1xucHJvcHMoRGV4aWUsIGZ1bGxOYW1lRXhjZXB0aW9ucyk7IC8vIERleGllLlhYWEVycm9yID0gY2xhc3MgWFhYRXJyb3Igey4uLn07XG4vL1xuLy8gU3RhdGljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcbi8vIFxucHJvcHMoRGV4aWUsIHtcbiAgICAvL1xuICAgIC8vIFN0YXRpYyBkZWxldGUoKSBtZXRob2QuXG4gICAgLy9cbiAgICBkZWxldGU6IGZ1bmN0aW9uIChkYXRhYmFzZU5hbWUpIHtcbiAgICAgICAgdmFyIGRiID0gbmV3IERleGllKGRhdGFiYXNlTmFtZSksIHByb21pc2UgPSBkYi5kZWxldGUoKTtcbiAgICAgICAgcHJvbWlzZS5vbmJsb2NrZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGRiLm9uKFwiYmxvY2tlZFwiLCBmbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICAvL1xuICAgIC8vIFN0YXRpYyBleGlzdHMoKSBtZXRob2QuXG4gICAgLy9cbiAgICBleGlzdHM6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWUobmFtZSkub3BlbigpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmNhdGNoKERleGllLk5vU3VjaERhdGFiYXNlRXJyb3IsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICB9LFxuICAgIC8vXG4gICAgLy8gU3RhdGljIG1ldGhvZCBmb3IgcmV0cmlldmluZyBhIGxpc3Qgb2YgYWxsIGV4aXN0aW5nIGRhdGFiYXNlcyBhdCBjdXJyZW50IGhvc3QuXG4gICAgLy9cbiAgICBnZXREYXRhYmFzZU5hbWVzOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIGdldERhdGFiYXNlTmFtZXMgPSBnZXROYXRpdmVHZXREYXRhYmFzZU5hbWVzRm4oRGV4aWUuZGVwZW5kZW5jaWVzLmluZGV4ZWREQik7XG4gICAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzID8gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IGdldERhdGFiYXNlTmFtZXMoKTtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHNsaWNlKGV2ZW50LnRhcmdldC5yZXN1bHQsIDApKTsgLy8gQ29udmVyc3QgRE9NU3RyaW5nTGlzdCB0byBBcnJheTxTdHJpbmc+XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihjYikgOiBkYk5hbWVzREIuZGJuYW1lcy50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cyhjYik7XG4gICAgfSxcbiAgICBkZWZpbmVDbGFzczogZnVuY3Rpb24gKHN0cnVjdHVyZSkge1xuICAgICAgICAvLy8gPHN1bW1hcnk+XG4gICAgICAgIC8vLyAgICAgQ3JlYXRlIGEgamF2YXNjcmlwdCBjb25zdHJ1Y3RvciBiYXNlZCBvbiBnaXZlbiB0ZW1wbGF0ZSBmb3Igd2hpY2ggcHJvcGVydGllcyB0byBleHBlY3QgaW4gdGhlIGNsYXNzLlxuICAgICAgICAvLy8gICAgIEFueSBwcm9wZXJ0eSB0aGF0IGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gd2lsbCBhY3QgYXMgYSB0eXBlLiBTbyB7bmFtZTogU3RyaW5nfSB3aWxsIGJlIGVxdWFsIHRvIHtuYW1lOiBuZXcgU3RyaW5nKCl9LlxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdHJ1Y3R1cmVcIj5IZWxwcyBJREUgY29kZSBjb21wbGV0aW9uIGJ5IGtub3dpbmcgdGhlIG1lbWJlcnMgdGhhdCBvYmplY3RzIGNvbnRhaW4gYW5kIG5vdCBqdXN0IHRoZSBpbmRleGVzLiBBbHNvXG4gICAgICAgIC8vLyBrbm93IHdoYXQgdHlwZSBlYWNoIG1lbWJlciBoYXMuIEV4YW1wbGU6IHtuYW1lOiBTdHJpbmcsIGVtYWlsQWRkcmVzc2VzOiBbU3RyaW5nXSwgcHJvcGVydGllczoge3Nob2VTaXplOiBOdW1iZXJ9fTwvcGFyYW0+XG4gICAgICAgIC8vIERlZmF1bHQgY29uc3RydWN0b3IgYWJsZSB0byBjb3B5IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MocHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJvcGVydGllc1wiIHR5cGU9XCJPYmplY3RcIiBvcHRpb25hbD1cInRydWVcIj5Qcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb2JqZWN0IHdpdGguXG4gICAgICAgICAgICAvLy8gPC9wYXJhbT5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2xhc3M7XG4gICAgfSxcbiAgICBhcHBseVN0cnVjdHVyZTogYXBwbHlTdHJ1Y3R1cmUsXG4gICAgaWdub3JlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChzY29wZUZ1bmMpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBjYWxsZXIgaXMgd2l0aGluIGEgdHJhbnNhY3Rpb24gYnV0IG5lZWRzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uLlxuICAgICAgICAvLyBFeGFtcGxlIG9mIHVzYWdlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBMZXQncyBzYXkgd2UgaGF2ZSBhIGxvZ2dlciBmdW5jdGlvbiBpbiBvdXIgYXBwLiBPdGhlciBhcHBsaWNhdGlvbi1sb2dpYyBzaG91bGQgYmUgdW5hd2FyZSBvZiB0aGVcbiAgICAgICAgLy8gbG9nZ2VyIGZ1bmN0aW9uIGFuZCBub3QgbmVlZCB0byBpbmNsdWRlIHRoZSAnbG9nZW50cmllcycgdGFibGUgaW4gYWxsIHRyYW5zYWN0aW9uIGl0IHBlcmZvcm1zLlxuICAgICAgICAvLyBUaGUgbG9nZ2luZyBzaG91bGQgYWx3YXlzIGJlIGRvbmUgaW4gYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbiBhbmQgbm90IGJlIGRlcGVuZGFudCBvbiB0aGUgY3VycmVudFxuICAgICAgICAvLyBydW5uaW5nIHRyYW5zYWN0aW9uIGNvbnRleHQuIFRoZW4geW91IGNvdWxkIHVzZSBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbigpIHRvIHJ1biBjb2RlIHRoYXQgc3RhcnRzIGEgbmV3IHRyYW5zYWN0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICAgICAgZGIubG9nZW50cmllcy5hZGQobmV3TG9nRW50cnkpO1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFVubGVzcyB1c2luZyBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbigpLCB0aGUgYWJvdmUgZXhhbXBsZSB3b3VsZCB0cnkgdG8gcmV1c2UgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgLy8gaW4gY3VycmVudCBQcm9taXNlLXNjb3BlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbiBhbHRlcm5hdGl2ZSB0byBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbigpIHdvdWxkIGJlIHNldEltbWVkaWF0ZSgpIG9yIHNldFRpbWVvdXQoKS4gVGhlIHJlYXNvbiB3ZSBzdGlsbCBwcm92aWRlIGFuXG4gICAgICAgIC8vIEFQSSBmb3IgdGhpcyBiZWNhdXNlXG4gICAgICAgIC8vICAxKSBUaGUgaW50ZW50aW9uIG9mIHdyaXRpbmcgdGhlIHN0YXRlbWVudCBjb3VsZCBiZSB1bmNsZWFyIGlmIHVzaW5nIHNldEltbWVkaWF0ZSgpIG9yIHNldFRpbWVvdXQoKS5cbiAgICAgICAgLy8gIDIpIHNldFRpbWVvdXQoKSB3b3VsZCB3YWl0IHVubmVzY2Vzc2FyeSB1bnRpbCBmaXJpbmcuIFRoaXMgaXMgaG93ZXZlciBub3QgdGhlIGNhc2Ugd2l0aCBzZXRJbW1lZGlhdGUoKS5cbiAgICAgICAgLy8gIDMpIHNldEltbWVkaWF0ZSgpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEVTIHN0YW5kYXJkLlxuICAgICAgICAvLyAgNCkgWW91IG1pZ2h0IHdhbnQgdG8ga2VlcCBvdGhlciBQU0Qgc3RhdGUgdGhhdCB3YXMgc2V0IGluIGEgcGFyZW50IFBTRCwgc3VjaCBhcyBQU0QubGV0VGhyb3VnaC5cbiAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgc2NvcGVGdW5jKSA6IC8vIFVzZSB0aGUgY2xvc2VzdCBwYXJlbnQgdGhhdCB3YXMgbm9uLXRyYW5zYWN0aW9uYWwuXG4gICAgICAgICAgICBzY29wZUZ1bmMoKTsgLy8gTm8gbmVlZCB0byBjaGFuZ2Ugc2NvcGUgYmVjYXVzZSB0aGVyZSBpcyBubyBvbmdvaW5nIHRyYW5zYWN0aW9uLlxuICAgIH0sXG4gICAgdmlwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgLy8gVG8gYmUgdXNlZCBieSBzdWJzY3JpYmVycyB0byB0aGUgb24oJ3JlYWR5JykgZXZlbnQuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZXQgY2FsbGVyIHRocm91Z2ggdG8gYWNjZXNzIERCIGV2ZW4gd2hlbiBpdCBpcyBibG9ja2VkIHdoaWxlIHRoZSBkYi5yZWFkeSgpIHN1YnNjcmliZXJzIGFyZSBmaXJpbmcuXG4gICAgICAgIC8vIFRoaXMgd291bGQgaGF2ZSB3b3JrZWQgYXV0b21hdGljYWxseSBpZiB3ZSB3ZXJlIGNlcnRhaW4gdGhhdCB0aGUgUHJvdmlkZXIgd2FzIHVzaW5nIERleGllLlByb21pc2UgZm9yIGFsbCBhc3luY3JvbmljIG9wZXJhdGlvbnMuIFRoZSBwcm9taXNlIFBTRFxuICAgICAgICAvLyBmcm9tIHRoZSBwcm92aWRlci5jb25uZWN0KCkgY2FsbCB3b3VsZCB0aGVuIGJlIGRlcml2ZWQgYWxsIHRoZSB3YXkgdG8gd2hlbiBwcm92aWRlciB3b3VsZCBjYWxsIGxvY2FsRGF0YWJhc2UuYXBwbHlDaGFuZ2VzKCkuIEJ1dCBzaW5jZVxuICAgICAgICAvLyB0aGUgcHJvdmlkZXIgbW9yZSBsaWtlbHkgaXMgdXNpbmcgbm9uLXByb21pc2UgYXN5bmMgQVBJcyBvciBvdGhlciB0aGVuYWJsZSBpbXBsZW1lbnRhdGlvbnMsIHdlIGNhbm5vdCBhc3N1bWUgdGhhdC5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZnVsIGZvciBvbigncmVhZHknKSBzdWJzY3JpYmVycyB0aGF0IGlzIHJldHVybmluZyBhIFByb21pc2UgZnJvbSB0aGUgZXZlbnQuIElmIG5vdCB1c2luZyB2aXAoKVxuICAgICAgICAvLyB0aGUgZGF0YWJhc2UgY291bGQgZGVhZGxvY2sgc2luY2UgaXQgd29udCBvcGVuIHVudGlsIHRoZSByZXR1cm5lZCBQcm9taXNlIGlzIHJlc29sdmVkLCBhbmQgYW55IG5vbi1WSVBlZCBvcGVyYXRpb24gc3RhcnRlZCBieVxuICAgICAgICAvLyB0aGUgY2FsbGVyIHdpbGwgbm90IHJlc29sdmUgdW50aWwgZGF0YWJhc2UgaXMgb3BlbmVkLlxuICAgICAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgUFNELmxldFRocm91Z2ggPSB0cnVlOyAvLyBNYWtlIHN1cmUgd2UgYXJlIGxldCB0aHJvdWdoIGlmIHN0aWxsIGJsb2NraW5nIGRiIGR1ZSB0byBvbnJlYWR5IGlzIGZpcmluZy5cbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzcGF3bjogZnVuY3Rpb24gKGdlbmVyYXRvckZuLCBhcmdzLCB0aGl6KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcbiAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIERleGllLmN1cnJlbnRUcmFuc2FjdGlvbiBwcm9wZXJ0eVxuICAgIGN1cnJlbnRUcmFuc2FjdGlvbjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBTRC50cmFucyB8fCBudWxsOyB9XG4gICAgfSxcbiAgICB3YWl0Rm9yOiBmdW5jdGlvbiAocHJvbWlzZU9yRnVuY3Rpb24sIG9wdGlvbmFsVGltZW91dCkge1xuICAgICAgICAvLyBJZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpbnZva2UgaXQgYW5kIHBhc3MgdGhlIHJldHVybmluZyB2YWx1ZSB0byBUcmFuc2FjdGlvbi53YWl0Rm9yKClcbiAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID8gRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDogcHJvbWlzZU9yRnVuY3Rpb24pXG4gICAgICAgICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApOyAvLyBEZWZhdWx0IHRoZSB0aW1lb3V0IHRvIG9uZSBtaW51dGUuIENhbGxlciBtYXkgc3BlY2lmeSBJbmZpbml0eSBpZiByZXF1aXJlZC4gICAgICAgXG4gICAgICAgIC8vIFJ1biBnaXZlbiBwcm9taXNlIG9uIGN1cnJlbnQgdHJhbnNhY3Rpb24uIElmIG5vIGN1cnJlbnQgdHJhbnNhY3Rpb24sIGp1c3QgcmV0dXJuIGEgRGV4aWUgcHJvbWlzZSBiYXNlZFxuICAgICAgICAvLyBvbiBnaXZlbiB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIFBTRC50cmFucyA/IFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDogcHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIEV4cG9ydCBvdXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBzaW5jZSBpdCBjYW4gYmUgaGFuZHkgYXMgYSBzdGFuZGFsb25lIFByb21pc2UgaW1wbGVtZW50YXRpb25cbiAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgIC8vIERleGllLmRlYnVnIHByb3B0ZXJ5OlxuICAgIC8vIERleGllLmRlYnVnID0gZmFsc2VcbiAgICAvLyBEZXhpZS5kZWJ1ZyA9IHRydWVcbiAgICAvLyBEZXhpZS5kZWJ1ZyA9IFwiZGV4aWVcIiAtIGRvbid0IGhpZGUgZGV4aWUncyBzdGFjayBmcmFtZXMuXG4gICAgZGVidWc6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWJ1ZzsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldERlYnVnKHZhbHVlLCB2YWx1ZSA9PT0gJ2RleGllJyA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0gOiBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBFeHBvcnQgb3VyIGRlcml2ZS9leHRlbmQvb3ZlcnJpZGUgbWV0aG9kb2xvZ3lcbiAgICBkZXJpdmU6IGRlcml2ZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuICAgIC8vIEV4cG9ydCBvdXIgRXZlbnRzKCkgZnVuY3Rpb24gLSBjYW4gYmUgaGFuZHkgYXMgYSB0b29sa2l0XG4gICAgRXZlbnRzOiBFdmVudHMsXG4gICAgLy8gVXRpbGl0aWVzXG4gICAgZ2V0QnlLZXlQYXRoOiBnZXRCeUtleVBhdGgsXG4gICAgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsXG4gICAgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsXG4gICAgc2hhbGxvd0Nsb25lOiBzaGFsbG93Q2xvbmUsXG4gICAgZGVlcENsb25lOiBkZWVwQ2xvbmUsXG4gICAgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZixcbiAgICBhc2FwOiBhc2FwLFxuICAgIG1heEtleTogbWF4S2V5LFxuICAgIG1pbktleTogbWluS2V5LFxuICAgIC8vIEFkZG9uIHJlZ2lzdHJ5XG4gICAgYWRkb25zOiBbXSxcbiAgICAvLyBHbG9iYWwgREIgY29ubmVjdGlvbiBsaXN0XG4gICAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuICAgIE11bHRpTW9kaWZ5RXJyb3I6IGV4Y2VwdGlvbnMuTW9kaWZ5LFxuICAgIGVycm5hbWVzOiBlcnJuYW1lcyxcbiAgICAvLyBFeHBvcnQgb3RoZXIgc3RhdGljIGNsYXNzZXNcbiAgICBJbmRleFNwZWM6IEluZGV4U3BlYyxcbiAgICBUYWJsZVNjaGVtYTogVGFibGVTY2hlbWEsXG4gICAgLy9cbiAgICAvLyBEZXBlbmRlbmNpZXNcbiAgICAvL1xuICAgIC8vIFRoZXNlIHdpbGwgYXV0b21hdGljYWxseSB3b3JrIGluIGJyb3dzZXJzIHdpdGggaW5kZXhlZERCIHN1cHBvcnQsIG9yIHdoZXJlIGFuIGluZGV4ZWREQiBwb2x5ZmlsbCBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgICAvL1xuICAgIC8vIEluIG5vZGUuanMsIGhvd2V2ZXIsIHRoZXNlIHByb3BlcnRpZXMgbXVzdCBiZSBzZXQgXCJtYW51YWxseVwiIGJlZm9yZSBpbnN0YW5zaWF0aW5nIGEgbmV3IERleGllKCkuXG4gICAgLy8gRm9yIG5vZGUuanMsIHlvdSBuZWVkIHRvIHJlcXVpcmUgaW5kZXhlZGRiLWpzIG9yIHNpbWlsYXIgYW5kIHRoZW4gc2V0IHRoZXNlIGRlcHMuXG4gICAgLy9cbiAgICBkZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgLy8gUmVxdWlyZWQ6XG4gICAgICAgIGluZGV4ZWREQjogX2dsb2JhbC5pbmRleGVkREIgfHwgX2dsb2JhbC5tb3pJbmRleGVkREIgfHwgX2dsb2JhbC53ZWJraXRJbmRleGVkREIgfHwgX2dsb2JhbC5tc0luZGV4ZWREQixcbiAgICAgICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICAgIH0sXG4gICAgLy8gQVBJIFZlcnNpb24gTnVtYmVyOiBUeXBlIE51bWJlciwgbWFrZSBzdXJlIHRvIGFsd2F5cyBzZXQgYSB2ZXJzaW9uIG51bWJlciB0aGF0IGNhbiBiZSBjb21wYXJhYmxlIGNvcnJlY3RseS4gRXhhbXBsZTogMC45LCAwLjkxLCAwLjkyLCAxLjAsIDEuMDEsIDEuMSwgMS4yLCAxLjIxLCBldGMuXG4gICAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLFxuICAgIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBwYXJzZUludChuKTsgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocCwgYywgaSkgeyByZXR1cm4gcCArIChjIC8gTWF0aC5wb3coMTAsIGkgKiAyKSk7IH0pLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyL0RleGllLmpzL2lzc3Vlcy8xODZcbiAgICAvLyB0eXBlc2NyaXB0IGNvbXBpbGVyIHRzYyBpbiBtb2RlIHRzLS0+ZXM1ICYgY29tbW9uSlMsIHdpbGwgZXhwZWN0IHJlcXVpcmUoKSB0byByZXR1cm5cbiAgICAvLyB4LmRlZmF1bHQuIFdvcmthcm91bmQ6IFNldCBEZXhpZS5kZWZhdWx0ID0gRGV4aWUuXG4gICAgZGVmYXVsdDogRGV4aWUsXG4gICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBpbXBvcnQge0RleGllfSAobm9uLWRlZmF1bHQgaW1wb3J0KVxuICAgIC8vIFJlYXNvbiAxOiBNYXkgc3dpdGNoIHRvIHRoYXQgaW4gZnV0dXJlLlxuICAgIC8vIFJlYXNvbiAyOiBXZSBkZWNsYXJlIGl0IGJvdGggZGVmYXVsdCBhbmQgbmFtZWQgZXhwb3J0ZWQgaW4gZC50cyB0byBtYWtlIGl0IHBvc3NpYmxlXG4gICAgLy8gdG8gbGV0IGFkZG9ucyBleHRlbmQgdGhlIERleGllIGludGVyZmFjZSB3aXRoIFR5cGVzY3JpcHQgMi4xICh3b3JrcyBvbmx5IHdoZW4gZXhwbGljaXRlbHlcbiAgICAvLyBleHBvcnRpbmcgdGhlIHN5bWJvbCwgbm90IGp1c3QgZGVmYXVsdCBleHBvcnRpbmcpXG4gICAgRGV4aWU6IERleGllXG59KTtcbi8vIE1hcCBET01FcnJvcnMgYW5kIERPTUV4Y2VwdGlvbnMgdG8gY29ycmVzcG9uZGluZyBEZXhpZSBlcnJvcnMuIE1heSBjaGFuZ2UgaW4gRGV4aWUgdjIuMC5cblByb21pc2UucmVqZWN0aW9uTWFwcGVyID0gbWFwRXJyb3I7XG4vLyBJbml0aWFsaXplIGRiTmFtZXNEQiAod29uJ3QgZXZlciBiZSBvcGVuZWQgb24gY2hyb21pdW0gYnJvd3NlcnMnKVxuZGJOYW1lc0RCID0gbmV3IERleGllKCdfX2RibmFtZXMnKTtcbmRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6ICduYW1lJyB9KTtcbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWlncmF0ZSBmcm9tIERleGllIDEueCBkYXRhYmFzZSBuYW1lcyBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlOlxuICAgIHZhciBEQk5BTUVTID0gJ0RleGllLkRhdGFiYXNlTmFtZXMnO1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSB1bmRlZmluZWQgJiYgX2dsb2JhbC5kb2N1bWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSGF2ZSBsb2NhbFN0b3JhZ2UgYW5kIGlzIG5vdCBleGVjdXRpbmcgaW4gYSB3b3JrZXIuIExldHMgbWlncmF0ZSBmcm9tIERleGllIDEueC5cbiAgICAgICAgICAgIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oREJOQU1FUykgfHwgXCJbXVwiKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBkYk5hbWVzREIuZGJuYW1lcy5wdXQoeyBuYW1lOiBuYW1lIH0pLmNhdGNoKG5vcCk7IH0pO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oREJOQU1FUyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lKSB7IH1cbn0pKCk7XG5cbnJldHVybiBEZXhpZTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRleGllLmpzLm1hcFxuIl19
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIklubmVyU3Vic2NyaWJlci5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJTdWJzY3JpYmVyXzEiLCJyZXF1aXJlIiwiSW5uZXJTdWJzY3JpYmVyIiwiX3N1cGVyIiwicGFyZW50Iiwib3V0ZXJWYWx1ZSIsIm91dGVySW5kZXgiLCJjYWxsIiwiaW5kZXgiLCJfbmV4dCIsInZhbHVlIiwibm90aWZ5TmV4dCIsIl9lcnJvciIsImVycm9yIiwibm90aWZ5RXJyb3IiLCJ1bnN1YnNjcmliZSIsIl9jb21wbGV0ZSIsIm5vdGlmeUNvbXBsZXRlIiwiU3Vic2NyaWJlciIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSUssZUFBZUMsUUFBUSxjQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSUMsa0JBQW1CLFVBQVVDLE1BQVYsRUFBa0I7QUFDckNiLGNBQVVZLGVBQVYsRUFBMkJDLE1BQTNCO0FBQ0EsYUFBU0QsZUFBVCxDQUF5QkUsTUFBekIsRUFBaUNDLFVBQWpDLEVBQTZDQyxVQUE3QyxFQUF5RDtBQUNyREgsZUFBT0ksSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLSCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxhQUFLQyxVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLGFBQUtDLFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0EsYUFBS0UsS0FBTCxHQUFhLENBQWI7QUFDSDtBQUNETixvQkFBZ0JMLFNBQWhCLENBQTBCWSxLQUExQixHQUFrQyxVQUFVQyxLQUFWLEVBQWlCO0FBQy9DLGFBQUtOLE1BQUwsQ0FBWU8sVUFBWixDQUF1QixLQUFLTixVQUE1QixFQUF3Q0ssS0FBeEMsRUFBK0MsS0FBS0osVUFBcEQsRUFBZ0UsS0FBS0UsS0FBTCxFQUFoRSxFQUE4RSxJQUE5RTtBQUNILEtBRkQ7QUFHQU4sb0JBQWdCTCxTQUFoQixDQUEwQmUsTUFBMUIsR0FBbUMsVUFBVUMsS0FBVixFQUFpQjtBQUNoRCxhQUFLVCxNQUFMLENBQVlVLFdBQVosQ0FBd0JELEtBQXhCLEVBQStCLElBQS9CO0FBQ0EsYUFBS0UsV0FBTDtBQUNILEtBSEQ7QUFJQWIsb0JBQWdCTCxTQUFoQixDQUEwQm1CLFNBQTFCLEdBQXNDLFlBQVk7QUFDOUMsYUFBS1osTUFBTCxDQUFZYSxjQUFaLENBQTJCLElBQTNCO0FBQ0EsYUFBS0YsV0FBTDtBQUNILEtBSEQ7QUFJQSxXQUFPYixlQUFQO0FBQ0gsQ0FyQnNCLENBcUJyQkYsYUFBYWtCLFVBckJRLENBQXZCO0FBc0JBQyxRQUFRakIsZUFBUixHQUEwQkEsZUFBMUI7QUFDQSIsImZpbGUiOiJJbm5lclN1YnNjcmliZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJTdWJzY3JpYmVyKHBhcmVudCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub3V0ZXJWYWx1ZSA9IG91dGVyVmFsdWU7XG4gICAgICAgIHRoaXMub3V0ZXJJbmRleCA9IG91dGVySW5kZXg7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodGhpcy5vdXRlclZhbHVlLCB2YWx1ZSwgdGhpcy5vdXRlckluZGV4LCB0aGlzLmluZGV4KyssIHRoaXMpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5Q29tcGxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbm5lclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLklubmVyU3Vic2NyaWJlciA9IElubmVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmVyU3Vic2NyaWJlci5qcy5tYXAiXX0=
},{"./Subscriber":9}],3:[function(require,module,exports){
"use strict";

var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk5vdGlmaWNhdGlvbi5qcyJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlXzEiLCJyZXF1aXJlIiwiTm90aWZpY2F0aW9uIiwia2luZCIsInZhbHVlIiwiZXJyb3IiLCJoYXNWYWx1ZSIsInByb3RvdHlwZSIsIm9ic2VydmUiLCJvYnNlcnZlciIsIm5leHQiLCJjb21wbGV0ZSIsImRvIiwiYWNjZXB0IiwibmV4dE9yT2JzZXJ2ZXIiLCJ0b09ic2VydmFibGUiLCJPYnNlcnZhYmxlIiwib2YiLCJ0aHJvdyIsImVtcHR5IiwiRXJyb3IiLCJjcmVhdGVOZXh0IiwidW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb24iLCJjcmVhdGVFcnJvciIsImVyciIsInVuZGVmaW5lZCIsImNyZWF0ZUNvbXBsZXRlIiwiY29tcGxldGVOb3RpZmljYXRpb24iLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxlQUFlQyxRQUFRLGNBQVIsQ0FBbkI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFJQyxlQUFnQixZQUFZO0FBQzVCLGFBQVNBLFlBQVQsQ0FBc0JDLElBQXRCLEVBQTRCQyxLQUE1QixFQUFtQ0MsS0FBbkMsRUFBMEM7QUFDdEMsYUFBS0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsYUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS0MsUUFBTCxHQUFnQkgsU0FBUyxHQUF6QjtBQUNIO0FBQ0Q7Ozs7O0FBS0FELGlCQUFhSyxTQUFiLENBQXVCQyxPQUF2QixHQUFpQyxVQUFVQyxRQUFWLEVBQW9CO0FBQ2pELGdCQUFRLEtBQUtOLElBQWI7QUFDSSxpQkFBSyxHQUFMO0FBQ0ksdUJBQU9NLFNBQVNDLElBQVQsSUFBaUJELFNBQVNDLElBQVQsQ0FBYyxLQUFLTixLQUFuQixDQUF4QjtBQUNKLGlCQUFLLEdBQUw7QUFDSSx1QkFBT0ssU0FBU0osS0FBVCxJQUFrQkksU0FBU0osS0FBVCxDQUFlLEtBQUtBLEtBQXBCLENBQXpCO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPSSxTQUFTRSxRQUFULElBQXFCRixTQUFTRSxRQUFULEVBQTVCO0FBTlI7QUFRSCxLQVREO0FBVUE7Ozs7Ozs7O0FBUUFULGlCQUFhSyxTQUFiLENBQXVCSyxFQUF2QixHQUE0QixVQUFVRixJQUFWLEVBQWdCTCxLQUFoQixFQUF1Qk0sUUFBdkIsRUFBaUM7QUFDekQsWUFBSVIsT0FBTyxLQUFLQSxJQUFoQjtBQUNBLGdCQUFRQSxJQUFSO0FBQ0ksaUJBQUssR0FBTDtBQUNJLHVCQUFPTyxRQUFRQSxLQUFLLEtBQUtOLEtBQVYsQ0FBZjtBQUNKLGlCQUFLLEdBQUw7QUFDSSx1QkFBT0MsU0FBU0EsTUFBTSxLQUFLQSxLQUFYLENBQWhCO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPTSxZQUFZQSxVQUFuQjtBQU5SO0FBUUgsS0FWRDtBQVdBOzs7Ozs7Ozs7QUFTQVQsaUJBQWFLLFNBQWIsQ0FBdUJNLE1BQXZCLEdBQWdDLFVBQVVDLGNBQVYsRUFBMEJULEtBQTFCLEVBQWlDTSxRQUFqQyxFQUEyQztBQUN2RSxZQUFJRyxrQkFBa0IsT0FBT0EsZUFBZUosSUFBdEIsS0FBK0IsVUFBckQsRUFBaUU7QUFDN0QsbUJBQU8sS0FBS0YsT0FBTCxDQUFhTSxjQUFiLENBQVA7QUFDSCxTQUZELE1BR0s7QUFDRCxtQkFBTyxLQUFLRixFQUFMLENBQVFFLGNBQVIsRUFBd0JULEtBQXhCLEVBQStCTSxRQUEvQixDQUFQO0FBQ0g7QUFDSixLQVBEO0FBUUE7Ozs7O0FBS0FULGlCQUFhSyxTQUFiLENBQXVCUSxZQUF2QixHQUFzQyxZQUFZO0FBQzlDLFlBQUlaLE9BQU8sS0FBS0EsSUFBaEI7QUFDQSxnQkFBUUEsSUFBUjtBQUNJLGlCQUFLLEdBQUw7QUFDSSx1QkFBT0gsYUFBYWdCLFVBQWIsQ0FBd0JDLEVBQXhCLENBQTJCLEtBQUtiLEtBQWhDLENBQVA7QUFDSixpQkFBSyxHQUFMO0FBQ0ksdUJBQU9KLGFBQWFnQixVQUFiLENBQXdCRSxLQUF4QixDQUE4QixLQUFLYixLQUFuQyxDQUFQO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPTCxhQUFhZ0IsVUFBYixDQUF3QkcsS0FBeEIsRUFBUDtBQU5SO0FBUUEsY0FBTSxJQUFJQyxLQUFKLENBQVUsb0NBQVYsQ0FBTjtBQUNILEtBWEQ7QUFZQTs7Ozs7OztBQU9BbEIsaUJBQWFtQixVQUFiLEdBQTBCLFVBQVVqQixLQUFWLEVBQWlCO0FBQ3ZDLFlBQUksT0FBT0EsS0FBUCxLQUFpQixXQUFyQixFQUFrQztBQUM5QixtQkFBTyxJQUFJRixZQUFKLENBQWlCLEdBQWpCLEVBQXNCRSxLQUF0QixDQUFQO0FBQ0g7QUFDRCxlQUFPRixhQUFhb0IsMEJBQXBCO0FBQ0gsS0FMRDtBQU1BOzs7Ozs7O0FBT0FwQixpQkFBYXFCLFdBQWIsR0FBMkIsVUFBVUMsR0FBVixFQUFlO0FBQ3RDLGVBQU8sSUFBSXRCLFlBQUosQ0FBaUIsR0FBakIsRUFBc0J1QixTQUF0QixFQUFpQ0QsR0FBakMsQ0FBUDtBQUNILEtBRkQ7QUFHQTs7OztBQUlBdEIsaUJBQWF3QixjQUFiLEdBQThCLFlBQVk7QUFDdEMsZUFBT3hCLGFBQWF5QixvQkFBcEI7QUFDSCxLQUZEO0FBR0F6QixpQkFBYXlCLG9CQUFiLEdBQW9DLElBQUl6QixZQUFKLENBQWlCLEdBQWpCLENBQXBDO0FBQ0FBLGlCQUFhb0IsMEJBQWIsR0FBMEMsSUFBSXBCLFlBQUosQ0FBaUIsR0FBakIsRUFBc0J1QixTQUF0QixDQUExQztBQUNBLFdBQU92QixZQUFQO0FBQ0gsQ0E1R21CLEVBQXBCO0FBNkdBMEIsUUFBUTFCLFlBQVIsR0FBdUJBLFlBQXZCO0FBQ0EiLCJmaWxlIjoiTm90aWZpY2F0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwdXNoLWJhc2VkIGV2ZW50IG9yIHZhbHVlIHRoYXQgYW4ge0BsaW5rIE9ic2VydmFibGV9IGNhbiBlbWl0LlxuICogVGhpcyBjbGFzcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBvcGVyYXRvcnMgdGhhdCBtYW5hZ2Ugbm90aWZpY2F0aW9ucyxcbiAqIGxpa2Uge0BsaW5rIG1hdGVyaWFsaXplfSwge0BsaW5rIGRlbWF0ZXJpYWxpemV9LCB7QGxpbmsgb2JzZXJ2ZU9ufSwgYW5kXG4gKiBvdGhlcnMuIEJlc2lkZXMgd3JhcHBpbmcgdGhlIGFjdHVhbCBkZWxpdmVyZWQgdmFsdWUsIGl0IGFsc28gYW5ub3RhdGVzIGl0XG4gKiB3aXRoIG1ldGFkYXRhIG9mLCBmb3IgaW5zdGFuY2UsIHdoYXQgdHlwZSBvZiBwdXNoIG1lc3NhZ2UgaXQgaXMgKGBuZXh0YCxcbiAqIGBlcnJvcmAsIG9yIGBjb21wbGV0ZWApLlxuICpcbiAqIEBzZWUge0BsaW5rIG1hdGVyaWFsaXplfVxuICogQHNlZSB7QGxpbmsgZGVtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIG9ic2VydmVPbn1cbiAqXG4gKiBAY2xhc3MgTm90aWZpY2F0aW9uPFQ+XG4gKi9cbnZhciBOb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihraW5kLCB2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBraW5kID09PSAnTic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGl2ZXJzIHRvIHRoZSBnaXZlbiBgb2JzZXJ2ZXJgIHRoZSB2YWx1ZSB3cmFwcGVkIGJ5IHRoaXMgTm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAgICogQHJldHVyblxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5jb21wbGV0ZSAmJiBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBzb21lIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2tzLCBkZWxpdmVyIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGVcbiAgICAgKiBjdXJyZW50IE5vdGlmaWNhdGlvbiB0byB0aGUgY29ycmVjdGx5IGNvcnJlc3BvbmRpbmcgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IG5leHQgQW4gT2JzZXJ2ZXIgYG5leHRgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuZG8gPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0ICYmIG5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGUgJiYgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gT2JzZXJ2ZXIgb3IgaXRzIGluZGl2aWR1YWwgY2FsbGJhY2sgZnVuY3Rpb25zLCBhbmQgY2FsbHMgYG9ic2VydmVgXG4gICAgICogb3IgYGRvYCBtZXRob2RzIGFjY29yZGluZ2x5LlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0T3JPYnNlcnZlciBBbiBPYnNlcnZlciBvclxuICAgICAqIHRoZSBgbmV4dGAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IGFueSk6IHZvaWR9IFtlcnJvcl0gQW4gT2JzZXJ2ZXIgYGVycm9yYCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gQW4gT2JzZXJ2ZXIgYGNvbXBsZXRlYCBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgJiYgdHlwZW9mIG5leHRPck9ic2VydmVyLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ic2VydmUobmV4dE9yT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG8obmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IGp1c3QgZGVsaXZlcnMgdGhlIG5vdGlmaWNhdGlvbiByZXByZXNlbnRlZFxuICAgICAqIGJ5IHRoaXMgTm90aWZpY2F0aW9uIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLmtpbmQ7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm9mKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnRocm93KHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIG5vdGlmaWNhdGlvbiBraW5kIHZhbHVlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgbmV4dGAgZnJvbSBhXG4gICAgICogZ2l2ZW4gdmFsdWUuXG4gICAgICogQHBhcmFtIHtUfSB2YWx1ZSBUaGUgYG5leHRgIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxUPn0gVGhlIFwibmV4dFwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdOJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb3RpZmljYXRpb24udW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgZXJyb3JgIGZyb20gYVxuICAgICAqIGdpdmVuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBlcnJvci5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcImVycm9yXCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdFJywgdW5kZWZpbmVkLCBlcnIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGNvbXBsZXRlYC5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248YW55Pn0gVGhlIHZhbHVlbGVzcyBcImNvbXBsZXRlXCIgTm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbjtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ0MnKTtcbiAgICBOb3RpZmljYXRpb24udW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdOJywgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uLmpzLm1hcCJdfQ==
},{"./Observable":4}],4:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
var pipe_1 = require('./util/pipe');
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    /** @deprecated internal use only */Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) {
                return value = x;
            }, function (err) {
                return reject(err);
            }, function () {
                return resolve(value);
            });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9ic2VydmFibGUuanMiXSwibmFtZXMiOlsicm9vdF8xIiwicmVxdWlyZSIsInRvU3Vic2NyaWJlcl8xIiwib2JzZXJ2YWJsZV8xIiwicGlwZV8xIiwiT2JzZXJ2YWJsZSIsInN1YnNjcmliZSIsIl9pc1NjYWxhciIsIl9zdWJzY3JpYmUiLCJwcm90b3R5cGUiLCJsaWZ0Iiwib3BlcmF0b3IiLCJvYnNlcnZhYmxlIiwic291cmNlIiwib2JzZXJ2ZXJPck5leHQiLCJlcnJvciIsImNvbXBsZXRlIiwic2luayIsInRvU3Vic2NyaWJlciIsImNhbGwiLCJhZGQiLCJzeW5jRXJyb3JUaHJvd2FibGUiLCJfdHJ5U3Vic2NyaWJlIiwic3luY0Vycm9yVGhyb3duIiwic3luY0Vycm9yVmFsdWUiLCJlcnIiLCJmb3JFYWNoIiwibmV4dCIsIlByb21pc2VDdG9yIiwiX3RoaXMiLCJyb290IiwiUngiLCJjb25maWciLCJQcm9taXNlIiwiRXJyb3IiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3Vic2NyaXB0aW9uIiwidmFsdWUiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZXIiLCJwaXBlIiwib3BlcmF0aW9ucyIsIl9pIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicGlwZUZyb21BcnJheSIsInRvUHJvbWlzZSIsIngiLCJjcmVhdGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLGFBQVIsQ0FBYjtBQUNBLElBQUlDLGlCQUFpQkQsUUFBUSxxQkFBUixDQUFyQjtBQUNBLElBQUlFLGVBQWVGLFFBQVEscUJBQVIsQ0FBbkI7QUFDQSxJQUFJRyxTQUFTSCxRQUFRLGFBQVIsQ0FBYjtBQUNBOzs7Ozs7QUFNQSxJQUFJSSxhQUFjLFlBQVk7QUFDMUI7Ozs7Ozs7QUFPQSxhQUFTQSxVQUFULENBQW9CQyxTQUFwQixFQUErQjtBQUMzQixhQUFLQyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsWUFBSUQsU0FBSixFQUFlO0FBQ1gsaUJBQUtFLFVB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XCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG52YXIgcGlwZV8xID0gcmVxdWlyZSgnLi91dGlsL3BpcGUnKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBPYnNlcnZhYmxlIGlzXG4gICAgICogaW5pdGlhbGx5IHN1YnNjcmliZWQgdG8uIFRoaXMgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBTdWJzY3JpYmVyLCB0byB3aGljaCBuZXcgdmFsdWVzXG4gICAgICogY2FuIGJlIGBuZXh0YGVkLCBvciBhbiBgZXJyb3JgIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJhaXNlIGFuIGVycm9yLCBvclxuICAgICAqIGBjb21wbGV0ZWAgY2FuIGJlIGNhbGxlZCB0byBub3RpZnkgb2YgYSBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSwgd2l0aCB0aGlzIE9ic2VydmFibGUgYXMgdGhlIHNvdXJjZSwgYW5kIHRoZSBwYXNzZWRcbiAgICAgKiBvcGVyYXRvciBkZWZpbmVkIGFzIHRoZSBuZXcgb2JzZXJ2YWJsZSdzIG9wZXJhdG9yLlxuICAgICAqIEBtZXRob2QgbGlmdFxuICAgICAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wZXJhdG9yIHRoZSBvcGVyYXRvciBkZWZpbmluZyB0aGUgb3BlcmF0aW9uIHRvIHRha2Ugb24gdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBvYnNlcnZhYmxlIHdpdGggdGhlIE9wZXJhdG9yIGFwcGxpZWRcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhbiBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZSBhbmQgcmVnaXN0ZXJzIE9ic2VydmVyIGhhbmRsZXJzIGZvciBub3RpZmljYXRpb25zIGl0IHdpbGwgZW1pdC5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Vc2UgaXQgd2hlbiB5b3UgaGF2ZSBhbGwgdGhlc2UgT2JzZXJ2YWJsZXMsIGJ1dCBzdGlsbCBub3RoaW5nIGlzIGhhcHBlbmluZy48L3NwYW4+XG4gICAgICpcbiAgICAgKiBgc3Vic2NyaWJlYCBpcyBub3QgYSByZWd1bGFyIG9wZXJhdG9yLCBidXQgYSBtZXRob2QgdGhhdCBjYWxscyBPYnNlcnZhYmxlJ3MgaW50ZXJuYWwgYHN1YnNjcmliZWAgZnVuY3Rpb24uIEl0XG4gICAgICogbWlnaHQgYmUgZm9yIGV4YW1wbGUgYSBmdW5jdGlvbiB0aGF0IHlvdSBwYXNzZWQgdG8gYSB7QGxpbmsgY3JlYXRlfSBzdGF0aWMgZmFjdG9yeSwgYnV0IG1vc3Qgb2YgdGhlIHRpbWUgaXQgaXNcbiAgICAgKiBhIGxpYnJhcnkgaW1wbGVtZW50YXRpb24sIHdoaWNoIGRlZmluZXMgd2hhdCBhbmQgd2hlbiB3aWxsIGJlIGVtaXR0ZWQgYnkgYW4gT2JzZXJ2YWJsZS4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAgKiBgc3Vic2NyaWJlYCBpcyBhY3R1YWxseSB0aGUgbW9tZW50IHdoZW4gT2JzZXJ2YWJsZSBzdGFydHMgaXRzIHdvcmssIG5vdCB3aGVuIGl0IGlzIGNyZWF0ZWQsIGFzIGl0IGlzIG9mdGVuXG4gICAgICogdGhvdWdodC5cbiAgICAgKlxuICAgICAqIEFwYXJ0IGZyb20gc3RhcnRpbmcgdGhlIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlLCB0aGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGxpc3RlbiBmb3IgdmFsdWVzXG4gICAgICogdGhhdCBhbiBPYnNlcnZhYmxlIGVtaXRzLCBhcyB3ZWxsIGFzIGZvciB3aGVuIGl0IGNvbXBsZXRlcyBvciBlcnJvcnMuIFlvdSBjYW4gYWNoaWV2ZSB0aGlzIGluIHR3b1xuICAgICAqIGZvbGxvd2luZyB3YXlzLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHdheSBpcyBjcmVhdGluZyBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlLiBJdCBzaG91bGQgaGF2ZSBtZXRob2RzXG4gICAgICogZGVmaW5lZCBieSB0aGF0IGludGVyZmFjZSwgYnV0IG5vdGUgdGhhdCBpdCBzaG91bGQgYmUganVzdCBhIHJlZ3VsYXIgSmF2YVNjcmlwdCBvYmplY3QsIHdoaWNoIHlvdSBjYW4gY3JlYXRlXG4gICAgICogeW91cnNlbGYgaW4gYW55IHdheSB5b3Ugd2FudCAoRVM2IGNsYXNzLCBjbGFzc2ljIGZ1bmN0aW9uIGNvbnN0cnVjdG9yLCBvYmplY3QgbGl0ZXJhbCBldGMuKS4gSW4gcGFydGljdWxhciBkb1xuICAgICAqIG5vdCBhdHRlbXB0IHRvIHVzZSBhbnkgUnhKUyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRvIGNyZWF0ZSBPYnNlcnZlcnMgLSB5b3UgZG9uJ3QgbmVlZCB0aGVtLiBSZW1lbWJlciBhbHNvXG4gICAgICogdGhhdCB5b3VyIG9iamVjdCBkb2VzIG5vdCBoYXZlIHRvIGltcGxlbWVudCBhbGwgbWV0aG9kcy4gSWYgeW91IGZpbmQgeW91cnNlbGYgY3JlYXRpbmcgYSBtZXRob2QgdGhhdCBkb2Vzbid0XG4gICAgICogZG8gYW55dGhpbmcsIHlvdSBjYW4gc2ltcGx5IG9taXQgaXQuIE5vdGUgaG93ZXZlciwgdGhhdCBpZiBgZXJyb3JgIG1ldGhvZCBpcyBub3QgcHJvdmlkZWQsIGFsbCBlcnJvcnMgd2lsbFxuICAgICAqIGJlIGxlZnQgdW5jYXVnaHQuXG4gICAgICpcbiAgICAgKiBUaGUgc2Vjb25kIHdheSBpcyB0byBnaXZlIHVwIG9uIE9ic2VydmVyIG9iamVjdCBhbHRvZ2V0aGVyIGFuZCBzaW1wbHkgcHJvdmlkZSBjYWxsYmFjayBmdW5jdGlvbnMgaW4gcGxhY2Ugb2YgaXRzIG1ldGhvZHMuXG4gICAgICogVGhpcyBtZWFucyB5b3UgY2FuIHByb3ZpZGUgdGhyZWUgZnVuY3Rpb25zIGFzIGFyZ3VtZW50cyB0byBgc3Vic2NyaWJlYCwgd2hlcmUgZmlyc3QgZnVuY3Rpb24gaXMgZXF1aXZhbGVudFxuICAgICAqIG9mIGEgYG5leHRgIG1ldGhvZCwgc2Vjb25kIG9mIGFuIGBlcnJvcmAgbWV0aG9kIGFuZCB0aGlyZCBvZiBhIGBjb21wbGV0ZWAgbWV0aG9kLiBKdXN0IGFzIGluIGNhc2Ugb2YgT2JzZXJ2ZXIsXG4gICAgICogaWYgeW91IGRvIG5vdCBuZWVkIHRvIGxpc3RlbiBmb3Igc29tZXRoaW5nLCB5b3UgY2FuIG9taXQgYSBmdW5jdGlvbiwgcHJlZmVyYWJseSBieSBwYXNzaW5nIGB1bmRlZmluZWRgIG9yIGBudWxsYCxcbiAgICAgKiBzaW5jZSBgc3Vic2NyaWJlYCByZWNvZ25pemVzIHRoZXNlIGZ1bmN0aW9ucyBieSB3aGVyZSB0aGV5IHdlcmUgcGxhY2VkIGluIGZ1bmN0aW9uIGNhbGwuIFdoZW4gaXQgY29tZXNcbiAgICAgKiB0byBgZXJyb3JgIGZ1bmN0aW9uLCBqdXN0IGFzIGJlZm9yZSwgaWYgbm90IHByb3ZpZGVkLCBlcnJvcnMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlIHdpbGwgYmUgdGhyb3duLlxuICAgICAqXG4gICAgICogV2hhdGV2ZXIgc3R5bGUgb2YgY2FsbGluZyBgc3Vic2NyaWJlYCB5b3UgdXNlLCBpbiBib3RoIGNhc2VzIGl0IHJldHVybnMgYSBTdWJzY3JpcHRpb24gb2JqZWN0LlxuICAgICAqIFRoaXMgb2JqZWN0IGFsbG93cyB5b3UgdG8gY2FsbCBgdW5zdWJzY3JpYmVgIG9uIGl0LCB3aGljaCBpbiB0dXJuIHdpbGwgc3RvcCB3b3JrIHRoYXQgYW4gT2JzZXJ2YWJsZSBkb2VzIGFuZCB3aWxsIGNsZWFuXG4gICAgICogdXAgYWxsIHJlc291cmNlcyB0aGF0IGFuIE9ic2VydmFibGUgdXNlZC4gTm90ZSB0aGF0IGNhbmNlbGxpbmcgYSBzdWJzY3JpcHRpb24gd2lsbCBub3QgY2FsbCBgY29tcGxldGVgIGNhbGxiYWNrXG4gICAgICogcHJvdmlkZWQgdG8gYHN1YnNjcmliZWAgZnVuY3Rpb24sIHdoaWNoIGlzIHJlc2VydmVkIGZvciBhIHJlZ3VsYXIgY29tcGxldGlvbiBzaWduYWwgdGhhdCBjb21lcyBmcm9tIGFuIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiBSZW1lbWJlciB0aGF0IGNhbGxiYWNrcyBwcm92aWRlZCB0byBgc3Vic2NyaWJlYCBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEl0IGlzIGFuIE9ic2VydmFibGUgaXRzZWxmIHRoYXQgZGVjaWRlcyB3aGVuIHRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZC4gRm9yIGV4YW1wbGUge0BsaW5rIG9mfVxuICAgICAqIGJ5IGRlZmF1bHQgZW1pdHMgYWxsIGl0cyB2YWx1ZXMgc3luY2hyb25vdXNseS4gQWx3YXlzIGNoZWNrIGRvY3VtZW50YXRpb24gZm9yIGhvdyBnaXZlbiBPYnNlcnZhYmxlXG4gICAgICogd2lsbCBiZWhhdmUgd2hlbiBzdWJzY3JpYmVkIGFuZCBpZiBpdHMgZGVmYXVsdCBiZWhhdmlvciBjYW4gYmUgbW9kaWZpZWQgd2l0aCBhIHtAbGluayBTY2hlZHVsZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3Vic2NyaWJlIHdpdGggYW4gT2JzZXJ2ZXI8L2NhcHRpb24+XG4gICAgICogY29uc3Qgc3VtT2JzZXJ2ZXIgPSB7XG4gICAgICogICBzdW06IDAsXG4gICAgICogICBuZXh0KHZhbHVlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdBZGRpbmc6ICcgKyB2YWx1ZSk7XG4gICAgICogICAgIHRoaXMuc3VtID0gdGhpcy5zdW0gKyB2YWx1ZTtcbiAgICAgKiAgIH0sXG4gICAgICogICBlcnJvcigpIHsgLy8gV2UgYWN0dWFsbHkgY291bGQganVzdCByZW1vdmUgdGhpcyBtZXRob2QsXG4gICAgICogICB9LCAgICAgICAgLy8gc2luY2Ugd2UgZG8gbm90IHJlYWxseSBjYXJlIGFib3V0IGVycm9ycyByaWdodCBub3cuXG4gICAgICogICBjb21wbGV0ZSgpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ1N1bSBlcXVhbHM6ICcgKyB0aGlzLnN1bSk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIFJ4Lk9ic2VydmFibGUub2YoMSwgMiwgMykgLy8gU3luY2hyb25vdXNseSBlbWl0cyAxLCAyLCAzIGFuZCB0aGVuIGNvbXBsZXRlcy5cbiAgICAgKiAuc3Vic2NyaWJlKHN1bU9ic2VydmVyKTtcbiAgICAgKlxuICAgICAqIC8vIExvZ3M6XG4gICAgICogLy8gXCJBZGRpbmc6IDFcIlxuICAgICAqIC8vIFwiQWRkaW5nOiAyXCJcbiAgICAgKiAvLyBcIkFkZGluZzogM1wiXG4gICAgICogLy8gXCJTdW0gZXF1YWxzOiA2XCJcbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3Vic2NyaWJlIHdpdGggZnVuY3Rpb25zPC9jYXB0aW9uPlxuICAgICAqIGxldCBzdW0gPSAwO1xuICAgICAqXG4gICAgICogUnguT2JzZXJ2YWJsZS5vZigxLCAyLCAzKVxuICAgICAqIC5zdWJzY3JpYmUoXG4gICAgICogICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnQWRkaW5nOiAnICsgdmFsdWUpO1xuICAgICAqICAgICBzdW0gPSBzdW0gKyB2YWx1ZTtcbiAgICAgKiAgIH0sXG4gICAgICogICB1bmRlZmluZWQsXG4gICAgICogICBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ1N1bSBlcXVhbHM6ICcgKyBzdW0pO1xuICAgICAqICAgfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiAvLyBMb2dzOlxuICAgICAqIC8vIFwiQWRkaW5nOiAxXCJcbiAgICAgKiAvLyBcIkFkZGluZzogMlwiXG4gICAgICogLy8gXCJBZGRpbmc6IDNcIlxuICAgICAqIC8vIFwiU3VtIGVxdWFsczogNlwiXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNhbmNlbCBhIHN1YnNjcmlwdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnN1YnNjcmliZShcbiAgICAgKiAgIG51bSA9PiBjb25zb2xlLmxvZyhudW0pLFxuICAgICAqICAgdW5kZWZpbmVkLFxuICAgICAqICAgKCkgPT4gY29uc29sZS5sb2coJ2NvbXBsZXRlZCEnKSAvLyBXaWxsIG5vdCBiZSBjYWxsZWQsIGV2ZW5cbiAgICAgKiApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBjYW5jZWxsaW5nIHN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICpcbiAgICAgKiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgKiAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAqICAgY29uc29sZS5sb2coJ3Vuc3Vic2NyaWJlZCEnKTtcbiAgICAgKiB9LCAyNTAwKTtcbiAgICAgKlxuICAgICAqIC8vIExvZ3M6XG4gICAgICogLy8gMCBhZnRlciAxc1xuICAgICAqIC8vIDEgYWZ0ZXIgMnNcbiAgICAgKiAvLyBcInVuc3Vic2NyaWJlZCFcIiBhZnRlciAyLjVzXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8RnVuY3Rpb259IG9ic2VydmVyT3JOZXh0IChvcHRpb25hbCkgRWl0aGVyIGFuIG9ic2VydmVyIHdpdGggbWV0aG9kcyB0byBiZSBjYWxsZWQsXG4gICAgICogIG9yIHRoZSBmaXJzdCBvZiB0aHJlZSBwb3NzaWJsZSBoYW5kbGVycywgd2hpY2ggaXMgdGhlIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBmcm9tIHRoZSBzdWJzY3JpYmVkXG4gICAgICogIE9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgKG9wdGlvbmFsKSBBIGhhbmRsZXIgZm9yIGEgdGVybWluYWwgZXZlbnQgcmVzdWx0aW5nIGZyb20gYW4gZXJyb3IuIElmIG5vIGVycm9yIGhhbmRsZXIgaXMgcHJvdmlkZWQsXG4gICAgICogIHRoZSBlcnJvciB3aWxsIGJlIHRocm93biBhcyB1bmhhbmRsZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGxldGUgKG9wdGlvbmFsKSBBIGhhbmRsZXIgZm9yIGEgdGVybWluYWwgZXZlbnQgcmVzdWx0aW5nIGZyb20gc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm4ge0lTdWJzY3JpcHRpb259IGEgc3Vic2NyaXB0aW9uIHJlZmVyZW5jZSB0byB0aGUgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuICAgICAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgdmFyIHNpbmsgPSB0b1N1YnNjcmliZXJfMS50b1N1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgICAgb3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW5rLmFkZCh0aGlzLnNvdXJjZSB8fCAhc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPyB0aGlzLl9zdWJzY3JpYmUoc2luaykgOiB0aGlzLl90cnlTdWJzY3JpYmUoc2luaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIHRocm93IHNpbmsuc3luY0Vycm9yVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbms7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoc2luayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZUNvbnN0cnVjdG9yfSBbUHJvbWlzZUN0b3JdIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgUHJvbWlzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyBvbiBvYnNlcnZhYmxlIGNvbXBsZXRpb24gb3JcbiAgICAgKiAgcmVqZWN0cyB3aXRoIHRoZSBoYW5kbGVkIGVycm9yXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBQcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgZGVjbGFyZWQgaW4gYSBzZXBhcmF0ZSBzdGF0ZW1lbnQgdG8gYXZvaWQgYSBSZWZlcm5jZUVycm9yIHdoZW5cbiAgICAgICAgICAgIC8vIGFjY2Vzc2luZyBzdWJzY3JpcHRpb24gYmVsb3cgaW4gdGhlIGNsb3N1cmUgZHVlIHRvIFRlbXBvcmFsIERlYWQgWm9uZS5cbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSBjYW4gc3VybWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBoYW5kbGluZyBpcyBhc3luY2hyb25vdXMuIEFueSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgcmVqZWN0ZWQgZXhwbGljaXRseSBhbmQgdW5zdWJzY3JpYmUgbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIE5PIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSdyZSBnZXR0aW5nIGEgbmV4dGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHN5bmNocm9ub3VzbHkgZHVyaW5nIHN1YnNjcmlwdGlvbi4gV2UgY2FuIGp1c3QgY2FsbCBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCBPYnNlcnZhYmxlJ3MgYHN1YnNjcmliZWAgd2lsbCBlbnN1cmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaXB0aW9uIGxvZ2ljIGlzIGNhbGxlZCwgdGhlbiBzeW5jaHJvbm91c2x5IHJldGhyb3cgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB0aGF0LCBQcm9taXNlIHdpbGwgdHJhcCB0aGUgZXJyb3IgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0aGUgcmVqZWN0aW9uIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIGludGVybmFsIHVzZSBvbmx5ICovIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJvcCBwb2ludCBkZWZpbmVkIGJ5IHRoZSBlczctb2JzZXJ2YWJsZSBzcGVjIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhpcyBpbnN0YW5jZSBvZiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3RpdGNoIHRvZ2V0aGVyIGZ1bmN0aW9uYWwgb3BlcmF0b3JzIGludG8gYSBjaGFpbi5cbiAgICAgKiBAbWV0aG9kIHBpcGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSB0aGUgT2JzZXJ2YWJsZSByZXN1bHQgb2YgYWxsIG9mIHRoZSBvcGVyYXRvcnMgaGF2aW5nXG4gICAgICogYmVlbiBjYWxsZWQgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBwYXNzZWQgaW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogaW1wb3J0IHsgbWFwLCBmaWx0ZXIsIHNjYW4gfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG4gICAgICpcbiAgICAgKiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApXG4gICAgICogICAucGlwZShcbiAgICAgKiAgICAgZmlsdGVyKHggPT4geCAlIDIgPT09IDApLFxuICAgICAqICAgICBtYXAoeCA9PiB4ICsgeCksXG4gICAgICogICAgIHNjYW4oKGFjYywgeCkgPT4gYWNjICsgeClcbiAgICAgKiAgIClcbiAgICAgKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSlcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3BlcmF0aW9uc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlXzEucGlwZUZyb21BcnJheShvcGVyYXRpb25zKSh0aGlzKTtcbiAgICB9O1xuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB2YWx1ZSA9IHg7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmU/IHRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcCJdfQ==
},{"./symbol/observable":37,"./util/pipe":50,"./util/root":51,"./util/toSubscriber":53}],5:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
        throw err;
    },
    complete: function complete() {}
};
//# sourceMappingURL=Observer.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9ic2VydmVyLmpzIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJlbXB0eSIsImNsb3NlZCIsIm5leHQiLCJ2YWx1ZSIsImVycm9yIiwiZXJyIiwiY29tcGxldGUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBQSxRQUFRQyxLQUFSLEdBQWdCO0FBQ1pDLFlBQVEsSUFESTtBQUVaQyxVQUFNLGNBQVVDLEtBQVYsRUFBaUIsQ0FBRyxDQUZkO0FBR1pDLFdBQU8sZUFBVUMsR0FBVixFQUFlO0FBQUUsY0FBTUEsR0FBTjtBQUFZLEtBSHhCO0FBSVpDLGNBQVUsb0JBQVksQ0FBRztBQUpiLENBQWhCO0FBTUEiLCJmaWxlIjoiT2JzZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwIl19
},{}],6:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk91dGVyU3Vic2NyaWJlci5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJTdWJzY3JpYmVyXzEiLCJyZXF1aXJlIiwiT3V0ZXJTdWJzY3JpYmVyIiwiX3N1cGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJub3RpZnlOZXh0Iiwib3V0ZXJWYWx1ZSIsImlubmVyVmFsdWUiLCJvdXRlckluZGV4IiwiaW5uZXJJbmRleCIsImlubmVyU3ViIiwiZGVzdGluYXRpb24iLCJuZXh0Iiwibm90aWZ5RXJyb3IiLCJlcnJvciIsIm5vdGlmeUNvbXBsZXRlIiwiY29tcGxldGUiLCJTdWJzY3JpYmVyIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsWUFBYSxhQUFRLFVBQUtBLFNBQWQsSUFBNEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSUMsQ0FBVCxJQUFjRCxDQUFkO0FBQWlCLFlBQUlBLEVBQUVFLGNBQUYsQ0FBaUJELENBQWpCLENBQUosRUFBeUJGLEVBQUVFLENBQUYsSUFBT0QsRUFBRUMsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBU0UsRUFBVCxHQUFjO0FBQUUsYUFBS0MsV0FBTCxHQUFtQkwsQ0FBbkI7QUFBdUI7QUFDdkNBLE1BQUVNLFNBQUYsR0FBY0wsTUFBTSxJQUFOLEdBQWFNLE9BQU9DLE1BQVAsQ0FBY1AsQ0FBZCxDQUFiLElBQWlDRyxHQUFHRSxTQUFILEdBQWVMLEVBQUVLLFNBQWpCLEVBQTRCLElBQUlGLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJSyxlQUFlQyxRQUFRLGNBQVIsQ0FBbkI7QUFDQTs7Ozs7QUFLQSxJQUFJQyxrQkFBbUIsVUFBVUMsTUFBVixFQUFrQjtBQUNyQ2IsY0FBVVksZUFBVixFQUEyQkMsTUFBM0I7QUFDQSxhQUFTRCxlQUFULEdBQTJCO0FBQ3ZCQyxlQUFPQyxLQUFQLENBQWEsSUFBYixFQUFtQkMsU0FBbkI7QUFDSDtBQUNESCxvQkFBZ0JMLFNBQWhCLENBQTBCUyxVQUExQixHQUF1QyxVQUFVQyxVQUFWLEVBQXNCQyxVQUF0QixFQUFrQ0MsVUFBbEMsRUFBOENDLFVBQTlDLEVBQTBEQyxRQUExRCxFQUFvRTtBQUN2RyxhQUFLQyxXQUFMLENBQWlCQyxJQUFqQixDQUFzQkwsVUFBdEI7QUFDSCxLQUZEO0FBR0FOLG9CQUFnQkwsU0FBaEIsQ0FBMEJpQixXQUExQixHQUF3QyxVQUFVQyxLQUFWLEVBQWlCSixRQUFqQixFQUEyQjtBQUMvRCxhQUFLQyxXQUFMLENBQWlCRyxLQUFqQixDQUF1QkEsS0FBdkI7QUFDSCxLQUZEO0FBR0FiLG9CQUFnQkwsU0FBaEIsQ0FBMEJtQixjQUExQixHQUEyQyxVQUFVTCxRQUFWLEVBQW9CO0FBQzNELGFBQUtDLFdBQUwsQ0FBaUJLLFFBQWpCO0FBQ0gsS0FGRDtBQUdBLFdBQU9mLGVBQVA7QUFDSCxDQWZzQixDQWVyQkYsYUFBYWtCLFVBZlEsQ0FBdkI7QUFnQkFDLFFBQVFqQixlQUFSLEdBQTBCQSxlQUExQjtBQUNBIiwiZmlsZSI6Ik91dGVyU3Vic2NyaWJlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE91dGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE91dGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdXRlclN1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLk91dGVyU3Vic2NyaWJlciA9IE91dGVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dGVyU3Vic2NyaWJlci5qcy5tYXAiXX0=
},{"./Subscriber":9}],7:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    /** @deprecated internal use only */Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    /** @deprecated internal use only */AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlN1YmplY3QuanMiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZCIsImIiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiT2JzZXJ2YWJsZV8xIiwicmVxdWlyZSIsIlN1YnNjcmliZXJfMSIsIlN1YnNjcmlwdGlvbl8xIiwiT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSIsIlN1YmplY3RTdWJzY3JpcHRpb25fMSIsInJ4U3Vic2NyaWJlcl8xIiwiU3ViamVjdFN1YnNjcmliZXIiLCJfc3VwZXIiLCJkZXN0aW5hdGlvbiIsImNhbGwiLCJTdWJzY3JpYmVyIiwiZXhwb3J0cyIsIlN1YmplY3QiLCJvYnNlcnZlcnMiLCJjbG9zZWQiLCJpc1N0b3BwZWQiLCJoYXNFcnJvciIsInRocm93bkVycm9yIiwicnhTdWJzY3JpYmVyIiwibGlmdCIsIm9wZXJhdG9yIiwic3ViamVjdCIsIkFub255bW91c1N1YmplY3QiLCJuZXh0IiwidmFsdWUiLCJPYmplY3RVbnN1YnNjcmliZWRFcnJvciIsImxlbiIsImxlbmd0aCIsImNvcHkiLCJzbGljZSIsImkiLCJlcnJvciIsImVyciIsImNvbXBsZXRlIiwidW5zdWJzY3JpYmUiLCJfdHJ5U3Vic2NyaWJlIiwic3Vic2NyaWJlciIsIl9zdWJzY3JpYmUiLCJTdWJzY3JpcHRpb24iLCJFTVBUWSIsInB1c2giLCJTdWJqZWN0U3Vic2NyaXB0aW9uIiwiYXNPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJzb3VyY2UiLCJzdWJzY3JpYmUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlC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bEI7QUFDQSxZQUFJQSxNQUFKLEVBQVk7QUFDUixtQkFBTyxLQUFLQSxNQUFMLENBQVlDLFNBQVosQ0FBc0JWLFVBQXRCLENBQVA7QUFDSCxTQUZELE1BR0s7QUFDRCxtQkFBT2xDLGVBQWVvQyxZQUFmLENBQTRCQyxLQUFuQztBQUNIO0FBQ0osS0FSb0M7QUFTckMsV0FBT2pCLGdCQUFQO0FBQ0gsQ0FuQ3VCLENBbUN0QlYsT0FuQ3NCLENBQXhCO0FBb0NBRCxRQUFRVyxnQkFBUixHQUEyQkEsZ0JBQTNCO0FBQ0EiLCJmaWxlIjoiU3ViamVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBpbnRlcm5hbCB1c2Ugb25seSAqLyBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0O1xuLyoqXG4gKiBAY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPlxuICovXG52YXIgQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5uZXh0KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBpbnRlcm5hbCB1c2Ugb25seSAqLyBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCJdfQ==
},{"./Observable":4,"./SubjectSubscription":8,"./Subscriber":9,"./Subscription":10,"./symbol/rxSubscriber":38,"./util/ObjectUnsubscribedError":39}],8:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlN1YmplY3RTdWJzY3JpcHRpb24uanMiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZCIsImIiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiU3Vic2NyaXB0aW9uXzEiLCJyZXF1aXJlIiwiU3ViamVjdFN1YnNjcmlwdGlvbiIsIl9zdXBlciIsInN1YmplY3QiLCJzdWJzY3JpYmVyIiwiY2FsbCIsImNsb3NlZCIsInVuc3Vic2NyaWJlIiwib2JzZXJ2ZXJzIiwibGVuZ3RoIiwiaXNTdG9wcGVkIiwic3Vic2NyaWJlckluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIlN1YnNjcmlwdGlvbiIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSUssaUJBQWlCQyxRQUFRLGdCQUFSLENBQXJCO0FBQ0E7Ozs7O0FBS0EsSUFBSUMsc0JBQXVCLFVBQVVDLE1BQVYsRUFBa0I7QUFDekNiLGNBQVVZLG1CQUFWLEVBQStCQyxNQUEvQjtBQUNBLGFBQVNELG1CQUFULENBQTZCRSxPQUE3QixFQUFzQ0MsVUFBdEMsRUFBa0Q7QUFDOUNGLGVBQU9HLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBS0YsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsYUFBS0MsVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxhQUFLRSxNQUFMLEdBQWMsS0FBZDtBQUNIO0FBQ0RMLHdCQUFvQkwsU0FBcEIsQ0FBOEJXLFdBQTlCLEdBQTRDLFlBQVk7QUFDcEQsWUFBSSxLQUFLRCxNQUFULEVBQWlCO0FBQ2I7QUFDSDtBQUNELGFBQUtBLE1BQUwsR0FBYyxJQUFkO0FBQ0EsWUFBSUgsVUFBVSxLQUFLQSxPQUFuQjtBQUNBLFlBQUlLLFlBQVlMLFFBQVFLLFNBQXhCO0FBQ0EsYUFBS0wsT0FBTCxHQUFlLElBQWY7QUFDQSxZQUFJLENBQUNLLFNBQUQsSUFBY0EsVUFBVUMsTUFBVixLQUFxQixDQUFuQyxJQUF3Q04sUUFBUU8sU0FBaEQsSUFBNkRQLFFBQVFHLE1BQXpFLEVBQWlGO0FBQzdFO0FBQ0g7QUFDRCxZQUFJSyxrQkFBa0JILFVBQVVJLE9BQVYsQ0FBa0IsS0FBS1IsVUFBdkIsQ0FBdEI7QUFDQSxZQUFJTyxvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUN4Qkgsc0JBQVVLLE1BQVYsQ0FBaUJGLGVBQWpCLEVBQWtDLENBQWxDO0FBQ0g7QUFDSixLQWZEO0FBZ0JBLFdBQU9WLG1CQUFQO0FBQ0gsQ0F6QjBCLENBeUJ6QkYsZUFBZWUsWUF6QlUsQ0FBM0I7QUEwQkFDLFFBQVFkLG1CQUFSLEdBQThCQSxtQkFBOUI7QUFDQSIsImZpbGUiOiJTdWJqZWN0U3Vic2NyaXB0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgc3Vic2NyaWJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3ViamVjdFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSBzdWJqZWN0Lm9ic2VydmVycztcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMgfHwgb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCB8fCBzdWJqZWN0LmlzU3RvcHBlZCB8fCBzdWJqZWN0LmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpYmVySW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZih0aGlzLnN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpcHRpb24gPSBTdWJqZWN0U3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdFN1YnNjcmlwdGlvbi5qcy5tYXAiXX0=
},{"./Subscription":10}],9:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
                    // HACK(benlesh): To resolve an issue where Node users may have multiple
                    // copies of rxjs in their node_modules directory.
                    if (isTrustedSubscriber(destinationOrNext)) {
                        var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                        this.destination = trustedSubscriber;
                        trustedSubscriber.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    /** @deprecated internal use only */Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function wrappedComplete() {
                    return _this._complete.call(_this._context);
                };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    /** @deprecated internal use only */SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);
function isTrustedSubscriber(obj) {
    return obj instanceof Subscriber || 'syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber];
}
//# sourceMappingURL=Subscriber.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlN1YnNjcmliZXIuanMiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZCIsImIiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiaXNGdW5jdGlvbl8xIiwicmVxdWlyZSIsIlN1YnNjcmlwdGlvbl8xIiwiT2JzZXJ2ZXJfMSIsInJ4U3Vic2NyaWJlcl8xIiwiU3Vic2NyaWJlciIsIl9zdXBlciIsImRlc3RpbmF0aW9uT3JOZXh0IiwiZXJyb3IiLCJjb21wbGV0ZSIsImNhbGwiLCJzeW5jRXJyb3JWYWx1ZSIsInN5bmNFcnJvclRocm93biIsInN5bmNFcnJvclRocm93YWJsZSIsImlzU3RvcHBlZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImRlc3RpbmF0aW9uIiwiZW1wdHkiLCJpc1RydXN0ZWRTdWJzY3JpYmVyIiwidHJ1c3RlZFN1YnNjcmliZXIiLCJyeFN1YnNjcmliZXIiLCJhZGQiLCJTYWZlU3Vic2NyaWJlciIsIm5leHQiLCJzdWJzY3JpYmVyIiwidmFsdWUiLCJfbmV4dCIsImVyciIsIl9lcnJvciIsIl9jb21wbGV0ZSIsInVuc3Vic2NyaWJlIiwiY2xvc2VkIiwiX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSIsIl9hIiwiX3BhcmVudCIsIl9wYXJlbnRzIiwiU3Vic2NyaXB0aW9uIiwiZXhwb3J0cyIsIl9wYXJlbnRTdWJzY3JpYmVyIiwib2JzZXJ2ZXJPck5leHQiLCJjb250ZXh0IiwiaXNGdW5jdGlvbiIsImJpbmQiLCJfY29udGV4dCIsIl9fdHJ5T3JVbnN1YiIsIl9fdHJ5T3JTZXRFcnJvciIsIl90aGlzIiwid3JhcHBlZENvbXBsZXRlIiwiZm4iLCJwYXJlbnQiLCJfdW5zdWJzY3JpYmUiLCJvYmoiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBQ0EsSUFBSUEsWUFBYSxhQUFRLFVBQUtBLFNBQWQsSUFBNEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3hELFNB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XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSEFDSyhiZW5sZXNoKTogVG8gcmVzb2x2ZSBhbiBpc3N1ZSB3aGVyZSBOb2RlIHVzZXJzIG1heSBoYXZlIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcGllcyBvZiByeGpzIGluIHRoZWlyIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RydXN0ZWRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRydXN0ZWRTdWJzY3JpYmVyID0gZGVzdGluYXRpb25Pck5leHRbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVzdGVkU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gdHJ1c3RlZFN1YnNjcmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVzdGVkU3Vic2NyaWJlci5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgaW50ZXJuYWwgdXNlIG9ubHkgKi8gU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBfcGFyZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnRTdWJzY3JpYmVyLCBvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlck9yTmV4dCAhPT0gT2JzZXJ2ZXJfMS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG9ic2VydmVyT3JOZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5fbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fbmV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY29tcGxldGUuY2FsbChfdGhpcy5fY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIod3JhcHBlZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHdyYXBwZWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIGludGVybmFsIHVzZSBvbmx5ICovIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgX3BhcmVudFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gaXNUcnVzdGVkU3Vic2NyaWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgU3Vic2NyaWJlciB8fCAoJ3N5bmNFcnJvclRocm93YWJsZScgaW4gb2JqICYmIG9ialtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwIl19
},{"./Observer":5,"./Subscription":10,"./symbol/rxSubscriber":38,"./util/isFunction":45}],10:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}
//# sourceMappingURL=Subscription.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlN1YnNjcmlwdGlvbi5qcyJdLCJuYW1lcyI6WyJpc0FycmF5XzEiLCJyZXF1aXJlIiwiaXNPYmplY3RfMSIsImlzRnVuY3Rpb25fMSIsInRyeUNhdGNoXzEiLCJlcnJvck9iamVjdF8xIiwiVW5zdWJzY3JpcHRpb25FcnJvcl8xIiwiU3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJjbG9zZWQiLCJfcGFyZW50IiwiX3BhcmVudHMiLCJfc3Vic2NyaXB0aW9ucyIsIl91bnN1YnNjcmliZSIsInByb3RvdHlwZSIsImhhc0Vycm9ycyIsImVycm9ycyIsIl9hIiwiaW5kZXgiLCJsZW4iLCJsZW5ndGgiLCJyZW1vdmUiLCJpc0Z1bmN0aW9uIiwidHJpYWwiLCJ0cnlDYXRjaCIsImNhbGwiLCJlcnJvck9iamVjdCIsImUiLCJVbnN1YnNjcmlwdGlvbkVycm9yIiwiZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzIiwiaXNBcnJheSIsInN1YiIsImlzT2JqZWN0IiwiZXJyIiwiY29uY2F0IiwicHVzaCIsImFkZCIsInRlYXJkb3duIiwiRU1QVFkiLCJzdWJzY3JpcHRpb24iLCJfYWRkUGFyZW50IiwidG1wIiwiRXJyb3IiLCJzdWJzY3JpcHRpb25zIiwic3Vic2NyaXB0aW9uSW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicGFyZW50IiwiZW1wdHkiLCJleHBvcnRzIiwicmVkdWNlIiwiZXJycyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFDQSxJQUFJQSxZQUFZQyxRQUFRLGdCQUFSLENBQWhCO0FBQ0EsSUFBSUMsYUFBYUQsUUFBUSxpQkFBUixDQUFqQjtBQUNBLElBQUlFLGVBQWVGLFFBQVEsbUJBQVIsQ0FBbkI7QUFDQSxJQUFJRyxhQUFhSCxRQUFRLGlCQUFSLENBQWpCO0FBQ0EsSUFBSUksZ0JBQWdCSixRQUFRLG9CQUFSLENBQXBCO0FBQ0EsSUFBSUssd0JBQXdCTCxRQUFRLDRCQUFSLENBQTVCO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBLElBQUlNLGVBQWdC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QVA7QUFDSCxLQUhxQixDQUdwQixJQUFJekMsWUFBSixFQUhvQixDQUF0QjtBQUlBLFdBQU9BLFlBQVA7QUFDSCxDQXhLbUIsRUFBcEI7QUF5S0EwQyxRQUFRMUMsWUFBUixHQUF1QkEsWUFBdkI7QUFDQSxTQUFTc0IsMkJBQVQsQ0FBcUNiLE1BQXJDLEVBQTZDO0FBQ3pDLFdBQU9BLE9BQU9rQyxNQUFQLENBQWMsVUFBVUMsSUFBVixFQUFnQmxCLEdBQWhCLEVBQXFCO0FBQUUsZUFBT2tCLEtBQUtqQixNQUFMLENBQWFELGVBQWUzQixzQkFBc0JzQixtQkFBdEMsR0FBNkRLLElBQUlqQixNQUFqRSxHQUEwRWlCLEdBQXRGLENBQVA7QUFBb0csS0FBekksRUFBMkksRUFBM0ksQ0FBUDtBQUNIO0FBQ0QiLCJmaWxlIjoiU3Vic2NyaXB0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2lzT2JqZWN0Jyk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlLCBzdWNoIGFzIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZS4gQVxuICogU3Vic2NyaXB0aW9uIGhhcyBvbmUgaW1wb3J0YW50IG1ldGhvZCwgYHVuc3Vic2NyaWJlYCwgdGhhdCB0YWtlcyBubyBhcmd1bWVudFxuICogYW5kIGp1c3QgZGlzcG9zZXMgdGhlIHJlc291cmNlIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHN1YnNjcmlwdGlvbnMgbWF5IGJlIGdyb3VwZWQgdG9nZXRoZXIgdGhyb3VnaCB0aGUgYGFkZCgpYFxuICogbWV0aG9kLCB3aGljaCB3aWxsIGF0dGFjaCBhIGNoaWxkIFN1YnNjcmlwdGlvbiB0byB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24uXG4gKiBXaGVuIGEgU3Vic2NyaXB0aW9uIGlzIHVuc3Vic2NyaWJlZCwgYWxsIGl0cyBjaGlsZHJlbiAoYW5kIGl0cyBncmFuZGNoaWxkcmVuKVxuICogd2lsbCBiZSB1bnN1YnNjcmliZWQgYXMgd2VsbC5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXG4gKi9cbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW3Vuc3Vic2NyaWJlXSBBIGZ1bmN0aW9uIGRlc2NyaWJpbmcgaG93IHRvXG4gICAgICogcGVyZm9ybSB0aGUgZGlzcG9zYWwgb2YgcmVzb3VyY2VzIHdoZW4gdGhlIGB1bnN1YnNjcmliZWAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgU3Vic2NyaXB0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdW5zdWJzY3JpYmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiBNYXksIGZvciBpbnN0YW5jZSwgY2FuY2VsXG4gICAgICogYW4gb25nb2luZyBPYnNlcnZhYmxlIGV4ZWN1dGlvbiBvciBjYW5jZWwgYW55IG90aGVyIHR5cGUgb2Ygd29yayB0aGF0XG4gICAgICogc3RhcnRlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gd2FzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzLCBfdW5zdWJzY3JpYmUgPSBfYS5fdW5zdWJzY3JpYmUsIF9zdWJzY3JpcHRpb25zID0gX2EuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIC8vIG51bGwgb3V0IF9zdWJzY3JpcHRpb25zIGZpcnN0IHNvIGFueSBjaGlsZCBzdWJzY3JpcHRpb25zIHRoYXQgYXR0ZW1wdFxuICAgICAgICAvLyB0byByZW1vdmUgdGhlbXNlbHZlcyBmcm9tIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGwgbm9vcFxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBsZW4gPSBfcGFyZW50cyA/IF9wYXJlbnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIC8vIGlmIHRoaXMuX3BhcmVudCBpcyBudWxsLCB0aGVuIHNvIGlzIHRoaXMuX3BhcmVudHMsIGFuZCB3ZVxuICAgICAgICAvLyBkb24ndCBoYXZlIHRvIHJlbW92ZSBvdXJzZWx2ZXMgZnJvbSBhbnkgcGFyZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICAgIHdoaWxlIChfcGFyZW50KSB7XG4gICAgICAgICAgICBfcGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMuX3BhcmVudHMgaXMgbnVsbCBvciBpbmRleCA+PSBsZW4sXG4gICAgICAgICAgICAvLyB0aGVuIF9wYXJlbnQgaXMgc2V0IHRvIG51bGwsIGFuZCB0aGUgbG9vcCBleGl0c1xuICAgICAgICAgICAgX3BhcmVudCA9ICsraW5kZXggPCBsZW4gJiYgX3BhcmVudHNbaW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKF91bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goX3Vuc3Vic2NyaWJlKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZS5lcnJvcnMpIDogW2Vycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0XzEuaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHN1Yi51bnN1YnNjcmliZSkuY2FsbChzdWIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyLmVycm9ycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRlYXIgZG93biB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSgpIG9mIHRoaXNcbiAgICAgKiBTdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGVhciBkb3duIGJlaW5nIGFkZGVkIGlzIGEgc3Vic2NyaXB0aW9uIHRoYXQgaXMgYWxyZWFkeVxuICAgICAqIHVuc3Vic2NyaWJlZCwgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGBhZGRgIGlzIGJlaW5nIGNhbGxlZCBvbiwgb3IgaXNcbiAgICAgKiBgU3Vic2NyaXB0aW9uLkVNUFRZYCwgaXQgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHN1YnNjcmlwdGlvbiBpcyBhbHJlYWR5IGluIGFuIGBjbG9zZWRgIHN0YXRlLCB0aGUgcGFzc2VkXG4gICAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RlYXJkb3duTG9naWN9IHRlYXJkb3duIFRoZSBhZGRpdGlvbmFsIGxvZ2ljIHRvIGV4ZWN1dGUgb25cbiAgICAgKiB0ZWFyZG93bi5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IFJldHVybnMgdGhlIFN1YnNjcmlwdGlvbiB1c2VkIG9yIGNyZWF0ZWQgdG8gYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgaW5uZXIgc3Vic2NyaXB0aW9ucyBsaXN0LiBUaGlzIFN1YnNjcmlwdGlvbiBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICogbGlzdC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICBpZiAoIXRlYXJkb3duIHx8ICh0ZWFyZG93biA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVhcmRvd24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0ZWFyZG93bjtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jbG9zZWQgfHwgdHlwZW9mIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbi5fYWRkUGFyZW50ICE9PSAnZnVuY3Rpb24nIC8qIHF1YWNrIHF1YWNrICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl9zdWJzY3JpcHRpb25zID0gW3RtcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCB0ZWFyZG93biAnICsgdGVhcmRvd24gKyAnIGFkZGVkIHRvIFN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnMgfHwgKHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbXSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgICAqIHVuc3Vic2NyaWJlIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUgcHJvY2VzcyBvZiB0aGlzIFN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fYWRkUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgaWYgKCFfcGFyZW50IHx8IF9wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudCwgb3IgdGhlIG5ldyBwYXJlbnQgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHBhcmVudCwgdGhlbiBzZXQgdGhpcy5fcGFyZW50IHRvIHRoZSBuZXcgcGFyZW50LlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFfcGFyZW50cykge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbHJlYWR5IG9uZSBwYXJlbnQsIGJ1dCBub3QgbXVsdGlwbGUsIGFsbG9jYXRlIGFuIEFycmF5IHRvXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgcmVzdCBvZiB0aGUgcGFyZW50IFN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRzID0gW3BhcmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3BhcmVudHMuaW5kZXhPZihwYXJlbnQpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gT25seSBhZGQgdGhlIG5ldyBwYXJlbnQgdG8gdGhlIF9wYXJlbnRzIGxpc3QgaWYgaXQncyBub3QgYWxyZWFkeSB0aGVyZS5cbiAgICAgICAgICAgIF9wYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLkVNUFRZID0gKGZ1bmN0aW9uIChlbXB0eSkge1xuICAgICAgICBlbXB0eS5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfShuZXcgU3Vic2NyaXB0aW9uKCkpKTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHsgcmV0dXJuIGVycnMuY29uY2F0KChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikgPyBlcnIuZXJyb3JzIDogZXJyKTsgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCJdfQ==
},{"./util/UnsubscriptionError":41,"./util/errorObject":42,"./util/isArray":43,"./util/isFunction":45,"./util/isObject":46,"./util/tryCatch":54}],11:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var from_1 = require('../../observable/from');
Observable_1.Observable.from = from_1.from;
//# sourceMappingURL=from.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZyb20uanMiXSwibmFtZXMiOlsiT2JzZXJ2YWJsZV8xIiwicmVxdWlyZSIsImZyb21fMSIsIk9ic2VydmFibGUiLCJmcm9tIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxlQUFlQyxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSUMsU0FBU0QsUUFBUSx1QkFBUixDQUFiO0FBQ0FELGFBQWFHLFVBQWIsQ0FBd0JDLElBQXhCLEdBQStCRixPQUFPRSxJQUF0QztBQUNBIiwiZmlsZSI6ImZyb20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbV8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9mcm9tJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mcm9tID0gZnJvbV8xLmZyb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tLmpzLm1hcCJdfQ==
},{"../../Observable":4,"../../observable/from":25}],12:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var fromPromise_1 = require('../../observable/fromPromise');
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
//# sourceMappingURL=fromPromise.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZyb21Qcm9taXNlLmpzIl0sIm5hbWVzIjpbIk9ic2VydmFibGVfMSIsInJlcXVpcmUiLCJmcm9tUHJvbWlzZV8xIiwiT2JzZXJ2YWJsZSIsImZyb21Qcm9taXNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxlQUFlQyxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSUMsZ0JBQWdCRCxRQUFRLDhCQUFSLENBQXBCO0FBQ0FELGFBQWFHLFVBQWIsQ0FBd0JDLFdBQXhCLEdBQXNDRixjQUFjRSxXQUFwRDtBQUNBIiwiZmlsZSI6ImZyb21Qcm9taXNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZyb21Qcm9taXNlXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZSA9IGZyb21Qcm9taXNlXzEuZnJvbVByb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tUHJvbWlzZS5qcy5tYXAiXX0=
},{"../../Observable":4,"../../observable/fromPromise":26}],13:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var distinct_1 = require('../../operator/distinct');
Observable_1.Observable.prototype.distinct = distinct_1.distinct;
//# sourceMappingURL=distinct.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRpc3RpbmN0LmpzIl0sIm5hbWVzIjpbIk9ic2VydmFibGVfMSIsInJlcXVpcmUiLCJkaXN0aW5jdF8xIiwiT2JzZXJ2YWJsZSIsInByb3RvdHlwZSIsImRpc3RpbmN0Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxlQUFlQyxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSUMsYUFBYUQsUUFBUSx5QkFBUixDQUFqQjtBQUNBRCxhQUFhRyxVQUFiLENBQXdCQyxTQUF4QixDQUFrQ0MsUUFBbEMsR0FBNkNILFdBQVdHLFFBQXhEO0FBQ0EiLCJmaWxlIjoiZGlzdGluY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGlzdGluY3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2Rpc3RpbmN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzdGluY3QgPSBkaXN0aW5jdF8xLmRpc3RpbmN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3QuanMubWFwIl19
},{"../../Observable":4,"../../operator/distinct":27}],14:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var filter_1 = require('../../operator/filter');
Observable_1.Observable.prototype.filter = filter_1.filter;
//# sourceMappingURL=filter.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbHRlci5qcyJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlXzEiLCJyZXF1aXJlIiwiZmlsdGVyXzEiLCJPYnNlcnZhYmxlIiwicHJvdG90eXBlIiwiZmlsdGVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxlQUFlQyxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSUMsV0FBV0QsUUFBUSx1QkFBUixDQUFmO0FBQ0FELGFBQWFHLFVBQWIsQ0FBd0JDLFNBQXhCLENBQWtDQyxNQUFsQyxHQUEyQ0gsU0FBU0csTUFBcEQ7QUFDQSIsImZpbGUiOiJmaWx0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9maWx0ZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5maWx0ZXIgPSBmaWx0ZXJfMS5maWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl19
},{"../../Observable":4,"../../operator/filter":28}],15:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hcC5qcyJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlXzEiLCJyZXF1aXJlIiwibWFwXzEiLCJPYnNlcnZhYmxlIiwicHJvdG90eXBlIiwibWFwIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxlQUFlQyxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSUMsUUFBUUQsUUFBUSxvQkFBUixDQUFaO0FBQ0FELGFBQWFHLFVBQWIsQ0FBd0JDLFNBQXhCLENBQWtDQyxHQUFsQyxHQUF3Q0gsTUFBTUcsR0FBOUM7QUFDQSIsImZpbGUiOiJtYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAgPSBtYXBfMS5tYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIl19
},{"../../Observable":4,"../../operator/map":29}],16:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var mergeMap_1 = require('../../operator/mergeMap');
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
//# sourceMappingURL=mergeMap.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1lcmdlTWFwLmpzIl0sIm5hbWVzIjpbIk9ic2VydmFibGVfMSIsInJlcXVpcmUiLCJtZXJnZU1hcF8xIiwiT2JzZXJ2YWJsZSIsInByb3RvdHlwZSIsIm1lcmdlTWFwIiwiZmxhdE1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsZUFBZUMsUUFBUSxrQkFBUixDQUFuQjtBQUNBLElBQUlDLGFBQWFELFFBQVEseUJBQVIsQ0FBakI7QUFDQUQsYUFBYUcsVUFBYixDQUF3QkMsU0FBeEIsQ0FBa0NDLFFBQWxDLEdBQTZDSCxXQUFXRyxRQUF4RDtBQUNBTCxhQUFhRyxVQUFiLENBQXdCQyxTQUF4QixDQUFrQ0UsT0FBbEMsR0FBNENKLFdBQVdHLFFBQXZEO0FBQ0EiLCJmaWxlIjoibWVyZ2VNYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlTWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VNYXAgPSBtZXJnZU1hcF8xLm1lcmdlTWFwO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZsYXRNYXAgPSBtZXJnZU1hcF8xLm1lcmdlTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXAuanMubWFwIl19
},{"../../Observable":4,"../../operator/mergeMap":30}],17:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        } else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        } else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike,
            index = state.index,
            length = state.length,
            subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    /** @deprecated internal use only */ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            arrayLike = _a.arrayLike,
            scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable);
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFycmF5TGlrZU9ic2VydmFibGUuanMiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZCIsImIiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiT2JzZXJ2YWJsZV8xIiwicmVxdWlyZSIsIlNjYWxhck9ic2VydmFibGVfMSIsIkVtcHR5T2JzZXJ2YWJsZV8xIiwiQXJyYXlMaWtlT2JzZXJ2YWJsZSIsIl9zdXBlciIsImFycmF5TGlrZSIsInNjaGVkdWxlciIsImNhbGwiLCJsZW5ndGgiLCJfaXNTY2FsYXIiLCJ2YWx1ZSIsIkVtcHR5T2JzZXJ2YWJsZSIsIlNjYWxhck9ic2VydmFibGUiLCJkaXNwYXRjaCIsInN0YXRlIiwiaW5kZXgiLCJzdWJzY3JpYmVyIiwiY2xvc2VkIiwiY29tcGxldGUiLCJuZXh0Iiwic2NoZWR1bGUiLCJfc3Vic2NyaWJlIiwiX2EiLCJpIiwiT2JzZXJ2YWJsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSUssZUFBZUMsUUFBUSxlQUFSLENBQW5C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aWtlT2JzZXJ2YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlMaWtlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5TGlrZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlMaWtlT2JzZXJ2YWJsZShhcnJheUxpa2UsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheUxpa2UgPSBhcnJheUxpa2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheUxpa2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gYXJyYXlMaWtlWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5TGlrZU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5TGlrZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheUxpa2VbMF0sIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5TGlrZU9ic2VydmFibGUoYXJyYXlMaWtlLCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcnJheUxpa2VPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBhcnJheUxpa2UgPSBzdGF0ZS5hcnJheUxpa2UsIGluZGV4ID0gc3RhdGUuaW5kZXgsIGxlbmd0aCA9IHN0YXRlLmxlbmd0aCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlMaWtlW2luZGV4XSk7XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBpbnRlcm5hbCB1c2Ugb25seSAqLyBBcnJheUxpa2VPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYXJyYXlMaWtlID0gX2EuYXJyYXlMaWtlLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEFycmF5TGlrZU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheUxpa2U6IGFycmF5TGlrZSwgaW5kZXg6IGluZGV4LCBsZW5ndGg6IGxlbmd0aCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheUxpa2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlMaWtlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQXJyYXlMaWtlT2JzZXJ2YWJsZSA9IEFycmF5TGlrZU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheUxpa2VPYnNlcnZhYmxlLmpzLm1hcCJdfQ==
},{"../Observable":4,"./EmptyObservable":19,"./ScalarObservable":23}],18:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    /** @deprecated internal use only */ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFycmF5T2JzZXJ2YWJsZS5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJPYnNlcnZhYmxlXzEiLCJyZXF1aXJlIiwiU2NhbGFyT2JzZXJ2YWJsZV8xIiwiRW1wdHlPYnNlcnZhYmxlXzEiLCJpc1NjaGVkdWxlcl8xIiwiQXJyYXlPYnNlcnZhYmxlIiwiX3N1cGVyIiwiYXJyYXkiLCJzY2hlZHVsZXIiLCJjYWxsIiwibGVuZ3RoIiwiX2lzU2NhbGFyIiwidmFsdWUiLCJvZiIsIl9pIiwiYXJndW1lbnRzIiwiaXNTY2hlZHVsZXIiLCJwb3AiLCJsZW4iLCJTY2FsYXJPYnNlcnZhYmxlIiwiRW1wdHlPYnNlcnZhYmxlIiwiZGlzcGF0Y2giLCJzdGF0ZSIsImluZGV4IiwiY291bnQiLCJzdWJzY3JpYmVyIiwiY29tcGxldGUiLCJuZXh0IiwiY2xvc2VkIiwic2NoZWR1bGUiLCJfc3Vic2NyaWJlIiwiaSIsIk9ic2VydmFibGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxZQUFhLGFBQVEsVUFBS0EsU0FBZCxJQUE0QixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJQyxDQUFULElBQWNELENBQWQ7QUFBaUIsWUFBSUEsRUFBRUUsY0FBRixDQUFpQkQsQ0FBakIsQ0FBSixFQUF5QkYsRUFBRUUsQ0FBRixJQUFPRCxFQUFFQyxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTRSxFQUFULEdBQWM7QUFBRSxhQUFLQyxXQUFMLEdBQW1CTCxDQUFuQjtBQUF1QjtBQUN2Q0EsTUFBRU0sU0FBRixHQUFjTCxNQUFNLElBQU4sR0FBYU0sT0FBT0MsTUFBUCxDQUFjUCxDQUFkLENBQWIsSUFBaUNHLEdBQUdFLFNBQUgsR0FBZUwsRUFBRUssU0FBakIsRUFBNEIsSUFBSUYsRUFB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LFFBQVFqQixNQUFNRyxNQUFsQjtBQUNBLFlBQUlGLFlBQVksS0FBS0EsU0FBckI7QUFDQSxZQUFJQSxTQUFKLEVBQWU7QUFDWCxtQkFBT0EsVUFBVXFCLFFBQVYsQ0FBbUJ4QixnQkFBZ0JnQixRQUFuQyxFQUE2QyxDQUE3QyxFQUFnRDtBQUNuRGQsdUJBQU9BLEtBRDRDLEVBQ3JDZ0IsT0FBT0EsS0FEOEIsRUFDdkJDLE9BQU9BLEtBRGdCLEVBQ1RDLFlBQVlBO0FBREgsYUFBaEQsQ0FBUDtBQUdILFNBSkQsTUFLSztBQUNELGlCQUFLLElBQUlNLElBQUksQ0FBYixFQUFnQkEsSUFBSVAsS0FBSixJQUFhLENBQUNDLFdBQVdHLE1BQXpDLEVBQWlERyxHQUFqRCxFQUFzRDtBQUNsRE4sMkJBQVdFLElBQVgsQ0FBZ0JwQixNQUFNd0IsQ0FBTixDQUFoQjtBQUNIO0FBQ0ROLHVCQUFXQyxRQUFYO0FBQ0g7QUFDSixLQWhCb0M7QUFpQnJDLFdBQU9yQixlQUFQO0FBQ0gsQ0F4R3NCLENBd0dyQkwsYUFBYWdDLFVBeEdRLENBQXZCO0FBeUdBQyxRQUFRNUIsZUFBUixHQUEwQkEsZUFBMUI7QUFDQSIsImZpbGUiOiJBcnJheU9ic2VydmFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgICAqIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgc3luY2hyb25vdXNseSwgYWx0aG91Z2ggd2l0aCBhIGRpZmZlcmVudCBJU2NoZWR1bGVyXG4gICAgICogaXQgaXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZW4gdGhvc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlIGRlbGl2ZXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgMTAsIDIwLCAzMCwgdGhlbiAnYScsICdiJywgJ2MnLCB0aGVuIHN0YXJ0IHRpY2tpbmcgZXZlcnkgc2Vjb25kLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUub2YoMTAsIDIwLCAzMCk7XG4gICAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IG51bWJlcnMuY29uY2F0KGxldHRlcnMpLmNvbmNhdChpbnRlcnZhbCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIEFyZ3VtZW50cyB0aGF0IHJlcHJlc2VudCBgbmV4dGAgdmFsdWVzIHRvIGJlIGVtaXR0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgaW50ZXJuYWwgdXNlIG9ubHkgKi8gQXJyYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIGNvdW50ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoQXJyYXlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgYXJyYXk6IGFycmF5LCBpbmRleDogaW5kZXgsIGNvdW50OiBjb3VudCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFycmF5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQXJyYXlPYnNlcnZhYmxlID0gQXJyYXlPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlPYnNlcnZhYmxlLmpzLm1hcCJdfQ==
},{"../Observable":4,"../util/isScheduler":48,"./EmptyObservable":19,"./ScalarObservable":23}],19:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    /** @deprecated internal use only */EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkVtcHR5T2JzZXJ2YWJsZS5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJPYnNlcnZhYmxlXzEiLCJyZXF1aXJlIiwiRW1wdHlPYnNlcnZhYmxlIiwiX3N1cGVyIiwic2NoZWR1bGVyIiwiY2FsbCIsImRpc3BhdGNoIiwiYXJnIiwic3Vic2NyaWJlciIsImNvbXBsZXRlIiwiX3N1YnNjcmliZSIsInNjaGVkdWxlIiwiT2JzZXJ2YWJsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSUssZUFBZUMsUUFBUSxlQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSUMsa0JBQW1CLFVBQVVDLE1BQVYsRUFBa0I7QUFDckNiLGNBQVVZLGVBQVYsRUFBMkJDLE1BQTNCO0FBQ0EsYUFBU0QsZUFBVCxDQUF5QkUsU0FBekIsRUFBb0M7QUFDaENELGVBQU9FLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBS0QsU0FBTCxHQUFpQkEsU0FBakI7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBRixvQkFBZ0JILE1BQWhCLEdBQXlCLFVBQVVLLFNBQVYsRUFBcUI7QUFDMUMsZUFBTyxJQUFJRixlQUFKLENBQW9CRSxTQUFwQixDQUFQO0FBQ0gsS0FGRDtBQUdBRixvQkFBZ0JJLFFBQWhCLEdBQTJCLFVBQVVDLEdBQVYsRUFBZTtBQUN0QyxZQUFJQyxhQUFhRCxJQUFJQyxVQUFyQjtBQUNBQSxtQkFBV0MsUUFBWDtBQUNILEtBSEQ7QUFJQSx3Q0FBcUNQLGdCQUFnQkwsU0FBaEIsQ0FBMEJhLFVBQTFCLEdBQXVDLFVBQVVGLFVBQVYsRUFBc0I7QUFDOUYsWUFBSUosWUFBWSxLQUFLQSxTQUFyQjtBQUNBLFlBQUlBLFNBQUosRUFBZTtBQUNYLG1CQUFPQSxVQUFVTyxRQUFWLENBQW1CVCxnQkFBZ0JJLFFBQW5DLEVBQTZDLENBQTdDLEVBQWdELEVBQUVFLFlBQVlBLFVBQWQsRUFBaEQsQ0FBUDtBQUNILFNBRkQsTUFHSztBQUNEQSx1QkFBV0MsUUFBWDtBQUNIO0FBQ0osS0FSb0M7QUFTckMsV0FBT1AsZUFBUDtBQUNILENBbEVzQixDQWtFckJGLGFBQWFZLFVBbEVRLENBQXZCO0FBbUVBQyxRQUFRWCxlQUFSLEdBQTBCQSxlQUExQjtBQUNBIiwiZmlsZSI6IkVtcHR5T2JzZXJ2YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdjb21wbGV0ZScsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9lbXB0eS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBjb21wbGV0ZS48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBvbmx5IG9kZCBudW1iZXJzIHRvIHRoZSBzZXF1ZW5jZSAnYScsICdiJywgJ2MnPC9jYXB0aW9uPlxuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IGludGVydmFsLm1lcmdlTWFwKHggPT5cbiAgICAgKiAgIHggJSAyID09PSAxID8gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKSA6IFJ4Lk9ic2VydmFibGUuZW1wdHkoKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyB0byB0aGUgY29uc29sZTpcbiAgICAgKiAvLyB4IGlzIGVxdWFsIHRvIHRoZSBjb3VudCBvbiB0aGUgaW50ZXJ2YWwgZWcoMCwxLDIsMywuLi4pXG4gICAgICogLy8geCB3aWxsIG9jY3VyIGV2ZXJ5IDEwMDBtc1xuICAgICAqIC8vIGlmIHggJSAyIGlzIGVxdWFsIHRvIDEgcHJpbnQgYWJjXG4gICAgICogLy8gaWYgeCAlIDIgaXMgbm90IGVxdWFsIHRvIDEgbm90aGluZyB3aWxsIGJlIG91dHB1dFxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIFwiZW1wdHlcIiBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBjb21wbGV0ZVxuICAgICAqIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBlbXB0eVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRW1wdHlPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIGludGVybmFsIHVzZSBvbmx5ICovIEVtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShFbXB0eU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRW1wdHlPYnNlcnZhYmxlID0gRW1wdHlPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1wdHlPYnNlcnZhYmxlLmpzLm1hcCJdfQ==
},{"../Observable":4}],20:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = require('../util/isArray');
var isArrayLike_1 = require('../util/isArrayLike');
var isPromise_1 = require('../util/isPromise');
var PromiseObservable_1 = require('./PromiseObservable');
var IteratorObservable_1 = require('./IteratorObservable');
var ArrayObservable_1 = require('./ArrayObservable');
var ArrayLikeObservable_1 = require('./ArrayLikeObservable');
var iterator_1 = require('../symbol/iterator');
var Observable_1 = require('../Observable');
var observeOn_1 = require('../operators/observeOn');
var observable_1 = require('../symbol/observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            } else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            } else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            } else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            } else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && (typeof ish === 'undefined' ? 'undefined' : _typeof(ish)) || ish) + ' is not observable');
    };
    /** @deprecated internal use only */FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        } else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable);
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkZyb21PYnNlcnZhYmxlLmpzIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImlzQXJyYXlfMSIsInJlcXVpcmUiLCJpc0FycmF5TGlrZV8xIiwiaXNQcm9taXNlXzEiLCJQcm9taXNlT2JzZXJ2YWJsZV8xIiwiSXRlcmF0b3JPYnNlcnZhYmxlXzEiLCJBcnJheU9ic2VydmFibGVfMSIsIkFycmF5TGlrZU9ic2VydmFibGVfMSIsIml0ZXJhdG9yXzEiLCJPYnNlcnZhYmxlXzEiLCJvYnNlcnZlT25fMSIsIm9ic2VydmFibGVfMSIsIkZyb21PYnNlcnZhYmxlIiwiX3N1cGVyIiwiaXNoIiwic2NoZWR1bGVyIiwiY2FsbCIsIm9ic2VydmFibGUiLCJPYnNlcnZhYmxlIiwiaXNBcnJheSIsIkFycmF5T2JzZXJ2YWJsZSIsImlzUHJvbWlzZSIsIlByb21pc2VPYnNlcnZhYmxlIiwiaXRlcmF0b3IiLCJJdGVyYXRvck9ic2VydmFibGUiLCJpc0FycmF5TGlrZSIsIkFycmF5TGlrZU9ic2VydmFibGUiLCJUeXBlRXJyb3IiLCJfc3Vic2NyaWJlIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsIk9ic2VydmVPblN1YnNjcmliZXIiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxN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LEdBQWY7QUFDQSxZQUFJQyxZQUFZLEtBQUtBLFNBQXJCO0FBQ0EsWUFBSUEsYUFBYSxJQUFqQixFQUF1QjtBQUNuQixtQkFBT0QsSUFBSUgsYUFBYU0sVUFBakIsSUFBK0JhLFNBQS9CLENBQXlDRCxVQUF6QyxDQUFQO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsbUJBQU9mLElBQUlILGFBQWFNLFVBQWpCLElBQStCYSxTQUEvQixDQUF5QyxJQUFJcEIsWUFBWXFCLG1CQUFoQixDQUFvQ0YsVUFBcEMsRUFBZ0RkLFNBQWhELEVBQTJELENBQTNELENBQXpDLENBQVA7QUFDSDtBQUNKLEtBVG9DO0FBVXJDLFdBQU9ILGNBQVA7QUFDSCxDQWpHcUIsQ0FpR3BCSCxhQUFhUyxVQWpHTyxDQUF0QjtBQWtHQWMsUUFBUXBCLGNBQVIsR0FBeUJBLGNBQXpCO0FBQ0EiLCJmaWxlIjoiRnJvbU9ic2VydmFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIGlzQXJyYXlMaWtlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXlMaWtlJyk7XG52YXIgaXNQcm9taXNlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzUHJvbWlzZScpO1xudmFyIFByb21pc2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1Byb21pc2VPYnNlcnZhYmxlJyk7XG52YXIgSXRlcmF0b3JPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0l0ZXJhdG9yT2JzZXJ2YWJsZScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbnZhciBBcnJheUxpa2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5TGlrZU9ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL29ic2VydmVPbicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gYW4gQXJyYXksIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBhIFByb21pc2UsIGFuXG4gICAgICogaXRlcmFibGUgb2JqZWN0LCBvciBhbiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnRzIGFsbW9zdCBhbnl0aGluZyB0byBhbiBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIENvbnZlcnQgdmFyaW91cyBvdGhlciBvYmplY3RzIGFuZCBkYXRhIHR5cGVzIGludG8gT2JzZXJ2YWJsZXMuIGBmcm9tYFxuICAgICAqIGNvbnZlcnRzIGEgUHJvbWlzZSBvciBhbiBhcnJheS1saWtlIG9yIGFuXG4gICAgICogW2l0ZXJhYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhYmxlKVxuICAgICAqIG9iamVjdCBpbnRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgaW4gdGhhdCBwcm9taXNlIG9yIGFycmF5IG9yXG4gICAgICogaXRlcmFibGUuIEEgU3RyaW5nLCBpbiB0aGlzIGNvbnRleHQsIGlzIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0cyAoY29udGFpbnMgYSBmdW5jdGlvbiBuYW1lZCB3aXRoIHRoZSBFUzIwMTUgU3ltYm9sXG4gICAgICogZm9yIE9ic2VydmFibGUpIGNhbiBhbHNvIGJlIGNvbnZlcnRlZCB0aHJvdWdoIHRoaXMgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0cyBhbiBhcnJheSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIHZhciBhcnJheSA9IFsxMCwgMjAsIDMwXTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tKGFycmF5KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICAgICAqIC8vIDEwIDIwIDMwXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIGluZmluaXRlIGl0ZXJhYmxlIChmcm9tIGEgZ2VuZXJhdG9yKSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uKiBnZW5lcmF0ZURvdWJsZXMoc2VlZCkge1xuICAgICAqICAgdmFyIGkgPSBzZWVkO1xuICAgICAqICAgd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgICAgeWllbGQgaTtcbiAgICAgKiAgICAgaSA9IDIgKiBpOyAvLyBkb3VibGUgaXRcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaXRlcmF0b3IgPSBnZW5lcmF0ZURvdWJsZXMoMyk7XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbShpdGVyYXRvcikudGFrZSgxMCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAgICAgKiAvLyAzIDYgMTIgMjQgNDggOTYgMTkyIDM4NCA3NjggMTUzNlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudH1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXQ8VD59IGlzaCBBIHN1YnNjcmliYWJsZSBvYmplY3QsIGEgUHJvbWlzZSwgYW5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2UsIGFuIEFycmF5LCBhbiBpdGVyYWJsZSBvciBhbiBhcnJheS1saWtlIG9iamVjdCB0byBiZVxuICAgICAqIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBlbWlzc2lvbnMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgb3JpZ2luYWxseSBmcm9tIHRoZVxuICAgICAqIGlucHV0IG9iamVjdCB0aGF0IHdhcyBjb252ZXJ0ZWQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGlzaCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChpc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc2hbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzaCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlICYmICFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5XzEuaXNBcnJheShpc2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VPYnNlcnZhYmxlXzEuUHJvbWlzZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlzaFtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlXzEuSXRlcmF0b3JPYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlXzEuaXNBcnJheUxpa2UoaXNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZV8xLkFycmF5TGlrZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKGlzaCAhPT0gbnVsbCAmJiB0eXBlb2YgaXNoIHx8IGlzaCkgKyAnIGlzIG5vdCBvYnNlcnZhYmxlJyk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgaW50ZXJuYWwgdXNlIG9ubHkgKi8gRnJvbU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaXNoID0gdGhpcy5pc2g7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNoW29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSgpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc2hbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdKCkuc3Vic2NyaWJlKG5ldyBvYnNlcnZlT25fMS5PYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgMCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkZyb21PYnNlcnZhYmxlID0gRnJvbU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tT2JzZXJ2YWJsZS5qcy5tYXAiXX0=
},{"../Observable":4,"../operators/observeOn":35,"../symbol/iterator":36,"../symbol/observable":37,"../util/isArray":43,"../util/isArrayLike":44,"../util/isPromise":47,"./ArrayLikeObservable":17,"./ArrayObservable":18,"./IteratorObservable":21,"./PromiseObservable":22}],21:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index,
            hasError = state.hasError,
            iterator = state.iterator,
            subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    /** @deprecated internal use only */IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            iterator = _a.iterator,
            scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        } else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                } else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable);
exports.IteratorObservable = IteratorObservable;
var StringIterator = function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = str.length;
        }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}();
var ArrayIterator = function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = toLength(arr);
        }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}();
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkl0ZXJhdG9yT2JzZXJ2YWJsZS5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJyb290XzEiLCJyZXF1aXJlIiwiT2JzZXJ2YWJsZV8xIiwiaXRlcmF0b3JfMSIsIkl0ZXJhdG9yT2JzZXJ2YWJsZSIsIl9zdXBlciIsIml0ZXJhdG9yIiwic2NoZWR1bGVyIiwiY2FsbCIsIkVycm9yIiwiZ2V0SXRlcmF0b3IiLCJkaXNwYXRjaCIsInN0YXRlIiwiaW5kZXgiLCJoYXNFcnJvciIsInN1YnNjcmliZXIiLCJlcnJvciIsInJlc3VsdCIsIm5leHQiLCJkb25lIiwiY29tcGxldGUiLCJ2YWx1ZSIsImNsb3NlZCIsInJldHVybiIsInNjaGVkdWxlIiwiX3N1YnNjcmliZSIsIl9hIiwiT2JzZXJ2YWJsZSIsImV4cG9ydHMiLCJTdHJpbmdJdGVyYXRvciIsInN0ciIsImlkeCIsImxlbiIsImxlbmd0aCIsImNoYXJBdCIsInVuZGVmaW5lZCIsIkFycmF5SXRlcmF0b3IiLCJhcnIiLCJ0b0xlbmd0aCIsIm9iaiIsImkiLCJUeXBlRXJyb3IiLCJtYXhTYWZlSW50ZWdlciIsIk1hdGgiLCJwb3ciLCJvIiwiaXNOYU4iLCJudW1iZXJJc0Zpbml0ZSIsInNpZ24iLCJmbG9vciIsImFicyIsInJvb3QiLCJpc0Zpbml0ZSIsInZhbHVlQXNOdW1iZXIiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSUssU0FBU0MsUUFBUSxjQUFSLENBQWI7QUFDQSxJQUFJQyxlQUFlRCxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJRSxhQUFhRixRQUFRLG9CQUFSLENBQWpCO0FBQ0E7Ozs7O0FBS0EsSUFBSUcscUJBQXNCLFVBQVVDLE1BQVYsRUFBa0I7QUFDeENmLGNBQVVjLGtCQUFWLEVBQThCQyxNQUE5QjtBQUNBLGFBQVNELGtCQUFULENBQTRCRSxRQUE1QixFQUFzQ0MsU0FBdEMsRUFBaUQ7QUFDN0NGLGVBQU9HLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBS0QsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxZQUFJRCxZQUFZLElBQWhCLEVBQXNCO0FBQ2xCLGtCQUFNLElBQUlHLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0g7QUFDRCxhQUFLSCxRQUFMLEdBQWdCSSxZQUFZSixRQUFaLENBQWhCO0FBQ0g7QUFDREYsdUJBQW1CTCxNQUFuQixHQUE0QixVQUFVTyxRQUFWLEVBQW9CQyxTQUFwQixFQUErQjtBQUN2RCxlQUFPLElBQUlILGtCQUFKLENBQXVCRSxRQUF2QixFQUFpQ0MsU0FBakMsQ0FBUDtBQUNILEtBRkQ7QUFHQUgsdUJBQW1CTyxRQUFuQixHQUE4QixVQUFVQyxLQUFWLEVBQWlCO0FBQzNDLFlBQUlDLFFBQVFELE1BQU1DLEtBQWxCO0FBQUEsWUFBeUJDLFdBQVdGLE1BQU1FLFFBQTFDO0FBQUEsWUFBb0RSLFdBQVdNLE1BQU1OLFFBQXJFO0FBQUEsWUFBK0VTLGFBQWFILE1BQU1HLFVBQWxHO0FBQ0EsWUFBSUQsUUFBSixFQUFjO0FBQ1ZDLHVCQUFXQyxLQUFYLENBQWlCSixNQUFNSSxLQUF2QjtBQUNBO0FBQ0g7QUFDRCxZQUFJQyxTQUFTWCxTQUFTWSxJQUFULEVBQWI7QUFDQSxZQUFJRCxPQUFPRSxJQUFYLEVBQWlCO0FBQ2JKLHVCQUFXSyxRQUFYO0FBQ0E7QUFDSDtBQUNETCxtQkFBV0csSUFBWCxDQUFnQkQsT0FBT0ksS0FBdkI7QUFDQVQsY0FBTUMsS0FBTixHQUFjQSxRQUFRLENBQXRCO0FBQ0EsWUFBSUUsV0FBV08sTUFBZixFQUF1QjtBQUNuQixnQkFBSSxPQUFPaEIsU0FBU2lCLE1BQWhCLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ3ZDakIseUJBQVNpQixNQUFUO0FBQ0g7QUFDRDtBQUNIO0FBQ0QsYUFBS0MsUUFBTCxDQUFjWixLQUFkO0FBQ0gsS0FwQkQ7QUFxQkEsd0NBQXFDUixtQkFBbUJQLFNBQW5CLENBQTZCNEIsVUFBN0IsR0FBMEMsVUFBVVYsVUFBVixFQUFzQjtBQUNqRyxZQUFJRixRQUFRLENBQVo7QUFDQSxZQUFJYSxLQUFLLElBQVQ7QUFBQSxZQUFlcEIsV0FBV29CLEdBQUdwQixRQUE3QjtBQUFBLFlBQXVDQyxZQUFZbUIsR0FBR25CLFNBQXREO0FBQ0EsWUFBSUEsU0FBSixFQUFlO0FBQ1gsbUJBQU9BLFVBQVVpQixRQUFWLENBQW1CcEIsbUJBQW1CTyxRQUF0QyxFQUFnRCxDQUFoRCxFQUFtRDtBQUN0REUsdUJBQU9BLEtBRCtDLEVBQ3hDUCxVQUFVQSxRQUQ4QixFQUNwQlMsWUFBWUE7QUFEUSxhQUFuRCxDQUFQO0FBR0gsU0FKRCxNQUtLO0FBQ0QsZUFBRztBQUNDLG9CQUFJRSxTQUFTWCxTQUFTWSxJQUFULEVBQWI7QUFDQSxvQkFBSUQsT0FBT0UsSUFBWCxFQUFpQjtBQUNiSiwrQkFBV0ssUUFBWDtBQUNBO0FBQ0gsaUJBSEQsTUFJSztBQUNETCwrQkFBV0csSUFBWCxDQUFnQkQsT0FBT0ksS0FBdkI7QUFDSDtBQUNELG9CQUFJTixXQUFXTyxNQUFmLEVBQXVCO0FBQ25CLHdCQUFJLE9BQU9oQixTQUFTaUIsTUFBaEIsS0FBMkIsVUFBL0IsRUFBMkM7QUFDdkNqQixpQ0FBU2lCLE1BQVQ7QUFDSDtBQUNEO0FBQ0g7QUFDSixhQWZELFFBZVMsSUFmVDtBQWdCSDtBQUNKLEtBMUJvQztBQTJCckMsV0FBT25CLGtCQUFQO0FBQ0gsQ0E5RHlCLENBOER4QkYsYUFBYXlCLFVBOURXLENBQTFCO0FBK0RBQyxRQUFReEIsa0JBQVIsR0FBNkJBLGtCQUE3QjtBQUNBLElBQUl5QixpQkFBa0IsWUFBWTtBQUM5QixhQUFTQSxjQUFULENBQXdCQyxHQUF4QixFQUE2QkMsR0FBN0IsRUFBa0NDLEdBQWxDLEVBQXVDO0FBQ25DLFlBQUlELFFBQVEsS0FBSyxDQUFqQixFQUFvQjtBQUFFQSxrQkFBTSxDQUFOO0FBQVU7QUFDaEMsWUFBSUMsUUFBUSxLQUFLLENBQWpCLEVBQW9CO0FBQUVBLGtCQUFNRixJQUFJRyxNQUFWO0FBQW1CO0FBQ3pDLGFBQUtILEdBQUwsR0FBV0EsR0FBWDtBQUNBLGFBQUtDLEdBQUwsR0FBV0EsR0FBWDtBQUNBLGFBQUtDLEdBQUwsR0FBV0EsR0FBWDtBQUNIO0FBQ0RILG1CQUFlaEMsU0FBZixDQUF5Qk0sV0FBV0csUUFBcEMsSUFBZ0QsWUFBWTtBQUFFLGVBQVEsSUFBUjtBQUFnQixLQUE5RTtBQUNBdUIsbUJBQWVoQyxTQUFmLENBQXlCcUIsSUFBekIsR0FBZ0MsWUFBWTtBQUN4QyxlQUFPLEtBQUthLEdBQUwsR0FBVyxLQUFLQyxHQUFoQixHQUFzQjtBQUN6QmIsa0JBQU0sS0FEbUI7QUFFekJFLG1CQUFPLEtBQUtTLEdBQUwsQ0FBU0ksTUFBVCxDQUFnQixLQUFLSCxHQUFMLEVBQWhCO0FBRmtCLFNBQXRCLEdBR0g7QUFDQVosa0JBQU0sSUFETjtBQUVBRSxtQkFBT2M7QUFGUCxTQUhKO0FBT0gsS0FSRDtBQVNBLFdBQU9OLGNBQVA7QUFDSCxDQW5CcUIsRUFBdEI7QUFvQkEsSUFBSU8sZ0JBQWlCLFlBQVk7QUFDN0IsYUFBU0EsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEJOLEdBQTVCLEVBQWlDQyxHQUFqQyxFQUFzQztBQUNsQyxZQUFJRCxRQUFRLEtBQUssQ0FBakIsRUFBb0I7QUFBRUEsa0JBQU0sQ0FBTjtBQUFVO0FBQ2hDLFlBQUlDLFFBQVEsS0FBSyxDQUFqQixFQUFvQjtBQUFFQSxrQkFBTU0sU0FBU0QsR0FBVCxDQUFOO0FBQXNCO0FBQzVDLGFBQUtBLEdBQUwsR0FBV0EsR0FBWDtBQUNBLGFBQUtOLEdBQUwsR0FBV0EsR0FBWDtBQUNBLGFBQUtDLEdBQUwsR0FBV0EsR0FBWDtBQUNIO0FBQ0RJLGtCQUFjdkMsU0FBZCxDQUF3Qk0sV0FBV0csUUFBbkMsSUFBK0MsWUFBWTtBQUFFLGVBQU8sSUFBUDtBQUFjLEtBQTNFO0FBQ0E4QixrQkFBY3ZDLFNBQWQsQ0FBd0JxQixJQUF4QixHQUErQixZQUFZO0FBQ3ZDLGVBQU8sS0FBS2EsR0FBTCxHQUFXLEtBQUtDLEdBQWhCLEdBQXNCO0FBQ3pCYixrQkFBTSxLQURtQjtBQUV6QkUsbUJBQU8sS0FBS2dCLEdBQUwsQ0FBUyxLQUFLTixHQUFMLEVBQVQ7QUFGa0IsU0FBdEIsR0FHSDtBQUNBWixrQkFBTSxJQUROO0FBRUFFLG1CQUFPYztBQUZQLFNBSEo7QUFPSCxLQVJEO0FBU0EsV0FBT0MsYUFBUDtBQUNILENBbkJvQixFQUFyQjtBQW9CQSxTQUFTMUIsV0FBVCxDQUFxQjZCLEdBQXJCLEVBQTBCO0FBQ3RCLFFBQUlDLElBQUlELElBQUlwQyxXQUFXRyxRQUFmLENBQVI7QUFDQSxRQUFJLENBQUNrQyxDQUFELElBQU0sT0FBT0QsR0FBUCxLQUFlLFFBQXpCLEVBQW1DO0FBQy9CLGVBQU8sSUFBSVYsY0FBSixDQUFtQlUsR0FBbkIsQ0FBUDtBQUNIO0FBQ0QsUUFBSSxDQUFDQyxDQUFELElBQU1ELElBQUlOLE1BQUosS0FBZUUsU0FBekIsRUFBb0M7QUFDaEMsZUFBTyxJQUFJQyxhQUFKLENBQWtCRyxHQUFsQixDQUFQO0FBQ0g7QUFDRCxRQUFJLENBQUNDLENBQUwsRUFBUTtBQUNKLGNBQU0sSUFBSUMsU0FBSixDQUFjLHdCQUFkLENBQU47QUFDSDtBQUNELFdBQU9GLElBQUlwQyxXQUFXRyxRQUFmLEdBQVA7QUFDSDtBQUNELElBQUlvQyxpQkFBaUJDLEtBQUtDLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBWixJQUFrQixDQUF2QztBQUNBLFNBQVNOLFFBQVQsQ0FBa0JPLENBQWxCLEVBQXFCO0FBQ2pCLFFBQUliLE1BQU0sQ0FBQ2EsRUFBRVosTUFBYjtBQUNBLFFBQUlhLE1BQU1kLEdBQU4sQ0FBSixFQUFnQjtBQUNaLGVBQU8sQ0FBUDtBQUNIO0FBQ0QsUUFBSUEsUUFBUSxDQUFSLElBQWEsQ0FBQ2UsZUFBZWYsR0FBZixDQUFsQixFQUF1QztBQUNuQyxlQUFPQSxHQUFQO0FBQ0g7QUFDREEsVUFBTWdCLEtBQUtoQixHQUFMLElBQVlXLEtBQUtNLEtBQUwsQ0FBV04sS0FBS08sR0FBTCxDQUFTbEIsR0FBVCxDQUFYLENBQWxCO0FBQ0EsUUFBSUEsT0FBTyxDQUFYLEVBQWM7QUFDVixlQUFPLENBQVA7QUFDSDtBQUNELFFBQUlBLE1BQU1VLGNBQVYsRUFBMEI7QUFDdEIsZUFBT0EsY0FBUDtBQUNIO0FBQ0QsV0FBT1YsR0FBUDtBQUNIO0FBQ0QsU0FBU2UsY0FBVCxDQUF3QjFCLEtBQXhCLEVBQStCO0FBQzNCLFdBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QnJCLE9BQU9tRCxJQUFQLENBQVlDLFFBQVosQ0FBcUIvQixLQUFyQixDQUFwQztBQUNIO0FBQ0QsU0FBUzJCLElBQVQsQ0FBYzNCLEtBQWQsRUFBcUI7QUFDakIsUUFBSWdDLGdCQUFnQixDQUFDaEMsS0FBckI7QUFDQSxRQUFJZ0Msa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGVBQU9BLGFBQVA7QUFDSDtBQUNELFFBQUlQLE1BQU1PLGFBQU4sQ0FBSixFQUEwQjtBQUN0QixlQUFPQSxhQUFQO0FBQ0g7QUFDRCxXQUFPQSxnQkFBZ0IsQ0FBaEIsR0FBb0IsQ0FBQyxDQUFyQixHQUF5QixDQUFoQztBQUNIO0FBQ0QiLCJmaWxlIjoiSXRlcmF0b3JPYnNlcnZhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBJdGVyYXRvck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVyYXRvck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlcmF0b3JPYnNlcnZhYmxlKGl0ZXJhdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoaXRlcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBJdGVyYXRvck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvck9ic2VydmFibGUoaXRlcmF0b3IsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIGhhc0Vycm9yID0gc3RhdGUuaGFzRXJyb3IsIGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3IsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc3RhdGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgLyoqIEBkZXByZWNhdGVkIGludGVybmFsIHVzZSBvbmx5ICovIEl0ZXJhdG9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGl0ZXJhdG9yID0gX2EuaXRlcmF0b3IsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsIGl0ZXJhdG9yOiBpdGVyYXRvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSXRlcmF0b3JPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5JdGVyYXRvck9ic2VydmFibGUgPSBJdGVyYXRvck9ic2VydmFibGU7XG52YXIgU3RyaW5nSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKHN0ciwgaWR4LCBsZW4pIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gdm9pZCAwKSB7IGlkeCA9IDA7IH1cbiAgICAgICAgaWYgKGxlbiA9PT0gdm9pZCAwKSB7IGxlbiA9IHN0ci5sZW5ndGg7IH1cbiAgICAgICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMpOyB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RyLmNoYXJBdCh0aGlzLmlkeCsrKVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdJdGVyYXRvcjtcbn0oKSk7XG52YXIgQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcihhcnIsIGlkeCwgbGVuKSB7XG4gICAgICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSB0b0xlbmd0aChhcnIpOyB9XG4gICAgICAgIHRoaXMuYXJyID0gYXJyO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXJyW3RoaXMuaWR4KytdXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG59KCkpO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIGkgPSBvYmpbaXRlcmF0b3JfMS5pdGVyYXRvcl07XG4gICAgaWYgKCFpICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKCFpICYmIG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKCFpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialtpdGVyYXRvcl8xLml0ZXJhdG9yXSgpO1xufVxudmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbmZ1bmN0aW9uIHRvTGVuZ3RoKG8pIHtcbiAgICB2YXIgbGVuID0gK28ubGVuZ3RoO1xuICAgIGlmIChpc05hTihsZW4pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIGxlbiA9IHNpZ24obGVuKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobGVuKSk7XG4gICAgaWYgKGxlbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID4gbWF4U2FmZUludGVnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1heFNhZmVJbnRlZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gbnVtYmVySXNGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByb290XzEucm9vdC5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaWduKHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlQXNOdW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKHZhbHVlQXNOdW1iZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gICAgfVxuICAgIGlmIChpc05hTih2YWx1ZUFzTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVBc051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlQXNOdW1iZXIgPCAwID8gLTEgOiAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlcmF0b3JPYnNlcnZhYmxlLmpzLm1hcCJdfQ==
},{"../Observable":4,"../symbol/iterator":36,"../util/root":51}],22:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    /** @deprecated internal use only */PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        } else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable);
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlByb21pc2VPYnNlcnZhYmxlLmpzIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInJvb3RfMSIsInJlcXVpcmUiLCJPYnNlcnZhYmxlXzEiLCJQcm9taXNlT2JzZXJ2YWJsZSIsIl9zdXBlciIsInByb21pc2UiLCJzY2hlZHVsZXIiLCJjYWxsIiwiX3N1YnNjcmliZSIsInN1YnNjcmliZXIiLCJfdGhpcyIsIl9pc1NjYWxhciIsImNsb3NlZCIsIm5leHQiLCJ2YWx1ZSIsImNvbXBsZXRlIiwidGhlbiIsImVyciIsImVycm9yIiwicm9vdCIsInNldFRpbWVvdXQiLCJzY2hlZHVsZSIsImRpc3BhdGNoTmV4dCIsImFkZCIsImRpc3BhdGNoRXJyb3IiLCJPYnNlcnZhYmxlIiwiZXhwb3J0cyIsImFyZyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsWUFBYSxhQUFRLFVBQUtBLFNBQWQsSUFBNEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSUMsQ0FBVCxJQUFjRCxDQUFkO0FBQWlCLFlBQUlBLEVBQUVFLGNBQUYsQ0FBaUJELENBQWpCLENBQUosRUFBeUJGLEVBQUVFLENBQUYsSUFBT0QsRUFBRUMsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBU0UsRUFBVCxHQUFjO0FBQUUsYUFBS0MsV0FBTCxHQUFtQkwsQ0FBbkI7QUFBdUI7QUFDdkNBLE1BQUVNLFNBQUYsR0FBY0wsTUFBTSxJQUFOLEdBQWFNLE9BQU9DLE1BQVAsQ0FBY1AsQ0FBZCxDQUFiLElBQWlDRyxHQUFHRSxTQUFILEdBQWVMLEVBQUVLLFNBQWpCLEVBQTRCLElBQUlGLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJSyxTQUFTQyxRQUFRLGNBQVIsQ0FBYjtBQUNBLElBQUlDLGVBQWVELFFBQVEsZUFBUixD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VixFQVdnQixVQUFVQyxHQUFWLEVBQWU7QUFDM0I7QUFDQWpCLDJCQUFPbUIsSUFBUCxDQUFZQyxVQUFaLENBQXVCLFlBQVk7QUFBRSw4QkFBTUgsR0FBTjtBQUFZLHFCQUFqRDtBQUNILGlCQWREO0FBZUg7QUFDSjtBQUNKLEtBdERvQztBQXVEckMsV0FBT2QsaUJBQVA7QUFDSCxDQTVGd0IsQ0E0RnZCRCxhQUFhdUIsVUE1RlUsQ0FBekI7QUE2RkFDLFFBQVF2QixpQkFBUixHQUE0QkEsaUJBQTVCO0FBQ0EsU0FBU21CLFlBQVQsQ0FBc0JLLEdBQXRCLEVBQTJCO0FBQ3ZCLFFBQUliLFFBQVFhLElBQUliLEtBQWhCO0FBQUEsUUFBdUJMLGFBQWFrQixJQUFJbEIsVUFBeEM7QUFDQSxRQUFJLENBQUNBLFdBQVdHLE1BQWhCLEVBQXdCO0FBQ3BCSCxtQkFBV0ksSUFBWCxDQUFnQkMsS0FBaEI7QUFDQUwsbUJBQVdNLFFBQVg7QUFDSDtBQUNKO0FBQ0QsU0FBU1MsYUFBVCxDQUF1QkcsR0FBdkIsRUFBNEI7QUFDeEIsUUFBSVYsTUFBTVUsSUFBSVYsR0FBZDtBQUFBLFFBQW1CUixhQUFha0IsSUFBSWxCLFVBQXBDO0FBQ0EsUUFBSSxDQUFDQSxXQUFXRyxNQUFoQixFQUF3QjtBQUNwQkgsbUJBQVdTLEtBQVgsQ0FBaUJELEdBQWpCO0FBQ0g7QUFDSjtBQUNEIiwiZmlsZSI6IlByb21pc2VPYnNlcnZhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFByb21pc2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvbWlzZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvbWlzZU9ic2VydmFibGUocHJvbWlzZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBQcm9taXNlIHRvIGFuIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQganVzdCBlbWl0cyB0aGUgUHJvbWlzZSdzXG4gICAgICogcmVzb2x2ZWQgdmFsdWUsIHRoZW4gY29tcGxldGVzLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIENvbnZlcnRzIGFuIEVTMjAxNSBQcm9taXNlIG9yIGEgUHJvbWlzZXMvQSsgc3BlYyBjb21wbGlhbnQgUHJvbWlzZSB0byBhblxuICAgICAqIE9ic2VydmFibGUuIElmIHRoZSBQcm9taXNlIHJlc29sdmVzIHdpdGggYSB2YWx1ZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gICAgICogZW1pdHMgdGhhdCByZXNvbHZlZCB2YWx1ZSBhcyBhIGBuZXh0YCwgYW5kIHRoZW4gY29tcGxldGVzLiBJZiB0aGUgUHJvbWlzZVxuICAgICAqIGlzIHJlamVjdGVkLCB0aGVuIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB0aGUgY29ycmVzcG9uZGluZyBFcnJvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnQgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgRmV0Y2ggdG8gYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZShmZXRjaCgnaHR0cDovL215c2VydmVyLmNvbS8nKSk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgYmluZENhbGxiYWNrfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Byb21pc2VMaWtlPFQ+fSBwcm9taXNlIFRoZSBwcm9taXNlIHRvIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZGVsaXZlcnkgb2YgdGhlIHJlc29sdmVkIHZhbHVlIChvciB0aGUgcmVqZWN0aW9uKS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHdoaWNoIHdyYXBzIHRoZSBQcm9taXNlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21Qcm9taXNlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBQcm9taXNlT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAocHJvbWlzZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZU9ic2VydmFibGUocHJvbWlzZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBpbnRlcm5hbCB1c2Ugb25seSAqLyBQcm9taXNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHRoZSBwcm9taXNlIHRyYXAsIHRocm93IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hFcnJvciwgMCwgeyBlcnI6IGVyciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSB0aGUgcHJvbWlzZSB0cmFwLCB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHJvb3RfMS5yb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlByb21pc2VPYnNlcnZhYmxlID0gUHJvbWlzZU9ic2VydmFibGU7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHZhbHVlID0gYXJnLnZhbHVlLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hFcnJvcihhcmcpIHtcbiAgICB2YXIgZXJyID0gYXJnLmVyciwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb21pc2VPYnNlcnZhYmxlLmpzLm1hcCJdfQ==
},{"../Observable":4,"../util/root":51}],23:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    /** @deprecated internal use only */ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjYWxhck9ic2VydmFibGUuanMiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZCIsImIiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiT2JzZXJ2YWJsZV8xIiwicmVxdWlyZSIsIlNjYWxhck9ic2VydmFibGUiLCJfc3VwZXIiLCJ2YWx1ZSIsInNjaGVkdWxlciIsImNhbGwiLCJfaXNTY2FsYXIiLCJkaXNwYXRjaCIsInN0YXRlIiwiZG9uZSIsInN1YnNjcmliZXIiLCJjb21wbGV0ZSIsIm5leHQiLCJjbG9zZWQiLCJzY2hlZHVsZSIsIl9zdWJzY3JpYmUiLCJPYnNlcnZhYmxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsWUFBYSxhQUFRLFVBQUtBLFNBQWQsSUFBNEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSUMsQ0FBVCxJQUFjRCxDQUFkO0FBQWlCLFlBQUlBLEVBQUVFLGNBQUYsQ0FBaUJELENBQWpCLENBQUosRUFBeUJGLEVBQUVFLENBQUYsSUFBT0QsRUFBRUMsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBU0UsRUFBVCxHQUFjO0FBQUUsYUFBS0MsV0FBTCxHQUFtQkwsQ0FBbkI7QUFBdUI7QUFDdkNBLE1BQUVNLFNBQUYsR0FBY0wsTUFBTSxJQUFOLEdBQWFNLE9BQU9DLE1BQVAsQ0FBY1AsQ0FBZCxDQUFiLElBQWlDRyxHQUFHRSxTQUFILEdBQWVMLEVBQUVLLFNBQWpCLEVBQTRCLElBQUlGLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJSyxlQUFlQyxRQUFRLGVBQVIsQ0FBbkI7QUFDQTs7Ozs7QUFLQSxJQUFJQyxtQkFBb0IsVUFBVUMsTUFBVixFQUFrQjtBQUN0Q2IsY0FBVVksZ0JBQVYsRUFBNEJDLE1BQTVCO0FBQ0EsYUFBU0QsZ0JBQVQsQ0FBMEJFLEtBQTFCLEVBQWlDQyxTQUFqQyxFQUE0QztBQUN4Q0YsZUFBT0csSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLRixLQUFMLEdBQWFBLEtBQWI7QUFDQSxhQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLGFBQUtFLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxZQUFJRixTQUFKLEVBQWU7QUFDWCxpQkFBS0UsU0FBTCxHQUFpQixLQUFqQjtBQUNIO0FBQ0o7QUFDREwscUJBQWlCSCxNQUFqQixHQUEwQixVQUFVSyxLQUFWLEVBQWlCQyxTQUFqQixFQUE0QjtBQUNsRCxlQUFPLElBQUlILGdCQUFKLENBQXFCRSxLQUFyQixFQUE0QkMsU0FBNUIsQ0FBUDtBQUNILEtBRkQ7QUFHQUgscUJBQWlCTSxRQUFqQixHQUE0QixVQUFVQyxLQUFWLEVBQWlCO0FBQ3pDLFlBQUlDLE9BQU9ELE1BQU1DLElBQWpCO0FBQUEsWUFBdUJOLFFBQVFLLE1BQU1MLEtBQXJDO0FBQUEsWUFBNENPLGFBQWFGLE1BQU1FLFVBQS9EO0FBQ0EsWUFBSUQsSUFBSixFQUFVO0FBQ05DLHVCQUFXQyxRQUFYO0FBQ0E7QUFDSDtBQUNERCxtQkFBV0UsSUFBWCxDQUFnQlQsS0FBaEI7QUFDQSxZQUFJTyxXQUFXRyxNQUFmLEVBQXVCO0FBQ25CO0FBQ0g7QUFDREwsY0FBTUMsSUFBTixHQUFhLElBQWI7QUFDQSxhQUFLSyxRQUFMLENBQWNOLEtBQWQ7QUFDSCxLQVpEO0FBYUEsd0NBQXFDUCxpQkFBaUJMLFNBQWpCLENBQTJCbUIsVUFBM0IsR0FBd0MsVUFBVUwsVUFBVixFQUFzQjtBQUMvRixZQUFJUCxRQUFRLEtBQUtBLEtBQWpCO0FBQ0EsWUFBSUMsWUFBWSxLQUFLQSxTQUFyQjtBQUNBLFlBQUlBLFNBQUosRUFBZTtBQUNYLG1CQUFPQSxVQUFVVSxRQUFWLENBQW1CYixpQkFBaUJNLFFBQXBDLEVBQThDLENBQTlDLEVBQWlEO0FBQ3BERSxzQkFBTSxLQUQ4QyxFQUN2Q04sT0FBT0EsS0FEZ0MsRUFDekJPLFlBQVlBO0FBRGEsYUFBakQsQ0FBUDtBQUdILFNBSkQsTUFLSztBQUNEQSx1QkFBV0UsSUFBWCxDQUFnQlQsS0FBaEI7QUFDQSxnQkFBSSxDQUFDTyxXQUFXRyxNQUFoQixFQUF3QjtBQUNwQkgsMkJBQVdDLFFBQVg7QUFDSDtBQUNKO0FBQ0osS0Fkb0M7QUFlckMsV0FBT1YsZ0JBQVA7QUFDSCxDQTNDdUIsQ0EyQ3RCRixhQUFhaUIsVUEzQ1MsQ0FBeEI7QUE0Q0FDLFFBQVFoQixnQkFBUixHQUEyQkEsZ0JBQTNCO0FBQ0EiLCJmaWxlIjoiU2NhbGFyT2JzZXJ2YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBTY2FsYXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2FsYXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBzdGF0ZS5kb25lLCB2YWx1ZSA9IHN0YXRlLnZhbHVlLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgaW50ZXJuYWwgdXNlIG9ubHkgKi8gU2NhbGFyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShTY2FsYXJPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjYWxhck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlNjYWxhck9ic2VydmFibGUgPSBTY2FsYXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NhbGFyT2JzZXJ2YWJsZS5qcy5tYXAiXX0=
},{"../Observable":4}],24:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../../util/root');
var tryCatch_1 = require('../../util/tryCatch');
var errorObject_1 = require('../../util/errorObject');
var Observable_1 = require('../../Observable');
var Subscriber_1 = require('../../Subscriber');
var map_1 = require('../../operators/map');
function getCORSRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1.root.ActiveXObject(progId)) {
                        break;
                    }
                } catch (e) {}
            }
            return new root_1.root.ActiveXObject(progId);
        } catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) {
        headers = null;
    }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
exports.ajaxGet = ajaxGet;
;
function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
exports.ajaxPost = ajaxPost;
;
function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
exports.ajaxDelete = ajaxDelete;
;
function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
exports.ajaxPut = ajaxPut;
;
function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}
exports.ajaxPatch = ajaxPatch;
;
var mapResponse = map_1.map(function (x, index) {
    return x.response;
});
function ajaxGetJSON(url, headers) {
    return mapResponse(new AjaxObservable({
        method: 'GET',
        url: url,
        responseType: 'json',
        headers: headers
    }));
}
exports.ajaxGetJSON = ajaxGetJSON;
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = function (_super) {
    __extends(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function createXHR() {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        } else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    /** @deprecated internal use only */AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = function () {
        var create = function create(urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    }();
    return AjaxObservable;
}(Observable_1.Observable);
exports.AjaxObservable = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = function (_super) {
    __extends(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this,
            xhr = _a.xhr,
            request = _a.request,
            destination = _a.destination;
        var response = new AjaxResponse(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this,
            request = _a.request,
            _b = _a.request,
            user = _b.user,
            method = _b.method,
            url = _b.url,
            async = _b.async,
            password = _b.password,
            headers = _b.headers,
            body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        } else {
            this.xhr = xhr;
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            this.setupEvents(xhr, request);
            // open XHR
            var result = void 0;
            if (user) {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            } else {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
            // timeout, responseType and withCredentials can be set once the XHR is open
            if (async) {
                xhr.timeout = request.timeout;
                xhr.responseType = request.responseType;
            }
            if ('withCredentials' in xhr) {
                xhr.withCredentials = !!request.withCredentials;
            }
            // set headers
            this.setHeaders(xhr, headers);
            // finally send the request
            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) {
                    return encodeURI(key) + "=" + encodeURI(body[key]);
                }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) {
            if (progressSubscriber) {
                var _xhrProgress_;
                _xhrProgress_ = function xhrProgress_1(e) {
                    var progressSubscriber = _xhrProgress_.progressSubscriber;
                    progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                    xhr.onprogress = _xhrProgress_;
                } else {
                    xhr.upload.onprogress = _xhrProgress_;
                }
                _xhrProgress_.progressSubscriber = progressSubscriber;
            }
            var _xhrError_;
            _xhrError_ = function xhrError_1(e) {
                var _a = _xhrError_,
                    progressSubscriber = _a.progressSubscriber,
                    subscriber = _a.subscriber,
                    request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError('ajax error', this, request));
            };
            xhr.onerror = _xhrError_;
            _xhrError_.request = request;
            _xhrError_.subscriber = this;
            _xhrError_.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = this.responseType === 'text' ? this.response || this.responseText : this.response;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                } else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                }
            }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this,
            done = _a.done,
            xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1.Subscriber);
exports.AjaxSubscriber = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse = function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        this.response = parseXhrResponse(this.responseType, xhr);
    }
    return AjaxResponse;
}();
exports.AjaxResponse = AjaxResponse;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError = function (_super) {
    __extends(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        this.response = parseXhrResponse(this.responseType, xhr);
    }
    return AjaxError;
}(Error);
exports.AjaxError = AjaxError;
function parseXhrResponse(responseType, xhr) {
    switch (responseType) {
        case 'json':
            if ('response' in xhr) {
                //IE does not support json as responseType, parse it internally
                return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
            } else {
                // HACK(benlesh): TypeScript shennanigans
                // tslint:disable-next-line:no-any latest TS seems to think xhr is "never" here.
                return JSON.parse(xhr.responseText || 'null');
            }
        case 'xml':
            return xhr.responseXML;
        case 'text':
        default:
            // HACK(benlesh): TypeScript shennanigans
            // tslint:disable-next-line:no-any latest TS seems to think xhr is "never" here.
            return 'response' in xhr ? xhr.response : xhr.responseText;
    }
}
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError = function (_super) {
    __extends(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError);
exports.AjaxTimeoutError = AjaxTimeoutError;
//# sourceMappingURL=AjaxObservable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFqYXhPYnNlcnZhYmxlLmpzIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInJvb3RfMSIsInJlcXVpcmUiLCJ0cnlDYXRjaF8xIiwiZXJyb3JPYmplY3RfMSIsIk9ic2VydmFibGVfMSIsIlN1YnNjcmliZXJfMSIsIm1hcF8xIiwiZ2V0Q09SU1JlcXVlc3QiLCJyb290IiwiWE1MSHR0cFJlcXVlc3QiLCJYRG9tYWluUmVxdWVzdCIsIkVycm9yIiwiZ2V0WE1MSHR0cFJlcXVlc3QiLCJwcm9nSWQiLCJwcm9nSWRzIiwiaSIsIkFjdGl2ZVhPYmplY3QiLCJlIiwiYWpheEdldCIsInVybCIsImhlYWRlcnMiLCJBamF4T2JzZXJ2YWJsZSIsIm1ldGhvZCIsImV4cG9ydHMiLCJhamF4UG9zdCIsImJvZHkiLCJhamF4RGVsZXRlIiwiYWpheFB1dCIsImFqYXhQYXRjaCIsIm1hcFJlc3BvbnNlIiwibWFwIiwieCIsImluZGV4IiwicmVzcG9uc2UiLCJhamF4R2V0SlNPTiIsInJlc3BvbnNlVHlwZSIsIl9zdXBlciIsInVybE9yUmVxdWVzdCIsImNhbGwiLCJyZXF1ZXN0IiwiYXN5bmMiLCJjcmVhdGVYSFIiLCJjcm9zc0RvbWFpbiIsIndpdGhDcmVkZW50aWFscyIsInRpbWVvdXQiLCJwcm9wIiwiX3N1YnNjcmliZSIsInN1YnNjcmliZXIiLCJBamF4U3Vic2NyaWJlciIsImdldCIsInBvc3QiLCJkZWxldGUiLCJwdXQiLCJwYXRjaCIsImdldEpTT04iLCJPYnNlcnZhYmxlIiwiZGVzdGluYXRpb24iLCJkb25lIiwiRm9ybURhdGEiLCJzZXJpYWxpemVCb2R5Iiwic2VuZCIsIm5leHQiLCJfYSIsInhociIsIkFqYXhSZXNwb25zZSIsIl9iIiwidXNlciIsInBhc3N3b3JkIiwidHJ5Q2F0Y2giLCJlcnJvck9iamVjdCIsImVycm9yIiwic2V0dXBFdmVudHMiLCJyZXN1bHQiLCJvcGVuIiwic2V0SGVhZGVycyIsImNvbnRlbnRUeXBlIiwic3BsaXRJbmRleCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJrZXlzIiwia2V5IiwiZW5jb2RlVVJJIiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicHJvZ3Jlc3NTdWJzY3JpYmVyIiwieGhyVGltZW91dCIsIkFqYXhUaW1lb3V0RXJyb3IiLCJvbnRpbWVvdXQiLCJ1cGxvYWQiLCJ4aHJQcm9ncmVzc18xIiwib25wcm9ncmVzcyIsInhockVycm9yXzEiLCJBamF4RXJyb3IiLCJvbmVycm9yIiwieGhyUmVhZHlTdGF0ZUNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXNfMSIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsImNvbXBsZXRlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwidW5zdWJzY3JpYmUiLCJhYm9ydCIsIlN1YnNjcmliZXIiLCJvcmlnaW5hbEV2ZW50IiwicGFyc2VYaHJSZXNwb25zZSIsIm1lc3NhZ2UiLCJwYXJzZSIsInJlc3BvbnNlWE1MIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxZQUFhLGFBQVEsVUFBS0EsU0FBZCxJQUE0QixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJQyxDQUFULElBQWNELENBQWQ7QUFBaUIsWUFBSUEsRUFBRUUsY0FBRixDQUFpQkQsQ0FBakIsQ0FBSixFQUF5QkYsRUFBRUUsQ0FBRixJQUFPRCxFQUFFQyxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTRSxFQUFULEdBQWM7QUFBRSxhQUFLQyxXQUFMLEdBQW1CTCxDQUFuQjtBQUF1QjtBQUN2Q0EsTUFBRU0sU0FBRixHQUFjTCxNQUFNLElBQU4sR0FBYU0sT0FBT0MsTUFBUCxDQUFjUCxDQUFkLENBQWIsSUFBaUNHLEdBQUdFLFNBQUgsR0FBZUwsRUFBRUssU0FBakIsRUFBNEIsSUFBSUYsRUFBSixFQUE3RCxDQUFkO0FB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QUFULENBQTBCekIsR0FBMUIsRUFBK0J4QixPQUEvQixFQUF3QztBQUNwQ0gsZUFBT0UsSUFBUCxDQUFZLElBQVosRUFBa0IsY0FBbEIsRUFBa0N5QixHQUFsQyxFQUF1Q3hCLE9BQXZDO0FBQ0g7QUFDRCxXQUFPaUQsZ0JBQVA7QUFDSCxDQU51QixDQU10Qk0sU0FOc0IsQ0FBeEI7QUFPQXZFLFFBQVFpRSxnQkFBUixHQUEyQkEsZ0JBQTNCO0FBQ0EiLCJmaWxlIjoiQWpheE9ic2VydmFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcm9vdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vLi4vU3Vic2NyaWJlcicpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3JzL21hcCcpO1xuZnVuY3Rpb24gZ2V0Q09SU1JlcXVlc3QoKSB7XG4gICAgaWYgKHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoISFyb290XzEucm9vdC5YRG9tYWluUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NPUlMgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRYTUxIdHRwUmVxdWVzdCgpIHtcbiAgICBpZiAocm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByb2dJZCA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9nSWRzID0gWydNc3htbDIuWE1MSFRUUCcsICdNaWNyb3NvZnQuWE1MSFRUUCcsICdNc3htbDIuWE1MSFRUUC40LjAnXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ0lkID0gcHJvZ0lkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyByb290XzEucm9vdC5BY3RpdmVYT2JqZWN0KHByb2dJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5BY3RpdmVYT2JqZWN0KHByb2dJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MSHR0cFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXInKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFqYXhHZXQodXJsLCBoZWFkZXJzKSB7XG4gICAgaWYgKGhlYWRlcnMgPT09IHZvaWQgMCkgeyBoZWFkZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheEdldCA9IGFqYXhHZXQ7XG47XG5mdW5jdGlvbiBhamF4UG9zdCh1cmwsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnUE9TVCcsIHVybDogdXJsLCBib2R5OiBib2R5LCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4UG9zdCA9IGFqYXhQb3N0O1xuO1xuZnVuY3Rpb24gYWpheERlbGV0ZSh1cmwsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnREVMRVRFJywgdXJsOiB1cmwsIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhEZWxldGUgPSBhamF4RGVsZXRlO1xuO1xuZnVuY3Rpb24gYWpheFB1dCh1cmwsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnUFVUJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQdXQgPSBhamF4UHV0O1xuO1xuZnVuY3Rpb24gYWpheFBhdGNoKHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQQVRDSCcsIHVybDogdXJsLCBib2R5OiBib2R5LCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4UGF0Y2ggPSBhamF4UGF0Y2g7XG47XG52YXIgbWFwUmVzcG9uc2UgPSBtYXBfMS5tYXAoZnVuY3Rpb24gKHgsIGluZGV4KSB7IHJldHVybiB4LnJlc3BvbnNlOyB9KTtcbmZ1bmN0aW9uIGFqYXhHZXRKU09OKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBtYXBSZXNwb25zZShuZXcgQWpheE9ic2VydmFibGUoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICB9KSk7XG59XG5leHBvcnRzLmFqYXhHZXRKU09OID0gYWpheEdldEpTT047XG47XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEFqYXhPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlWEhSOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NEb21haW4gPyBnZXRDT1JTUmVxdWVzdC5jYWxsKHRoaXMpIDogZ2V0WE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcm9zc0RvbWFpbjogZmFsc2UsXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB0aW1lb3V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdXJsT3JSZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVxdWVzdC51cmwgPSB1cmxPclJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHVybE9yUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmICh1cmxPclJlcXVlc3QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFtwcm9wXSA9IHVybE9yUmVxdWVzdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIGludGVybmFsIHVzZSBvbmx5ICovIEFqYXhPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBamF4U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnJlcXVlc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIGZvciBhbiBBamF4IHJlcXVlc3Qgd2l0aCBlaXRoZXIgYSByZXF1ZXN0IG9iamVjdCB3aXRoXG4gICAgICogdXJsLCBoZWFkZXJzLCBldGMgb3IgYSBzdHJpbmcgZm9yIGEgVVJMLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmFqYXgoJy9wcm9kdWN0cycpO1xuICAgICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCh7IHVybDogJ3Byb2R1Y3RzJywgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gcmVxdWVzdCBDYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICBBIHN0cmluZyBvZiB0aGUgVVJMIHRvIG1ha2UgdGhlIEFqYXggY2FsbC5cbiAgICAgKiAgIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuICAgICAqICAgLSB1cmw6IFVSTCBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBib2R5OiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBtZXRob2Q6IE1ldGhvZCBvZiB0aGUgcmVxdWVzdCwgc3VjaCBhcyBHRVQsIFBPU1QsIFBVVCwgUEFUQ0gsIERFTEVURVxuICAgICAqICAgLSBhc3luYzogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhc3luY1xuICAgICAqICAgLSBoZWFkZXJzOiBPcHRpb25hbCBoZWFkZXJzXG4gICAgICogICAtIGNyb3NzRG9tYWluOiB0cnVlIGlmIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3QsIGVsc2UgZmFsc2VcbiAgICAgKiAgIC0gY3JlYXRlWEhSOiBhIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBhbHRlcm5hdGVcbiAgICAgKiAgIFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uLlxuICAgICAqICAgLSByZXN1bHRTZWxlY3RvcjogYSBmdW5jdGlvbiB0byB1c2UgdG8gYWx0ZXIgdGhlIG91dHB1dCB2YWx1ZSB0eXBlIG9mXG4gICAgICogICB0aGUgT2JzZXJ2YWJsZS4gR2V0cyB7QGxpbmsgQWpheFJlc3BvbnNlfSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGFqYXhcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICovXG4gICAgQWpheE9ic2VydmFibGUuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY3JlYXRlLmdldCA9IGFqYXhHZXQ7XG4gICAgICAgIGNyZWF0ZS5wb3N0ID0gYWpheFBvc3Q7XG4gICAgICAgIGNyZWF0ZS5kZWxldGUgPSBhamF4RGVsZXRlO1xuICAgICAgICBjcmVhdGUucHV0ID0gYWpheFB1dDtcbiAgICAgICAgY3JlYXRlLnBhdGNoID0gYWpheFBhdGNoO1xuICAgICAgICBjcmVhdGUuZ2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuICAgICAgICByZXR1cm4gY3JlYXRlO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFqYXhPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BamF4T2JzZXJ2YWJsZSA9IEFqYXhPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBamF4U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAvLyBmb3JjZSBDT1JTIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAoIXJlcXVlc3QuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSkge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgY29udGVudCB0eXBlIGlzIHNldFxuICAgICAgICBpZiAoISgnQ29udGVudC1UeXBlJyBpbiBoZWFkZXJzKSAmJiAhKHJvb3RfMS5yb290LkZvcm1EYXRhICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIHJvb3RfMS5yb290LkZvcm1EYXRhKSAmJiB0eXBlb2YgcmVxdWVzdC5ib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wZXJseSBzZXJpYWxpemUgYm9keVxuICAgICAgICByZXF1ZXN0LmJvZHkgPSB0aGlzLnNlcmlhbGl6ZUJvZHkocmVxdWVzdC5ib2R5LCByZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgeGhyID0gX2EueGhyLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IEFqYXhSZXNwb25zZShlLCB4aHIsIHJlcXVlc3QpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgX2IgPSBfYS5yZXF1ZXN0LCB1c2VyID0gX2IudXNlciwgbWV0aG9kID0gX2IubWV0aG9kLCB1cmwgPSBfYi51cmwsIGFzeW5jID0gX2IuYXN5bmMsIHBhc3N3b3JkID0gX2IucGFzc3dvcmQsIGhlYWRlcnMgPSBfYi5oZWFkZXJzLCBib2R5ID0gX2IuYm9keTtcbiAgICAgICAgdmFyIGNyZWF0ZVhIUiA9IHJlcXVlc3QuY3JlYXRlWEhSO1xuICAgICAgICB2YXIgeGhyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjcmVhdGVYSFIpLmNhbGwocmVxdWVzdCk7XG4gICAgICAgIGlmICh4aHIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBldmVudHMgYmVmb3JlIG9wZW4gWEhSXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIFlvdSBuZWVkIHRvIGFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIG9wZW4oKSBvbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJvZ3Jlc3MgZXZlbnRzIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKHhociwgcmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBvcGVuIFhIUlxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGltZW91dCwgcmVzcG9uc2VUeXBlIGFuZCB3aXRoQ3JlZGVudGlhbHMgY2FuIGJlIHNldCBvbmNlIHRoZSBYSFIgaXMgb3BlblxuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIXJlcXVlc3Qud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGhlYWRlcnNcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVycyh4aHIsIGhlYWRlcnMpO1xuICAgICAgICAgICAgLy8gZmluYWxseSBzZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICByZXN1bHQgPSBib2R5ID8gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIuc2VuZCkuY2FsbCh4aHIsIGJvZHkpIDogdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIuc2VuZCkuY2FsbCh4aHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNlcmlhbGl6ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgY29udGVudFR5cGUpIHtcbiAgICAgICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuRm9ybURhdGEgJiYgYm9keSBpbnN0YW5jZW9mIHJvb3RfMS5yb290LkZvcm1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdEluZGV4ID0gY29udGVudFR5cGUuaW5kZXhPZignOycpO1xuICAgICAgICAgICAgaWYgKHNwbGl0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZS5zdWJzdHJpbmcoMCwgc3BsaXRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYm9keSkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChlbmNvZGVVUkkoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJKGJvZHlba2V5XSkpOyB9KS5qb2luKCcmJyk7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uICh4aHIsIGhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXR1cEV2ZW50cyA9IGZ1bmN0aW9uICh4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHByb2dyZXNzU3Vic2NyaWJlciA9IHJlcXVlc3QucHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICBmdW5jdGlvbiB4aHJUaW1lb3V0KGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHhoclRpbWVvdXQsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IobmV3IEFqYXhUaW1lb3V0RXJyb3IodGhpcywgcmVxdWVzdCkpOyAvL1RPRE86IE1ha2UgYmV0dGVyZXIuXG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB4aHIub250aW1lb3V0ID0geGhyVGltZW91dDtcbiAgICAgICAgeGhyVGltZW91dC5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgeGhyVGltZW91dC5zdWJzY3JpYmVyID0gdGhpcztcbiAgICAgICAgeGhyVGltZW91dC5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIGlmICh4aHIudXBsb2FkICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHZhciB4aHJQcm9ncmVzc18xO1xuICAgICAgICAgICAgICAgIHhoclByb2dyZXNzXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NTdWJzY3JpYmVyID0geGhyUHJvZ3Jlc3NfMS5wcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5uZXh0KGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0geGhyUHJvZ3Jlc3NfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhoclByb2dyZXNzXzEucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHhockVycm9yXzE7XG4gICAgICAgICAgICB4aHJFcnJvcl8xID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB4aHJFcnJvcl8xLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCByZXF1ZXN0ID0gX2EucmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheEVycm9yKCdhamF4IGVycm9yJywgdGhpcywgcmVxdWVzdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0geGhyRXJyb3JfMTtcbiAgICAgICAgICAgIHhockVycm9yXzEucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24geGhyUmVhZHlTdGF0ZUNoYW5nZShlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB4aHJSZWFkeVN0YXRlQ2hhbmdlLCBzdWJzY3JpYmVyID0gX2Euc3Vic2NyaWJlciwgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gX2EucHJvZ3Jlc3NTdWJzY3JpYmVyLCByZXF1ZXN0ID0gX2EucmVxdWVzdDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzXzEgPSB0aGlzLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHRoaXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9ICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gKHRoaXMucmVzcG9uc2UgfHwgdGhpcy5yZXNwb25zZVRleHQpIDogdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLy8gZml4IHN0YXR1cyBjb2RlIHdoZW4gaXQgaXMgMCAoMCBzdGF0dXMgaXMgdW5kb2N1bWVudGVkKS5cbiAgICAgICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBhY2Nlc3NpbmcgZmlsZSByZXNvdXJjZXMgb3Igb24gQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzXzEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzXzEgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzXzEgJiYgc3RhdHVzXzEgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGUpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheEVycm9yKCdhamF4IGVycm9yICcgKyBzdGF0dXNfMSwgdGhpcywgcmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHJSZWFkeVN0YXRlQ2hhbmdlO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgeGhyUmVhZHlTdGF0ZUNoYW5nZS5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZG9uZSA9IF9hLmRvbmUsIHhociA9IF9hLnhocjtcbiAgICAgICAgaWYgKCFkb25lICYmIHhociAmJiB4aHIucmVhZHlTdGF0ZSAhPT0gNCAmJiB0eXBlb2YgeGhyLmFib3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQWpheFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLkFqYXhTdWJzY3JpYmVyID0gQWpheFN1YnNjcmliZXI7XG4vKipcbiAqIEEgbm9ybWFsaXplZCBBSkFYIHJlc3BvbnNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhSZXNwb25zZVxuICovXG52YXIgQWpheFJlc3BvbnNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBamF4UmVzcG9uc2Uob3JpZ2luYWxFdmVudCwgeGhyLCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0geGhyLnJlc3BvbnNlVHlwZSB8fCByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHBhcnNlWGhyUmVzcG9uc2UodGhpcy5yZXNwb25zZVR5cGUsIHhocik7XG4gICAgfVxuICAgIHJldHVybiBBamF4UmVzcG9uc2U7XG59KCkpO1xuZXhwb3J0cy5BamF4UmVzcG9uc2UgPSBBamF4UmVzcG9uc2U7XG4vKipcbiAqIEEgbm9ybWFsaXplZCBBSkFYIGVycm9yLlxuICpcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhFcnJvclxuICovXG52YXIgQWpheEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhFcnJvcihtZXNzYWdlLCB4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0geGhyLnJlc3BvbnNlVHlwZSB8fCByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHBhcnNlWGhyUmVzcG9uc2UodGhpcy5yZXNwb25zZVR5cGUsIHhocik7XG4gICAgfVxuICAgIHJldHVybiBBamF4RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkFqYXhFcnJvciA9IEFqYXhFcnJvcjtcbmZ1bmN0aW9uIHBhcnNlWGhyUmVzcG9uc2UocmVzcG9uc2VUeXBlLCB4aHIpIHtcbiAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgIGlmICgncmVzcG9uc2UnIGluIHhocikge1xuICAgICAgICAgICAgICAgIC8vSUUgZG9lcyBub3Qgc3VwcG9ydCBqc29uIGFzIHJlc3BvbnNlVHlwZSwgcGFyc2UgaXQgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSEFDSyhiZW5sZXNoKTogVHlwZVNjcmlwdCBzaGVubmFuaWdhbnNcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IGxhdGVzdCBUUyBzZWVtcyB0byB0aGluayB4aHIgaXMgXCJuZXZlclwiIGhlcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBIQUNLKGJlbmxlc2gpOiBUeXBlU2NyaXB0IHNoZW5uYW5pZ2Fuc1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBsYXRlc3QgVFMgc2VlbXMgdG8gdGhpbmsgeGhyIGlzIFwibmV2ZXJcIiBoZXJlLlxuICAgICAgICAgICAgcmV0dXJuICgncmVzcG9uc2UnIGluIHhocikgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbn1cbi8qKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheFRpbWVvdXRFcnJvclxuICovXG52YXIgQWpheFRpbWVvdXRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhUaW1lb3V0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheFRpbWVvdXRFcnJvcih4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ2FqYXggdGltZW91dCcsIHhociwgcmVxdWVzdCk7XG4gICAgfVxuICAgIHJldHVybiBBamF4VGltZW91dEVycm9yO1xufShBamF4RXJyb3IpKTtcbmV4cG9ydHMuQWpheFRpbWVvdXRFcnJvciA9IEFqYXhUaW1lb3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BamF4T2JzZXJ2YWJsZS5qcy5tYXAiXX0=
},{"../../Observable":4,"../../Subscriber":9,"../../operators/map":33,"../../util/errorObject":42,"../../util/root":51,"../../util/tryCatch":54}],25:[function(require,module,exports){
"use strict";

var FromObservable_1 = require('./FromObservable');
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZyb20uanMiXSwibmFtZXMiOlsiRnJvbU9ic2VydmFibGVfMSIsInJlcXVpcmUiLCJleHBvcnRzIiwiZnJvbSIsIkZyb21PYnNlcnZhYmxlIiwiY3JlYXRlIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxtQkFBbUJDLFFBQVEsa0JBQVIsQ0FBdkI7QUFDQUMsUUFBUUMsSUFBUixHQUFlSCxpQkFBaUJJLGNBQWpCLENBQWdDQyxNQUEvQztBQUNBIiwiZmlsZSI6ImZyb20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gcm9tT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mcm9tID0gRnJvbU9ic2VydmFibGVfMS5Gcm9tT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tLmpzLm1hcCJdfQ==
},{"./FromObservable":20}],26:[function(require,module,exports){
"use strict";

var PromiseObservable_1 = require('./PromiseObservable');
exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
//# sourceMappingURL=fromPromise.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZyb21Qcm9taXNlLmpzIl0sIm5hbWVzIjpbIlByb21pc2VPYnNlcnZhYmxlXzEiLCJyZXF1aXJlIiwiZXhwb3J0cyIsImZyb21Qcm9taXNlIiwiUHJvbWlzZU9ic2VydmFibGUiLCJjcmVhdGUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLHNCQUFzQkMsUUFBUSxxQkFBUixDQUExQjtBQUNBQyxRQUFRQyxXQUFSLEdBQXNCSCxvQkFBb0JJLGlCQUFwQixDQUFzQ0MsTUFBNUQ7QUFDQSIsImZpbGUiOiJmcm9tUHJvbWlzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIFByb21pc2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1Byb21pc2VPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmZyb21Qcm9taXNlID0gUHJvbWlzZU9ic2VydmFibGVfMS5Qcm9taXNlT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tUHJvbWlzZS5qcy5tYXAiXX0=
},{"./PromiseObservable":22}],27:[function(require,module,exports){
"use strict";

var distinct_1 = require('../operators/distinct');
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
  return distinct_1.distinct(keySelector, flushes)(this);
}
exports.distinct = distinct;
//# sourceMappingURL=distinct.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRpc3RpbmN0LmpzIl0sIm5hbWVzIjpbImRpc3RpbmN0XzEiLCJyZXF1aXJlIiwiZGlzdGluY3QiLCJrZXlTZWxlY3RvciIsImZsdXNoZXMiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxhQUFhQyxRQUFRLHVCQUFSLENBQWpCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDQSxTQUFTQyxRQUFULENBQWtCQyxXQUFsQixFQUErQkMsT0FBL0IsRUFBd0M7QUFDcEMsU0FBT0osV0FBV0UsUUFBWCxDQUFvQkMsV0FBcEIsRUFBaUNDLE9BQWpDLEVBQTBDLElBQTFDLENBQVA7QUFDSDtBQUNEQyxRQUFRSCxRQUFSLEdBQW1CQSxRQUFuQjtBQUNBIiwiZmlsZSI6ImRpc3RpbmN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGlzdGluY3RfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycy9kaXN0aW5jdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHByZXZpb3VzIGl0ZW1zLlxuICpcbiAqIElmIGEga2V5U2VsZWN0b3IgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBwcm9qZWN0IGVhY2ggdmFsdWUgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUgaW50byBhIG5ldyB2YWx1ZSB0aGF0IGl0IHdpbGxcbiAqIGNoZWNrIGZvciBlcXVhbGl0eSB3aXRoIHByZXZpb3VzbHkgcHJvamVjdGVkIHZhbHVlcy4gSWYgYSBrZXlTZWxlY3RvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIGVhY2ggdmFsdWUgZnJvbSB0aGVcbiAqIHNvdXJjZSBvYnNlcnZhYmxlIGRpcmVjdGx5IHdpdGggYW4gZXF1YWxpdHkgY2hlY2sgYWdhaW5zdCBwcmV2aW91cyB2YWx1ZXMuXG4gKlxuICogSW4gSmF2YVNjcmlwdCBydW50aW1lcyB0aGF0IHN1cHBvcnQgYFNldGAsIHRoaXMgb3BlcmF0b3Igd2lsbCB1c2UgYSBgU2V0YCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZSBjaGVja2luZy5cbiAqXG4gKiBJbiBvdGhlciBydW50aW1lcywgdGhpcyBvcGVyYXRvciB3aWxsIHVzZSBhIG1pbmltYWwgaW1wbGVtZW50YXRpb24gb2YgYFNldGAgdGhhdCByZWxpZXMgb24gYW4gYEFycmF5YCBhbmQgYGluZGV4T2ZgIHVuZGVyIHRoZVxuICogaG9vZCwgc28gcGVyZm9ybWFuY2Ugd2lsbCBkZWdyYWRlIGFzIG1vcmUgdmFsdWVzIGFyZSBjaGVja2VkIGZvciBkaXN0aW5jdGlvbi4gRXZlbiBpbiBuZXdlciBicm93c2VycywgYSBsb25nLXJ1bm5pbmcgYGRpc3RpbmN0YFxuICogdXNlIG1pZ2h0IHJlc3VsdCBpbiBtZW1vcnkgbGVha3MuIFRvIGhlbHAgYWxsZXZpYXRlIHRoaXMgaW4gc29tZSBzY2VuYXJpb3MsIGFuIG9wdGlvbmFsIGBmbHVzaGVzYCBwYXJhbWV0ZXIgaXMgYWxzbyBwcm92aWRlZCBzb1xuICogdGhhdCB0aGUgaW50ZXJuYWwgYFNldGAgY2FuIGJlIFwiZmx1c2hlZFwiLCBiYXNpY2FsbHkgY2xlYXJpbmcgaXQgb2YgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc2ltcGxlIGV4YW1wbGUgd2l0aCBudW1iZXJzPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZigxLCAxLCAyLCAyLCAyLCAxLCAyLCAzLCA0LCAzLCAyLCAxKVxuICogICAuZGlzdGluY3QoKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAxLCAyLCAzLCA0XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSB1c2luZyBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICBhZ2U6IG51bWJlcixcbiAqICAgIG5hbWU6IHN0cmluZ1xuICogfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3QoKHA6IFBlcnNvbikgPT4gcC5uYW1lKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtrZXlTZWxlY3Rvcl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gc2VsZWN0IHdoaWNoIHZhbHVlIHlvdSB3YW50IHRvIGNoZWNrIGFzIGRpc3RpbmN0LlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZmx1c2hlc10gT3B0aW9uYWwgT2JzZXJ2YWJsZSBmb3IgZmx1c2hpbmcgdGhlIGludGVybmFsIEhhc2hTZXQgb2YgdGhlIG9wZXJhdG9yLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzLlxuICogQG1ldGhvZCBkaXN0aW5jdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3Qoa2V5U2VsZWN0b3IsIGZsdXNoZXMpIHtcbiAgICByZXR1cm4gZGlzdGluY3RfMS5kaXN0aW5jdChrZXlTZWxlY3RvciwgZmx1c2hlcykodGhpcyk7XG59XG5leHBvcnRzLmRpc3RpbmN0ID0gZGlzdGluY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdC5qcy5tYXAiXX0=
},{"../operators/distinct":31}],28:[function(require,module,exports){
"use strict";

var filter_1 = require('../operators/filter');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
  return filter_1.filter(predicate, thisArg)(this);
}
exports.filter = filter;
//# sourceMappingURL=filter.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbHRlci5qcyJdLCJuYW1lcyI6WyJmaWx0ZXJfMSIsInJlcXVpcmUiLCJmaWx0ZXIiLCJwcmVkaWNhdGUiLCJ0aGlzQXJnIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsV0FBV0MsUUFBUSxxQkFBUixDQUFmO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBLFNBQVNDLE1BQVQsQ0FBZ0JDLFNBQWhCLEVBQTJCQyxPQUEzQixFQUFvQztBQUNoQyxTQUFPSixTQUFTRSxNQUFULENBQWdCQyxTQUFoQixFQUEyQkMsT0FBM0IsRUFBb0MsSUFBcEMsQ0FBUDtBQUNIO0FBQ0RDLFFBQVFILE1BQVIsR0FBaUJBLE1BQWpCO0FBQ0EiLCJmaWxlIjoiZmlsdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvZmlsdGVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBGaWx0ZXIgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgb25seSBlbWl0dGluZyB0aG9zZSB0aGF0XG4gKiBzYXRpc2Z5IGEgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5maWx0ZXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyKSxcbiAqIGl0IG9ubHkgZW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgaWYgaXQgcGFzc2VzIGEgY3JpdGVyaW9uIGZ1bmN0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbHRlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsLWtub3duIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2QsIHRoaXMgb3BlcmF0b3JcbiAqIHRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcGFzc2VzIHRoZW0gdGhyb3VnaCBhIGBwcmVkaWNhdGVgXG4gKiBmdW5jdGlvbiBhbmQgb25seSBlbWl0cyB0aG9zZSB2YWx1ZXMgdGhhdCB5aWVsZGVkIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgY2xpY2sgZXZlbnRzIHdob3NlIHRhcmdldCB3YXMgYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gY2xpY2tzLmZpbHRlcihldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogY2xpY2tzT25EaXZzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBpZ25vcmVFbGVtZW50c31cbiAqIEBzZWUge0BsaW5rIHBhcnRpdGlvbn1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkLCBpZiBgZmFsc2VgIHRoZSB2YWx1ZSBpcyBub3QgcGFzc2VkIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlXG4gKiBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXJcbiAqIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmVcbiAqIGFsbG93ZWQgYnkgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBmaWx0ZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZmlsdGVyXzEuZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykodGhpcyk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiXX0=
},{"../operators/filter":32}],29:[function(require,module,exports){
"use strict";

var map_1 = require('../operators/map');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
  return map_1.map(project, thisArg)(this);
}
exports.map = map;
//# sourceMappingURL=map.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hcC5qcyJdLCJuYW1lcyI6WyJtYXBfMSIsInJlcXVpcmUiLCJtYXAiLCJwcm9qZWN0IiwidGhpc0FyZyIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFFBQVFDLFFBQVEsa0JBQVIsQ0FBWjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0EsU0FBU0MsR0FBVCxDQUFhQyxPQUFiLEVBQXNCQyxPQUF0QixFQUErQjtBQUMzQixTQUFPSixNQUFNRSxHQUFOLENBQVVDLE9BQVYsRUFBbUJDLE9BQW5CLEVBQTRCLElBQTVCLENBQVA7QUFDSDtBQUNEQyxRQUFRSCxHQUFSLEdBQWNBLEdBQWQ7QUFDQSIsImZpbGUiOiJtYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycy9tYXAnKTtcbi8qKlxuICogQXBwbGllcyBhIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoZSByZXN1bHRpbmcgdmFsdWVzIGFzIGFuIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2UgW0FycmF5LnByb3RvdHlwZS5tYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKSxcbiAqIGl0IHBhc3NlcyBlYWNoIHNvdXJjZSB2YWx1ZSB0aHJvdWdoIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gZ2V0XG4gKiBjb3JyZXNwb25kaW5nIG91dHB1dCB2YWx1ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwga25vd24gYEFycmF5LnByb3RvdHlwZS5tYXBgIGZ1bmN0aW9uLCB0aGlzIG9wZXJhdG9yXG4gKiBhcHBsaWVzIGEgcHJvamVjdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBlbWl0cyB0aGF0IHByb2plY3Rpb24gaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwVG99XG4gKiBAc2VlIHtAbGluayBwbHVja31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gcHJvamVjdCBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqIHRvIGVhY2ggYHZhbHVlYCBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzXG4gKiB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlXG4gKiBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRlZmluZSB3aGF0IGB0aGlzYCBpcyBpbiB0aGVcbiAqIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBtYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG1hcF8xLm1hcChwcm9qZWN0LCB0aGlzQXJnKSh0aGlzKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCJdfQ==
},{"../operators/map":33}],30:[function(require,module,exports){
"use strict";

var mergeMap_1 = require('../operators/mergeMap');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);
}
exports.mergeMap = mergeMap;
//# sourceMappingURL=mergeMap.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1lcmdlTWFwLmpzIl0sIm5hbWVzIjpbIm1lcmdlTWFwXzEiLCJyZXF1aXJlIiwibWVyZ2VNYXAiLCJwcm9qZWN0IiwicmVzdWx0U2VsZWN0b3IiLCJjb25jdXJyZW50IiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxhQUFhQyxRQUFRLHVCQUFSLENBQWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBEQSxTQUFTQyxRQUFULENBQWtCQyxPQUFsQixFQUEyQkMsY0FBM0IsRUFBMkNDLFVBQTNDLEVBQXVEO0FBQ25ELE1BQUlBLGVBQWUsS0FBSyxDQUF4QixFQUEyQjtBQUFFQSxpQkFBYUMsT0FBT0MsaUJBQXBCO0FBQXdDO0FBQ3JFLFNBQU9QLFdBQVdFLFFBQVgsQ0FBb0JDLE9BQXBCLEVBQTZCQyxjQUE3QixFQUE2Q0MsVUFBN0MsRUFBeUQsSUFBekQsQ0FBUDtBQUNIO0FBQ0RHLFFBQVFOLFFBQVIsR0FBbUJBLFFBQW5CO0FBQ0EiLCJmaWxlIjoibWVyZ2VNYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZU1hcF8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL21lcmdlTWFwJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBtZXJnZUFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBlYWNoIGxldHRlciB0byBhbiBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJyk7XG4gKiB2YXIgcmVzdWx0ID0gbGV0dGVycy5tZXJnZU1hcCh4ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkubWFwKGkgPT4geCtpKVxuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gYTBcbiAqIC8vIGIwXG4gKiAvLyBjMFxuICogLy8gYTFcbiAqIC8vIGIxXG4gKiAvLyBjMVxuICogLy8gY29udGludWVzIHRvIGxpc3QgYSxiLGMgd2l0aCByZXNwZWN0aXZlIGFzY2VuZGluZyBpbnRlZ2Vyc1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgbWVyZ2VNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIG1lcmdlTWFwXzEubWVyZ2VNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKHRoaXMpO1xufVxuZXhwb3J0cy5tZXJnZU1hcCA9IG1lcmdlTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXAuanMubWFwIl19
},{"../operators/mergeMap":34}],31:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var Set_1 = require('../util/Set');
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
    return function (source) {
        return source.lift(new DistinctOperator(keySelector, flushes));
    };
}
exports.distinct = distinct;
var DistinctOperator = function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new Set_1.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        } else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        } catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.DistinctSubscriber = DistinctSubscriber;
//# sourceMappingURL=distinct.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRpc3RpbmN0LmpzIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIk91dGVyU3Vic2NyaWJlcl8xIiwicmVxdWlyZSIsInN1YnNjcmliZVRvUmVzdWx0XzEiLCJTZXRfMSIsImRpc3RpbmN0Iiwia2V5U2VsZWN0b3IiLCJmbHVzaGVzIiwic291cmNlIiwibGlmdCIsIkRpc3RpbmN0T3BlcmF0b3IiLCJleHBvcnRzIiwiY2FsbCIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJEaXN0aW5jdFN1YnNjcmliZXIiLCJfc3VwZXIiLCJkZXN0aW5hdGlvbiIsInZhbHVlcyIsIlNldCIsImFkZCIsInN1YnNjcmliZVRvUmVzdWx0Iiwibm90aWZ5TmV4dCIsIm91dGVyVmFsdWUiLCJpbm5lclZhbHVlIiwib3V0ZXJJbmRleCIsImlubmVySW5kZXgiLCJpbm5lclN1YiIsImNsZWFyIiwibm90aWZ5RXJyb3IiLCJlcnJvciIsIl9lcnJvciIsIl9uZXh0IiwidmFsdWUiLCJfdXNlS2V5U2VsZWN0b3IiLCJfZmluYWxpemVOZXh0Iiwia2V5IiwiZXJyIiwiaGFzIiwibmV4dCIsIk91dGVyU3Vic2NyaWJlciJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsWUFBYSxhQUFRLFVBQUtBLFNBQWQsSUFBNEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSUMsQ0FBVCxJQUFjRCxDQUFkO0FBQWlCLFlBQUlBLEVBQUVFLGNBQUYsQ0FBaUJELENBQWpCLENBQUosRUFBeUJGLEVBQUVFLENBQUYsSUFBT0QsRUFBRUMsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBU0UsRUFBVCxHQUFjO0FBQUUsYUFBS0MsV0FBTCxHQUFtQkwsQ0FBbkI7QUFBdUI7QUFDdkNBLE1BQUVNLFNBQUYsR0FBY0wsTUFBTSxJQUFOLEdBQWFNLE9BQU9DLE1BQVAsQ0FBY1AsQ0FBZCxDQUFiLElBQWlDRyxHQUFHRSxTQUFILEdBQWVMLEVBQUVLLFNBQWpCLEVBQTRCLElBQUlGLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJSyxvQkFBb0JDLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJQyxzQkFBc0JELFFBQVEsMkJBQVIsQ0FBMUI7QUFDQSxJQUFJRSxRQUFRRixRQUFRLGFBQVIsQ0FBWjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2Q0EsU0FBU0csUUFBVCxDQUFrQkMsV0FBbEIsRUFBK0JDLE9BQS9CLEVBQXdDO0FBQ3BDLFdBQU8sVUFBVUMsTUFBVixFQUFrQjtBQUFFLGVBQU9BLE9BQU9DLElBQVAsQ0FBWSxJQUFJQyxnQkFBSixDQUFxQkosV0FBckIsRUFBa0NDLE9BQWxDLENBQVosQ0FBUDtBQUFpRSxLQUE1RjtBQUNIO0FBQ0RJLFFBQVFOLFFBQVIsR0FBbUJBLFFBQW5CO0FBQ0EsSUFBSUssbUJBQW9CLFlBQVk7QUFDaEMsYUFBU0EsZ0JBQVQsQ0FBMEJKLFdBQTFCLEVBQXVDQyxPQUF2QyxFQUFnRDtBQUM1QyxhQUFLRCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLGFBQUtDLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0RHLHFCQUFpQlosU0FBakIsQ0FBMkJjLElBQTNCLEdBQWtDLFVBQVVDLFVBQVYsRUFBc0JMLE1BQXRCLEVBQThCO0FBQzVELGVBQU9BLE9BQU9NLFNBQVAsQ0FBaUIsSUFBSUMsa0JBQUosQ0FBdUJGLFVBQXZCLEVBQW1DLEtBQUtQLFdBQXhDLEVBQXFELEtBQUtDLE9BQTFELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBT0csZ0JBQVA7QUFDSCxDQVR1QixFQUF4QjtBQVVBOzs7OztBQUtBLElBQUlLLHFCQUFzQixVQUFVQyxNQUFWLEVBQWtCO0FBQ3hDekIsY0FBVXdCLGtCQUFWLEVBQThCQyxNQUE5QjtBQUNBLGFBQVNELGtCQUFULENBQTRCRSxXQUE1QixFQUF5Q1gsV0FBekMsRUFBc0RDLE9BQXRELEVBQStEO0FBQzNEUyxlQUFPSixJQUFQLENBQVksSUFBWixFQUFrQkssV0FBbEI7QUFDQSxhQUFLWCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLGFBQUtZLE1BQUwsR0FBYyxJQUFJZCxNQUFNZSxHQUFWLEVBQWQ7QUFDQSxZQUFJWixPQUFKLEVBQWE7QUFDVCxpQkFBS2EsR0FBTCxDQUFTakIsb0JBQW9Ca0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDZCxPQUE1QyxDQUFUO0FBQ0g7QUFDSjtBQUNEUSx1QkFBbUJqQixTQUFuQixDQUE2QndCLFVBQTdCLEdBQTBDLFVBQVVDLFVBQVYsRUFBc0JDLFVBQXRCLEVBQWtDQyxVQUFsQyxFQUE4Q0MsVUFBOUMsRUFBMERDLFFBQTFELEVBQW9FO0FBQzFHLGFBQUtULE1BQUwsQ0FBWVUsS0FBWjtBQUNILEtBRkQ7QUFHQWIsdUJBQW1CakIsU0FBbkIsQ0FBNkIrQixXQUE3QixHQUEyQyxVQUFVQyxLQUFWLEVBQWlCSCxRQUFqQixFQUEyQjtBQUNsRSxhQUFLSSxNQUFMLENBQVlELEtBQVo7QUFDSCxLQUZEO0FBR0FmLHVCQUFtQmpCLFNBQW5CLENBQTZCa0MsS0FBN0IsR0FBcUMsVUFBVUMsS0FBVixFQUFpQjtBQUNsRCxZQUFJLEtBQUszQixXQUFULEVBQXNCO0FBQ2xCLGlCQUFLNEIsZUFBTCxDQUFxQkQsS0FBckI7QUFDSCxTQUZELE1BR0s7QUFDRCxpQkFBS0UsYUFBTCxDQUFtQkYsS0FBbkIsRUFBMEJBLEtBQTFCO0FBQ0g7QUFDSixLQVBEO0FBUUFsQix1QkFBbUJqQixTQUFuQixDQUE2Qm9DLGVBQTdCLEdBQStDLFVBQVVELEtBQVYsRUFBaUI7QUFDNUQsWUFBSUcsR0FBSjtBQUNBLFlBQUluQixjQUFjLEtBQUtBLFdBQXZCO0FBQ0EsWUFBSTtBQUNBbUIsa0JBQU0sS0FBSzlCLFdBQUwsQ0FBaUIyQixLQUFqQixDQUFOO0FBQ0gsU0FGRCxDQUdBLE9BQU9JLEdBQVAsRUFBWTtBQUNScEIsd0JBQVlhLEtBQVosQ0FBa0JPLEdBQWxCO0FBQ0E7QUFDSDtBQUNELGFBQUtGLGFBQUwsQ0FBbUJDLEdBQW5CLEVBQXdCSCxLQUF4QjtBQUNILEtBWEQ7QUFZQWxCLHVCQUFtQmpCLFNBQW5CLENBQTZCcUMsYUFBN0IsR0FBNkMsVUFBVUMsR0FBVixFQUFlSCxLQUFmLEVBQXNCO0FBQy9ELFlBQUlmLFNBQVMsS0FBS0EsTUFBbEI7QUFDQSxZQUFJLENBQUNBLE9BQU9vQixHQUFQLENBQVdGLEdBQVgsQ0FBTCxFQUFzQjtBQUNsQmxCLG1CQUFPRSxHQUFQLENBQVdnQixHQUFYO0FBQ0EsaUJBQUtuQixXQUFMLENBQWlCc0IsSUFBakIsQ0FBc0JOLEtBQXRCO0FBQ0g7QUFDSixLQU5EO0FBT0EsV0FBT2xCLGtCQUFQO0FBQ0gsQ0E1Q3lCLENBNEN4QmQsa0JBQWtCdUMsZUE1Q00sQ0FBMUI7QUE2Q0E3QixRQUFRSSxrQkFBUixHQUE2QkEsa0JBQTdCO0FBQ0EiLCJmaWxlIjoiZGlzdGluY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBTZXRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvU2V0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gcHJldmlvdXMgaXRlbXMuXG4gKlxuICogSWYgYSBrZXlTZWxlY3RvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIHByb2plY3QgZWFjaCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBpbnRvIGEgbmV3IHZhbHVlIHRoYXQgaXQgd2lsbFxuICogY2hlY2sgZm9yIGVxdWFsaXR5IHdpdGggcHJldmlvdXNseSBwcm9qZWN0ZWQgdmFsdWVzLiBJZiBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCB1c2UgZWFjaCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIG9ic2VydmFibGUgZGlyZWN0bHkgd2l0aCBhbiBlcXVhbGl0eSBjaGVjayBhZ2FpbnN0IHByZXZpb3VzIHZhbHVlcy5cbiAqXG4gKiBJbiBKYXZhU2NyaXB0IHJ1bnRpbWVzIHRoYXQgc3VwcG9ydCBgU2V0YCwgdGhpcyBvcGVyYXRvciB3aWxsIHVzZSBhIGBTZXRgIHRvIGltcHJvdmUgcGVyZm9ybWFuY2Ugb2YgdGhlIGRpc3RpbmN0IHZhbHVlIGNoZWNraW5nLlxuICpcbiAqIEluIG90aGVyIHJ1bnRpbWVzLCB0aGlzIG9wZXJhdG9yIHdpbGwgdXNlIGEgbWluaW1hbCBpbXBsZW1lbnRhdGlvbiBvZiBgU2V0YCB0aGF0IHJlbGllcyBvbiBhbiBgQXJyYXlgIGFuZCBgaW5kZXhPZmAgdW5kZXIgdGhlXG4gKiBob29kLCBzbyBwZXJmb3JtYW5jZSB3aWxsIGRlZ3JhZGUgYXMgbW9yZSB2YWx1ZXMgYXJlIGNoZWNrZWQgZm9yIGRpc3RpbmN0aW9uLiBFdmVuIGluIG5ld2VyIGJyb3dzZXJzLCBhIGxvbmctcnVubmluZyBgZGlzdGluY3RgXG4gKiB1c2UgbWlnaHQgcmVzdWx0IGluIG1lbW9yeSBsZWFrcy4gVG8gaGVscCBhbGxldmlhdGUgdGhpcyBpbiBzb21lIHNjZW5hcmlvcywgYW4gb3B0aW9uYWwgYGZsdXNoZXNgIHBhcmFtZXRlciBpcyBhbHNvIHByb3ZpZGVkIHNvXG4gKiB0aGF0IHRoZSBpbnRlcm5hbCBgU2V0YCBjYW4gYmUgXCJmbHVzaGVkXCIsIGJhc2ljYWxseSBjbGVhcmluZyBpdCBvZiB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QSBzaW1wbGUgZXhhbXBsZSB3aXRoIG51bWJlcnM8L2NhcHRpb24+XG4gKiBPYnNlcnZhYmxlLm9mKDEsIDEsIDIsIDIsIDIsIDEsIDIsIDMsIDQsIDMsIDIsIDEpXG4gKiAgIC5kaXN0aW5jdCgpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIDEsIDIsIDMsIDRcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIHVzaW5nIGEga2V5U2VsZWN0b3IgZnVuY3Rpb248L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgIGFnZTogbnVtYmVyLFxuICogICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdCgocDogUGVyc29uKSA9PiBwLm5hbWUpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2tleVNlbGVjdG9yXSBPcHRpb25hbCBmdW5jdGlvbiB0byBzZWxlY3Qgd2hpY2ggdmFsdWUgeW91IHdhbnQgdG8gY2hlY2sgYXMgZGlzdGluY3QuXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IFtmbHVzaGVzXSBPcHRpb25hbCBPYnNlcnZhYmxlIGZvciBmbHVzaGluZyB0aGUgaW50ZXJuYWwgSGFzaFNldCBvZiB0aGUgb3BlcmF0b3IuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGRpc3RpbmN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdChrZXlTZWxlY3RvciwgZmx1c2hlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRGlzdGluY3RPcGVyYXRvcihrZXlTZWxlY3RvciwgZmx1c2hlcykpOyB9O1xufVxuZXhwb3J0cy5kaXN0aW5jdCA9IGRpc3RpbmN0O1xudmFyIERpc3RpbmN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0T3BlcmF0b3Ioa2V5U2VsZWN0b3IsIGZsdXNoZXMpIHtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmZsdXNoZXMgPSBmbHVzaGVzO1xuICAgIH1cbiAgICBEaXN0aW5jdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGlzdGluY3RTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMua2V5U2VsZWN0b3IsIHRoaXMuZmx1c2hlcykpO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEaXN0aW5jdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXN0aW5jdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBrZXlTZWxlY3RvciwgZmx1c2hlcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgU2V0XzEuU2V0KCk7XG4gICAgICAgIGlmIChmbHVzaGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGZsdXNoZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuY2xlYXIoKTtcbiAgICB9O1xuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZUtleVNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplTmV4dCh2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLl91c2VLZXlTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5hbGl6ZU5leHQoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLl9maW5hbGl6ZU5leHQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGlmICghdmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWRkKGtleSk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuRGlzdGluY3RTdWJzY3JpYmVyID0gRGlzdGluY3RTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3QuanMubWFwIl19
},{"../OuterSubscriber":6,"../util/Set":40,"../util/subscribeToResult":52}],32:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=filter.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbHRlci5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJTdWJzY3JpYmVyXzEiLCJyZXF1aXJlIiwiZmlsdGVyIiwicHJlZGljYXRlIiwidGhpc0FyZyIsImZpbHRlck9wZXJhdG9yRnVuY3Rpb24iLCJzb3VyY2UiLCJsaWZ0IiwiRmlsdGVyT3BlcmF0b3IiLCJleHBvcnRzIiwiY2FsbCIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJGaWx0ZXJTdWJzY3JpYmVyIiwiX3N1cGVyIiwiZGVzdGluYXRpb24iLCJjb3VudCIsIl9uZXh0IiwidmFsdWUiLCJyZXN1bHQiLCJlcnIiLCJlcnJvciIsIm5leHQiLCJTdWJzY3JpYmVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxZQUFhLGFBQVEsVUFBS0EsU0FBZCxJQUE0QixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJQyxDQUFULElBQWNELENBQWQ7QUFBaUIsWUFBSUEsRUFBRUUsY0FBRixDQUFpQkQsQ0FBakIsQ0FBSixFQUF5QkYsRUFBRUUsQ0FBRixJQUFPRCxFQUFFQyxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTRSxFQUFULEdBQWM7QUFBRSxhQUFLQyxXQUFMLEdBQW1CTCxDQUFuQjtBQUF1QjtBQUN2Q0EsTUFBRU0sU0FBRixHQUFjTCxNQUFNLElBQU4sR0FBYU0sT0FBT0MsTUFBUCxDQUFjUCxDQUFkLENBQWIsSUFBaUNHLEdBQUdFLFNBQUgsR0FBZUwsRUFBRUssU0FBakIsRUFBNEIsSUFBSUYsRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUlLLGVBQWVDLFFBQVEsZUFBUixDQUFuQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQSxTQUFTQyxNQUFULENBQWdCQyxTQUFoQixFQUEyQkMsT0FBM0IsRUFBb0M7QUFDaEMsV0FBTyxTQUFTQyxzQkFBVCxDQUFnQ0MsTUFBaEMsRUFBd0M7QUFDM0MsZUFBT0EsT0FBT0MsSUFBUCxDQUFZLElBQUlDLGNBQUosQ0FBbUJMLFNBQW5CLEVBQThCQyxPQUE5QixDQUFaLENBQVA7QUFDSCxLQUZEO0FBR0g7QUFDREssUUFBUVAsTUFBUixHQUFpQkEsTUFBakI7QUFDQSxJQUFJTSxpQkFBa0IsWUFBWTtBQUM5QixhQUFTQSxjQUFULENBQXdCTCxTQUF4QixFQUFtQ0MsT0FBbkMsRUFBNEM7QUFDeEMsYUFBS0QsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxhQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNESSxtQkFBZVgsU0FBZixDQUF5QmEsSUFBekIsR0FBZ0MsVUFBVUMsVUFBVixFQUFzQkwsTUFBdEIsRUFBOEI7QUFDMUQsZUFBT0EsT0FBT00sU0FBUCxDQUFpQixJQUFJQyxnQkFBSixDQUFxQkYsVUFBckIsRUFBaUMsS0FBS1IsU0FBdEMsRUFBaUQsS0FBS0MsT0FBdEQsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPSSxjQUFQO0FBQ0gsQ0FUcUIsRUFBdEI7QUFVQTs7Ozs7QUFLQSxJQUFJSyxtQkFBb0IsVUFBVUMsTUFBVixFQUFrQjtBQUN0Q3hCLGNBQVV1QixnQkFBVixFQUE0QkMsTUFBNUI7QUFDQSxhQUFTRCxnQkFBVCxDQUEwQkUsV0FBMUIsRUFBdUNaLFNBQXZDLEVBQWtEQyxPQUFsRCxFQUEyRDtBQUN2RFUsZUFBT0osSUFBUCxDQUFZLElBQVosRUFBa0JLLFdBQWxCO0FBQ0EsYUFBS1osU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxhQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxhQUFLWSxLQUFMLEdBQWEsQ0FBYjtBQUNIO0FBQ0Q7QUFDQTtBQUNBSCxxQkFBaUJoQixTQUFqQixDQUEyQm9CLEtBQTNCLEdBQW1DLFVBQVVDLEtBQVYsRUFBaUI7QUFDaEQsWUFBSUMsTUFBSjtBQUNBLFlBQUk7QUFDQUEscUJBQVMsS0FBS2hCLFNBQUwsQ0FBZU8sSUFBZixDQUFvQixLQUFLTixPQUF6QixFQUFrQ2MsS0FBbEMsRUFBeUMsS0FBS0YsS0FBTCxFQUF6QyxDQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU9JLEdBQVAsRUFBWTtBQUNSLGlCQUFLTCxXQUFMLENBQWlCTSxLQUFqQixDQUF1QkQsR0FBdkI7QUFDQTtBQUNIO0FBQ0QsWUFBSUQsTUFBSixFQUFZO0FBQ1IsaUJBQUtKLFdBQUwsQ0FBaUJPLElBQWpCLENBQXNCSixLQUF0QjtBQUNIO0FBQ0osS0FaRDtBQWFBLFdBQU9MLGdCQUFQO0FBQ0gsQ0F4QnVCLENBd0J0QmIsYUFBYXVCLFVBeEJTLENBQXhCO0FBeUJBIiwiZmlsZSI6ImZpbHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRmlsdGVyIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IG9ubHkgZW1pdHRpbmcgdGhvc2UgdGhhdFxuICogc2F0aXNmeSBhIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2VcbiAqIFtBcnJheS5wcm90b3R5cGUuZmlsdGVyKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlciksXG4gKiBpdCBvbmx5IGVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIGlmIGl0IHBhc3NlcyBhIGNyaXRlcmlvbiBmdW5jdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maWx0ZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbC1rbm93biBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kLCB0aGlzIG9wZXJhdG9yXG4gKiB0YWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHBhc3NlcyB0aGVtIHRocm91Z2ggYSBgcHJlZGljYXRlYFxuICogZnVuY3Rpb24gYW5kIG9ubHkgZW1pdHMgdGhvc2UgdmFsdWVzIHRoYXQgeWllbGRlZCBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IGNsaWNrIGV2ZW50cyB3aG9zZSB0YXJnZXQgd2FzIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc09uRGl2cyA9IGNsaWNrcy5maWx0ZXIoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgaWdub3JlRWxlbWVudHN9XG4gKiBAc2VlIHtAbGluayBwYXJ0aXRpb259XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBib29sZWFufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0aGF0XG4gKiBldmFsdWF0ZXMgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsXG4gKiB0aGUgdmFsdWUgaXMgZW1pdHRlZCwgaWYgYGZhbHNlYCB0aGUgdmFsdWUgaXMgbm90IHBhc3NlZCB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZVxuICogZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyXG4gKiBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlXG4gKiBhbGxvd2VkIGJ5IHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgZmlsdGVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpbHRlck9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xudmFyIEZpbHRlck9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIEZpbHRlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmlsdGVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaWx0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIC8vIHRoZSB0cnkgY2F0Y2ggYmxvY2sgYmVsb3cgaXMgbGVmdCBzcGVjaWZpY2FsbHkgZm9yXG4gICAgLy8gb3B0aW1pemF0aW9uIGFuZCBwZXJmIHJlYXNvbnMuIGEgdHJ5Q2F0Y2hlciBpcyBub3QgbmVjZXNzYXJ5IGhlcmUuXG4gICAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl19
},{"../Subscriber":9}],33:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=map.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hcC5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJTdWJzY3JpYmVyXzEiLCJyZXF1aXJlIiwibWFwIiwicHJvamVjdCIsInRoaXNBcmciLCJtYXBPcGVyYXRpb24iLCJzb3VyY2UiLCJUeXBlRXJyb3IiLCJsaWZ0IiwiTWFwT3BlcmF0b3IiLCJleHBvcnRzIiwiY2FsbCIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJNYXBTdWJzY3JpYmVyIiwiX3N1cGVyIiwiZGVzdGluYXRpb24iLCJjb3VudCIsIl9uZXh0IiwidmFsdWUiLCJyZXN1bHQiLCJlcnIiLCJlcnJvciIsIm5leHQiLCJTdWJzY3JpYmVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxZQUFhLGFBQVEsVUFBS0EsU0FBZCxJQUE0QixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJQyxDQUFULElBQWNELENBQWQ7QUFBaUIsWUFBSUEsRUFBRUUsY0FBRixDQUFpQkQsQ0FBakIsQ0FBSixFQUF5QkYsRUFBRUUsQ0FBRixJQUFPRCxFQUFFQyxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTRSxFQUFULEdBQWM7QUFBRSxhQUFLQyxXQUFMLEdBQW1CTCxDQUFuQjtBQUF1QjtBQUN2Q0EsTUFBRU0sU0FBRixHQUFjTCxNQUFNLElBQU4sR0FBYU0sT0FBT0MsTUFBUCxDQUFjUCxDQUFkLENBQWIsSUFBaUNHLEdBQUdFLFNBQUgsR0FBZUwsRUFBRUssU0FBakIsRUFBNEIsSUFBSUYsRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUlLLGVBQWVDLFFBQVEsZUFBUixDQUFuQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0EsU0FBU0MsR0FBVCxDQUFhQyxPQUFiLEVBQXNCQyxPQUF0QixFQUErQjtBQUMzQixXQUFPLFNBQVNDLFlBQVQsQ0FBc0JDLE1BQXRCLEVBQThCO0FBQ2pDLFlBQUksT0FBT0gsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUMvQixrQkFBTSxJQUFJSSxTQUFKLENBQWMsNERBQWQsQ0FBTjtBQUNIO0FBQ0QsZUFBT0QsT0FBT0UsSUFBUCxDQUFZLElBQUlDLFdBQUosQ0FBZ0JOLE9BQWhCLEVBQXlCQyxPQUF6QixDQUFaLENBQVA7QUFDSCxLQUxEO0FBTUg7QUFDRE0sUUFBUVIsR0FBUixHQUFjQSxHQUFkO0FBQ0EsSUFBSU8sY0FBZSxZQUFZO0FBQzNCLGFBQVNBLFdBQVQsQ0FBcUJOLE9BQXJCLEVBQThCQyxPQUE5QixFQUF1QztBQUNuQyxhQUFLRCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxhQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNESyxnQkFBWVosU0FBWixDQUFzQmMsSUFBdEIsR0FBNkIsVUFBVUMsVUFBVixFQUFzQk4sTUFBdEIsRUFBOEI7QUFDdkQsZUFBT0EsT0FBT08sU0FBUCxDQUFpQixJQUFJQyxhQUFKLENBQWtCRixVQUFsQixFQUE4QixLQUFLVCxPQUFuQyxFQUE0QyxLQUFLQyxPQUFqRCxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU9LLFdBQVA7QUFDSCxDQVRrQixFQUFuQjtBQVVBQyxRQUFRRCxXQUFSLEdBQXNCQSxXQUF0QjtBQUNBOzs7OztBQUtBLElBQUlLLGdCQUFpQixVQUFVQyxNQUFWLEVBQWtCO0FBQ25DekIsY0FBVXdCLGFBQVYsRUFBeUJDLE1BQXpCO0FBQ0EsYUFBU0QsYUFBVCxDQUF1QkUsV0FBdkIsRUFBb0NiLE9BQXBDLEVBQTZDQyxPQUE3QyxFQUFzRDtBQUNsRFcsZUFBT0osSUFBUCxDQUFZLElBQVosRUFBa0JLLFdBQWxCO0FBQ0EsYUFBS2IsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsYUFBS2MsS0FBTCxHQUFhLENBQWI7QUFDQSxhQUFLYixPQUFMLEdBQWVBLFdBQVcsSUFBMUI7QUFDSDtBQUNEO0FBQ0E7QUFDQVUsa0JBQWNqQixTQUFkLENBQXdCcUIsS0FBeEIsR0FBZ0MsVUFBVUMsS0FBVixFQUFpQjtBQUM3QyxZQUFJQyxNQUFKO0FBQ0EsWUFBSTtBQUNBQSxxQkFBUyxLQUFLakIsT0FBTCxDQUFhUSxJQUFiLENBQWtCLEtBQUtQLE9BQXZCLEVBQWdDZSxLQUFoQyxFQUF1QyxLQUFLRixLQUFMLEVBQXZDLENBQVQ7QUFDSCxTQUZELENBR0EsT0FBT0ksR0FBUCxFQUFZO0FBQ1IsaUJBQUtMLFdBQUwsQ0FBaUJNLEtBQWpCLENBQXVCRCxHQUF2QjtBQUNBO0FBQ0g7QUFDRCxhQUFLTCxXQUFMLENBQWlCTyxJQUFqQixDQUFzQkgsTUFBdEI7QUFDSCxLQVZEO0FBV0EsV0FBT04sYUFBUDtBQUNILENBdEJvQixDQXNCbkJkLGFBQWF3QixVQXRCTSxDQUFyQjtBQXVCQSIsImZpbGUiOiJtYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQXBwbGllcyBhIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoZSByZXN1bHRpbmcgdmFsdWVzIGFzIGFuIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2UgW0FycmF5LnByb3RvdHlwZS5tYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKSxcbiAqIGl0IHBhc3NlcyBlYWNoIHNvdXJjZSB2YWx1ZSB0aHJvdWdoIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gZ2V0XG4gKiBjb3JyZXNwb25kaW5nIG91dHB1dCB2YWx1ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwga25vd24gYEFycmF5LnByb3RvdHlwZS5tYXBgIGZ1bmN0aW9uLCB0aGlzIG9wZXJhdG9yXG4gKiBhcHBsaWVzIGEgcHJvamVjdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBlbWl0cyB0aGF0IHByb2plY3Rpb24gaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwVG99XG4gKiBAc2VlIHtAbGluayBwbHVja31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gcHJvamVjdCBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqIHRvIGVhY2ggYHZhbHVlYCBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzXG4gKiB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlXG4gKiBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRlZmluZSB3aGF0IGB0aGlzYCBpcyBpbiB0aGVcbiAqIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBtYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcE9wZXJhdGlvbihzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xudmFyIE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWFwT3BlcmF0b3IgPSBNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5PVEU6IFRoaXMgbG9va3MgdW5vcHRpbWl6ZWQsIGJ1dCBpdCdzIGFjdHVhbGx5IHB1cnBvc2VmdWxseSBOT1RcbiAgICAvLyB1c2luZyB0cnkvY2F0Y2ggb3B0aW1pemF0aW9ucy5cbiAgICBNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiXX0=
},{"../Subscriber":9}],34:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return function mergeMapOperatorFunction(source) {
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
            resultSelector = null;
        }
        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
    };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1lcmdlTWFwLmpzIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInN1YnNjcmliZVRvUmVzdWx0XzEiLCJyZXF1aXJlIiwiT3V0ZXJTdWJzY3JpYmVyXzEiLCJtZXJnZU1hcCIsInByb2plY3QiLCJyZXN1bHRTZWxlY3RvciIsImNvbmN1cnJlbnQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsIm1lcmdlTWFwT3BlcmF0b3JGdW5jdGlvbiIsInNvdXJjZSIsImxpZnQiLCJNZXJnZU1hcE9wZXJhdG9yIiwiZXhwb3J0cyIsImNhbGwiLCJvYnNlcnZlciIsInN1YnNjcmliZSIsIk1lcmdlTWFwU3Vic2NyaWJlciIsIl9zdXBlciIsImRlc3RpbmF0aW9uIiwiaGFzQ29tcGxldGVkIiwiYnVmZmVyIiwiYWN0aXZlIiwiaW5kZXgiLCJfbmV4dCIsInZhbHVlIiwiX3RyeU5leHQiLCJwdXNoIiwicmVzdWx0IiwiZXJyIiwiZXJyb3IiLCJfaW5uZXJTdWIiLCJpc2giLCJhZGQiLCJzdWJzY3JpYmVUb1Jlc3VsdCIsIl9jb21wbGV0ZSIsImxlbmd0aCIsImNvbXBsZXRlIiwibm90aWZ5TmV4dCIsIm91dGVyVmFsdWUiLCJpbm5lclZhbHVlIiwib3V0ZXJJbmRleCIsImlubmVySW5kZXgiLCJpbm5lclN1YiIsIl9ub3RpZnlSZXN1bHRTZWxlY3RvciIsIm5leHQiLCJub3RpZnlDb21wbGV0ZSIsInJlbW92ZSIsInNoaWZ0IiwiT3V0ZXJTdWJzY3JpYmVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxZQUFhLGFBQVEsVUFBS0EsU0FBZCxJQUE0QixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJQyxDQUFULElBQWNELENBQWQ7QUFBaUIsWUFBSUEsRUFBRUUsY0FBRixDQUFpQkQsQ0FB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TCxDQUFpQmtCLFFBQWpCO0FBQ0g7QUFDSixLQVZEO0FBV0EsV0FBT3BCLGtCQUFQO0FBQ0gsQ0ExRXlCLENBMEV4QmYsa0JBQWtCK0MsZUExRU0sQ0FBMUI7QUEyRUFwQyxRQUFRSSxrQkFBUixHQUE2QkEsa0JBQTdCO0FBQ0EiLCJmaWxlIjoibWVyZ2VNYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIG1lcmdlQWxsfS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZU1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUsIGFuZCB0aGVuIG1lcmdpbmcgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGFuZFxuICogZW1pdHRpbmcgdGhlIHJlc3VsdHMgb2YgdGhpcyBtZXJnZXIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIGVhY2ggbGV0dGVyIHRvIGFuIE9ic2VydmFibGUgdGlja2luZyBldmVyeSAxIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKTtcbiAqIHZhciByZXN1bHQgPSBsZXR0ZXJzLm1lcmdlTWFwKHggPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS5tYXAoaSA9PiB4K2kpXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyBhMFxuICogLy8gYjBcbiAqIC8vIGMwXG4gKiAvLyBhMVxuICogLy8gYjFcbiAqIC8vIGMxXG4gKiAvLyBjb250aW51ZXMgdG8gbGlzdCBhLGIsYyB3aXRoIHJlc3BlY3RpdmUgYXNjZW5kaW5nIGludGVnZXJzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZUlucHV0fSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiAoYW5kIHRoZSBvcHRpb25hbCBgcmVzdWx0U2VsZWN0b3JgKSB0byBlYWNoIGl0ZW0gZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBtZXJnaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBPYnNlcnZhYmxlcyBvYnRhaW5lZFxuICogZnJvbSB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICogQG1ldGhvZCBtZXJnZU1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VNYXBPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkpO1xuICAgIH07XG59XG5leHBvcnRzLm1lcmdlTWFwID0gbWVyZ2VNYXA7XG52YXIgTWVyZ2VNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZU1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlTWFwU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VNYXBPcGVyYXRvciA9IE1lcmdlTWFwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKGlzaCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbm90aWZ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZU1hcFN1YnNjcmliZXIgPSBNZXJnZU1hcFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcC5qcy5tYXAiXX0=
},{"../OuterSubscriber":6,"../util/subscribeToResult":52}],35:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}();
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification,
            destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber);
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}();
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm9ic2VydmVPbi5qcyJdLCJuYW1lcyI6WyJfX2V4dGVuZHMiLCJkIiwiYiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJTdWJzY3JpYmVyXzEiLCJyZXF1aXJlIiwiTm90aWZpY2F0aW9uXzEiLCJvYnNlcnZlT24iLCJzY2hlZHVsZXIiLCJkZWxheSIsIm9ic2VydmVPbk9wZXJhdG9yRnVuY3Rpb24iLCJzb3VyY2UiLCJsaWZ0IiwiT2JzZXJ2ZU9uT3BlcmF0b3IiLCJleHBvcnRzIiwiY2FsbCIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJPYnNlcnZlT25TdWJzY3JpYmVyIiwiX3N1cGVyIiwiZGVzdGluYXRpb24iLCJkaXNwYXRjaCIsImFyZyIsIm5vdGlmaWNhdGlvbiIsIm9ic2VydmUiLCJ1bnN1YnNjcmliZSIsInNjaGVkdWxlTWVzc2FnZSIsImFkZCIsInNjaGVkdWxlIiwiT2JzZXJ2ZU9uTWVzc2FnZSIsIl9uZXh0IiwidmFsdWUiLCJOb3RpZmljYXRpb24iLCJjcmVhdGVOZXh0IiwiX2Vycm9yIiwiZXJyIiwiY3JlYXRlRXJyb3IiLCJfY29tcGxldGUiLCJjcmVhdGVDb21wbGV0ZSIsIlN1YnNjcmliZXIiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSUssZUFBZUMsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSUMsaUJBQWlCRCxRQUFRLGlCQUFSLENBQXJCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0EsU0FBU0UsU0FBVCxDQUFtQkMsU0FBbkIsRUFBOEJDLEtBQTlCLEVBQXFDO0FBQ2pDLFFBQUlBLFVBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUFFQSxnQkFBUSxDQUFSO0FBQVk7QUFDcEMsV0FBTyxTQUFTQyx5QkFBVCxDQUFtQ0MsTUFBbkMsRUFBMkM7QUFDOUMsZUFBT0EsT0FBT0MsSUFBUCxDQUFZLElBQUlDLGlCQUFKLENBQXNCTCxTQUF0QixFQUFpQ0MsS0FBakMsQ0FBWixDQUFQO0FBQ0gsS0FGRDtBQUdIO0FBQ0RLLFFBQVFQLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0EsSUFBSU0sb0JBQXFCLFlBQVk7QUFDakMsYUFBU0EsaUJBQVQsQ0FBMkJMLFNBQTNCLEVBQXNDQyxLQUF0QyxFQUE2QztBQUN6QyxZQUFJQSxVQUFVLEtBQUssQ0FBbkIsRUFBc0I7QUFBRUEsb0JBQVEsQ0FBUjtBQUFZO0FBQ3BDLGFBQUtELFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsYUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDREksc0JBQWtCWixTQUFsQixDQUE0QmMsSUFBNUIsR0FBbUMsVUFBVUMsVUFBVixFQUFzQkwsTUFBdEIsRUFBOEI7QUFDN0QsZUFBT0EsT0FBT00sU0FBUCxDQUFpQixJQUFJQyxtQkFBSixDQUF3QkYsVUFBeEIsRUFBb0MsS0FBS1IsU0FBekMsRUFBb0QsS0FBS0MsS0FBekQsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPSSxpQkFBUDtBQUNILENBVndCLEVBQXpCO0FBV0FDLFFBQVFELGlCQUFSLEdBQTRCQSxpQkFBNUI7QUFDQTs7Ozs7QUFLQSxJQUFJSyxzQkFBdUIsVUFBVUMsTUFBVixFQUFrQjtBQUN6Q3pCLGNBQVV3QixtQkFBVixFQUErQkMsTUFBL0I7QUFDQSxhQUFTRCxtQkFBVCxDQUE2QkUsV0FBN0IsRUFBMENaLFNBQTFDLEVBQXFEQyxLQUFyRCxFQUE0RDtBQUN4RCxZQUFJQSxVQUFVLEtBQUssQ0FBbkIsRUFBc0I7QUFBRUEsb0JBQVEsQ0FBUjtBQUFZO0FBQ3BDVSxlQUFPSixJQUFQLENBQVksSUFBWixFQUFrQkssV0FBbEI7QUFDQSxhQUFLWixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLGFBQUtDLEtBQUwsR0FBYUEsS0FBYjtBQUNIO0FBQ0RTLHdCQUFvQkcsUUFBcEIsR0FBK0IsVUFBVUMsR0FBVixFQUFlO0FBQzFDLFlBQUlDLGVBQWVELElBQUlDLFlBQXZCO0FBQUEsWUFBcUNILGNBQWNFLElBQUlGLFdBQXZEO0FBQ0FHLHFCQUFhQyxPQUFiLENBQXFCSixXQUFyQjtBQUNBLGFBQUtLLFdBQUw7QUFDSCxLQUpEO0FBS0FQLHdCQUFvQmpCLFNBQXBCLENBQThCeUIsZUFBOUIsR0FBZ0QsVUFBVUgsWUFBVixFQUF3QjtBQUNwRSxhQUFLSSxHQUFMLENBQVMsS0FBS25CLFNBQUwsQ0FBZW9CLFFBQWYsQ0FBd0JWLG9CQUFvQkcsUUFBNUMsRUFBc0QsS0FBS1osS0FBM0QsRUFBa0UsSUFBSW9CLGdCQUFKLENBQXFCTixZQUFyQixFQUFtQyxLQUFLSCxXQUF4QyxDQUFsRSxDQUFUO0FBQ0gsS0FGRDtBQUdBRix3QkFBb0JqQixTQUFwQixDQUE4QjZCLEtBQTlCLEdBQXNDLFVBQVVDLEtBQVYsRUFBaUI7QUFDbkQsYUFBS0wsZUFBTCxDQUFxQnBCLGVBQWUwQixZQUFmLENBQTRCQyxVQUE1QixDQUF1Q0YsS0FBdkMsQ0FBckI7QUFDSCxLQUZEO0FBR0FiLHdCQUFvQmpCLFNBQXBCLENBQThCaUMsTUFBOUIsR0FBdUMsVUFBVUMsR0FBVixFQUFlO0FBQ2xELGFBQUtULGVBQUwsQ0FBcUJwQixlQUFlMEIsWUFBZixDQUE0QkksV0FBNUIsQ0FBd0NELEdBQXhDLENBQXJCO0FBQ0gsS0FGRDtBQUdBakIsd0JBQW9CakIsU0FBcEIsQ0FBOEJvQyxTQUE5QixHQUEwQyxZQUFZO0FBQ2xELGFBQUtYLGVBQUwsQ0FBcUJwQixlQUFlMEIsWUFBZixDQUE0Qk0sY0FBNUIsRUFBckI7QUFDSCxLQUZEO0FBR0EsV0FBT3BCLG1CQUFQO0FBQ0gsQ0ExQjBCLENBMEJ6QmQsYUFBYW1DLFVBMUJZLENBQTNCO0FBMkJBekIsUUFBUUksbUJBQVIsR0FBOEJBLG1CQUE5QjtBQUNBLElBQUlXLG1CQUFvQixZQUFZO0FBQ2hDLGFBQVNBLGdCQUFULENBQTBCTixZQUExQixFQUF3Q0gsV0FBeEMsRUFBcUQ7QUFDakQsYUFBS0csWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxhQUFLSCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNIO0FBQ0QsV0FBT1MsZ0JBQVA7QUFDSCxDQU51QixFQUF4QjtBQU9BZixRQUFRZSxnQkFBUixHQUEyQkEsZ0JBQTNCO0FBQ0EiLCJmaWxlIjoib2JzZXJ2ZU9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICpcbiAqIFJlLWVtaXRzIGFsbCBub3RpZmljYXRpb25zIGZyb20gc291cmNlIE9ic2VydmFibGUgd2l0aCBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbnN1cmUgYSBzcGVjaWZpYyBzY2hlZHVsZXIgaXMgdXNlZCwgZnJvbSBvdXRzaWRlIG9mIGFuIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIGBvYnNlcnZlT25gIGlzIGFuIG9wZXJhdG9yIHRoYXQgYWNjZXB0cyBhIHNjaGVkdWxlciBhcyBhIGZpcnN0IHBhcmFtZXRlciwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlc2NoZWR1bGVcbiAqIG5vdGlmaWNhdGlvbnMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIEl0IG1pZ2h0IGJlIHVzZWZ1bCwgaWYgeW91IGRvIG5vdCBoYXZlIGNvbnRyb2wgb3ZlclxuICogaW50ZXJuYWwgc2NoZWR1bGVyIG9mIGEgZ2l2ZW4gT2JzZXJ2YWJsZSwgYnV0IHdhbnQgdG8gY29udHJvbCB3aGVuIGl0cyB2YWx1ZXMgYXJlIGVtaXR0ZWQgbmV2ZXJ0aGVsZXNzLlxuICpcbiAqIFJldHVybmVkIE9ic2VydmFibGUgZW1pdHMgdGhlIHNhbWUgbm90aWZpY2F0aW9ucyAobmV4dGVkIHZhbHVlcywgY29tcGxldGUgYW5kIGVycm9yIGV2ZW50cykgYXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLFxuICogYnV0IHJlc2NoZWR1bGVkIHdpdGggcHJvdmlkZWQgc2NoZWR1bGVyLiBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IG1lYW4gdGhhdCBzb3VyY2UgT2JzZXJ2YWJsZXMgaW50ZXJuYWxcbiAqIHNjaGVkdWxlciB3aWxsIGJlIHJlcGxhY2VkIGluIGFueSB3YXkuIE9yaWdpbmFsIHNjaGVkdWxlciBzdGlsbCB3aWxsIGJlIHVzZWQsIGJ1dCB3aGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0c1xuICogbm90aWZpY2F0aW9uLCBpdCB3aWxsIGJlIGltbWVkaWF0ZWx5IHNjaGVkdWxlZCBhZ2FpbiAtIHRoaXMgdGltZSB3aXRoIHNjaGVkdWxlciBwYXNzZWQgdG8gYG9ic2VydmVPbmAuXG4gKiBBbiBhbnRpLXBhdHRlcm4gd291bGQgYmUgY2FsbGluZyBgb2JzZXJ2ZU9uYCBvbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbG90cyBvZiB2YWx1ZXMgc3luY2hyb25vdXNseSwgdG8gc3BsaXRcbiAqIHRoYXQgZW1pc3Npb25zIGludG8gYXN5bmNocm9ub3VzIGNodW5rcy4gRm9yIHRoaXMgdG8gaGFwcGVuLCBzY2hlZHVsZXIgd291bGQgaGF2ZSB0byBiZSBwYXNzZWQgaW50byB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGRpcmVjdGx5ICh1c3VhbGx5IGludG8gdGhlIG9wZXJhdG9yIHRoYXQgY3JlYXRlcyBpdCkuIGBvYnNlcnZlT25gIHNpbXBseSBkZWxheXMgbm90aWZpY2F0aW9ucyBhXG4gKiBsaXR0bGUgYml0IG1vcmUsIHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlIGVtaXR0ZWQgYXQgZXhwZWN0ZWQgbW9tZW50cy5cbiAqXG4gKiBBcyBhIG1hdHRlciBvZiBmYWN0LCBgb2JzZXJ2ZU9uYCBhY2NlcHRzIHNlY29uZCBwYXJhbWV0ZXIsIHdoaWNoIHNwZWNpZmllcyBpbiBtaWxsaXNlY29uZHMgd2l0aCB3aGF0IGRlbGF5IG5vdGlmaWNhdGlvbnNcbiAqIHdpbGwgYmUgZW1pdHRlZC4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBkZWxheX0gb3BlcmF0b3IgYW5kIGBvYnNlcnZlT25gIGlzIHRoYXQgYG9ic2VydmVPbmBcbiAqIHdpbGwgZGVsYXkgYWxsIG5vdGlmaWNhdGlvbnMgLSBpbmNsdWRpbmcgZXJyb3Igbm90aWZpY2F0aW9ucyAtIHdoaWxlIGBkZWxheWAgd2lsbCBwYXNzIHRocm91Z2ggZXJyb3JcbiAqIGZyb20gc291cmNlIE9ic2VydmFibGUgaW1tZWRpYXRlbHkgd2hlbiBpdCBpcyBlbWl0dGVkLiBJbiBnZW5lcmFsIGl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0byB1c2UgYGRlbGF5YCBvcGVyYXRvclxuICogZm9yIGFueSBraW5kIG9mIGRlbGF5aW5nIG9mIHZhbHVlcyBpbiB0aGUgc3RyZWFtLCB3aGlsZSB1c2luZyBgb2JzZXJ2ZU9uYCB0byBzcGVjaWZ5IHdoaWNoIHNjaGVkdWxlciBzaG91bGQgYmUgdXNlZFxuICogZm9yIG5vdGlmaWNhdGlvbiBlbWlzc2lvbnMgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbnN1cmUgdmFsdWVzIGluIHN1YnNjcmliZSBhcmUgY2FsbGVkIGp1c3QgYmVmb3JlIGJyb3dzZXIgcmVwYWludC48L2NhcHRpb24+XG4gKiBjb25zdCBpbnRlcnZhbHMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwKTsgLy8gSW50ZXJ2YWxzIGFyZSBzY2hlZHVsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGFzeW5jIHNjaGVkdWxlciBieSBkZWZhdWx0Li4uXG4gKlxuICogaW50ZXJ2YWxzXG4gKiAub2JzZXJ2ZU9uKFJ4LlNjaGVkdWxlci5hbmltYXRpb25GcmFtZSkgICAgICAgLy8gLi4uYnV0IHdlIHdpbGwgb2JzZXJ2ZSBvbiBhbmltYXRpb25GcmFtZVxuICogLnN1YnNjcmliZSh2YWwgPT4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjaGVkdWxlciB0byBlbnN1cmUgc21vb3RoIGFuaW1hdGlvbi5cbiAqICAgc29tZURpdi5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnO1xuICogfSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKlxuICogQHBhcmFtIHtJU2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlc2NoZWR1bGUgbm90aWZpY2F0aW9ucyBmcm9tIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IHN0YXRlcyB3aXRoIHdoYXQgZGVsYXkgZXZlcnkgbm90aWZpY2F0aW9uIHNob3VsZCBiZSByZXNjaGVkdWxlZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2FtZSBub3RpZmljYXRpb25zIGFzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSxcbiAqIGJ1dCB3aXRoIHByb3ZpZGVkIHNjaGVkdWxlci5cbiAqXG4gKiBAbWV0aG9kIG9ic2VydmVPblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZU9uKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gb2JzZXJ2ZU9uT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG4gICAgfTtcbn1cbmV4cG9ydHMub2JzZXJ2ZU9uID0gb2JzZXJ2ZU9uO1xudmFyIE9ic2VydmVPbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICBPYnNlcnZlT25PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zY2hlZHVsZXIsIHRoaXMuZGVsYXkpKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlT25PcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmVPbk9wZXJhdG9yID0gT2JzZXJ2ZU9uT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE9ic2VydmVPblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYnNlcnZlT25TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmVPblN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB9XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IGFyZy5ub3RpZmljYXRpb24sIGRlc3RpbmF0aW9uID0gYXJnLmRlc3RpbmF0aW9uO1xuICAgICAgICBub3RpZmljYXRpb24ub2JzZXJ2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTWVzc2FnZSA9IGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCwgdGhpcy5kZWxheSwgbmV3IE9ic2VydmVPbk1lc3NhZ2Uobm90aWZpY2F0aW9uLCB0aGlzLmRlc3RpbmF0aW9uKSkpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZU9uU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uU3Vic2NyaWJlciA9IE9ic2VydmVPblN1YnNjcmliZXI7XG52YXIgT2JzZXJ2ZU9uTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uTWVzc2FnZShub3RpZmljYXRpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlT25NZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uTWVzc2FnZSA9IE9ic2VydmVPbk1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlT24uanMubWFwIl19
},{"../Notification":3,"../Subscriber":9}],36:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (!_Symbol.iterator) {
            _Symbol.iterator = _Symbol('iterator polyfill');
        }
        return _Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhdG9yLmpzIl0sIm5hbWVzIjpbInJvb3RfMSIsInJlcXVpcmUiLCJzeW1ib2xJdGVyYXRvclBvbnlmaWxsIiwicm9vdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiU2V0XzEiLCJTZXQiLCJNYXBfMSIsIk1hcCIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvdG90eXBlIiwiaSIsImxlbmd0aCIsImtleSIsImV4cG9ydHMiLCIkJGl0ZXJhdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLGNBQVIsQ0FBYjtBQUNBLFNBQVNDLHNCQUFULENBQWdDQyxJQUFoQyxFQUFzQztBQUNsQyxRQUFJQyxVQUFTRCxLQUFLQyxNQUFsQjtBQUNBLFFBQUksT0FBT0EsT0FBUCxLQUFrQixVQUF0QixFQUFrQztBQUM5QixZQUFJLENBQUNBLFFBQU9DLFFBQVosRUFBc0I7QUFDbEJELG9CQUFPQyxRQUFQLEdBQWtCRCxRQUFPLG1CQUFQLENBQWxCO0FBQ0g7QUFDRCxlQUFPQSxRQUFPQyxRQUFkO0FBQ0gsS0FMRCxNQU1LO0FBQ0Q7QUFDQSxZQUFJQyxRQUFRSCxLQUFLSSxHQUFqQjtBQUNBLFlBQUlELFNBQVMsT0FBTyxJQUFJQSxLQUFKLEdBQVksWUFBWixDQUFQLEtBQXFDLFVBQWxELEVBQThEO0FBQzFELG1CQUFPLFlBQVA7QUFDSDtBQUNELFlBQUlFLFFBQVFMLEtBQUtNLEdBQWpCO0FBQ0E7QUFDQSxZQUFJRCxLQUFKLEVBQVc7QUFDUCxnQkFBSUUsT0FBT0MsT0FBT0MsbUJBQVAsQ0FBMkJKLE1BQU1LLFNBQWpDLENBQVg7QUFDQSxpQkFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlKLEtBQUtLLE1BQXpCLEVBQWlDLEVBQUVELENBQW5DLEVBQXNDO0FBQ2xDLG9CQUFJRSxNQUFNTixLQUFLSSxDQUFMLENBQVY7QUFDQTtBQUNBLG9CQUFJRSxRQUFRLFNBQVIsSUFBcUJBLFFBQVEsTUFBN0IsSUFBdUNSLE1BQU1LLFNBQU4sQ0FBZ0JHLEdBQWhCLE1BQXlCUixNQUFNSyxTQUFOLENBQWdCLFNBQWhCLENBQXBFLEVBQWdHO0FBQzVGLDJCQUFPRyxHQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxZQUFQO0FBQ0g7QUFDSjtBQUNEQyxRQUFRZixzQkFBUixHQUFpQ0Esc0JBQWpDO0FBQ0FlLFFBQVFaLFFBQVIsR0FBbUJILHVCQUF1QkYsT0FBT0csSUFBOUIsQ0FBbkI7QUFDQTs7O0FBR0FjLFFBQVFDLFVBQVIsR0FBcUJELFFBQVFaLFFBQTdCO0FBQ0EiLCJmaWxlIjoiaXRlcmF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdCkge1xuICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdpdGVyYXRvciBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgICAgICB2YXIgU2V0XzEgPSByb290LlNldDtcbiAgICAgICAgaWYgKFNldF8xICYmIHR5cGVvZiBuZXcgU2V0XzEoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNYXBfMSA9IHJvb3QuTWFwO1xuICAgICAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgICAgIGlmIChNYXBfMSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXBfMS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBNYXBfMS5wcm90b3R5cGVba2V5XSA9PT0gTWFwXzEucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG59XG5leHBvcnRzLnN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsO1xuZXhwb3J0cy5pdGVyYXRvciA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdF8xLnJvb3QpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgaXRlcmF0b3IgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkaXRlcmF0b3IgPSBleHBvcnRzLml0ZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwIl19
},{"../util/root":51}],37:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var _Symbol = context.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) {
            $$observable = _Symbol.observable;
        } else {
            $$observable = _Symbol('observable');
            _Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;
//# sourceMappingURL=observable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm9ic2VydmFibGUuanMiXSwibmFtZXMiOlsicm9vdF8xIiwicmVxdWlyZSIsImdldFN5bWJvbE9ic2VydmFibGUiLCJjb250ZXh0IiwiJCRvYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsImV4cG9ydHMiLCJyb290Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLGNBQVIsQ0FBYjtBQUNBLFNBQVNDLG1CQUFULENBQTZCQyxPQUE3QixFQUFzQztBQUNsQyxRQUFJQyxZQUFKO0FBQ0EsUUFBSUMsVUFBU0YsUUFBUUUsTUFBckI7QUFDQSxRQUFJLE9BQU9BLE9BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDOUIsWUFBSUEsUUFBT0MsVUFBWCxFQUF1QjtBQUNuQkYsMkJBQWVDLFFBQU9DLFVBQXRCO0FBQ0gsU0FGRCxNQUdLO0FBQ0RGLDJCQUFlQyxRQUFPLFlBQVAsQ0FBZjtBQUNBQSxvQkFBT0MsVUFBUCxHQUFvQkYsWUFBcEI7QUFDSDtBQUNKLEtBUkQsTUFTSztBQUNEQSx1QkFBZSxjQUFmO0FBQ0g7QUFDRCxXQUFPQSxZQUFQO0FBQ0g7QUFDREcsUUFBUUwsbUJBQVIsR0FBOEJBLG1CQUE5QjtBQUNBSyxRQUFRRCxVQUFSLEdBQXFCSixvQkFBb0JGLE9BQU9RLElBQTNCLENBQXJCO0FBQ0E7OztBQUdBRCxRQUFRSCxZQUFSLEdBQXVCRyxRQUFRRCxVQUEvQjtBQUNBIiwiZmlsZSI6Im9ic2VydmFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIGdldFN5bWJvbE9ic2VydmFibGUoY29udGV4dCkge1xuICAgIHZhciAkJG9ic2VydmFibGU7XG4gICAgdmFyIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sLm9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbiAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gJCRvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkJG9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuICQkb2JzZXJ2YWJsZTtcbn1cbmV4cG9ydHMuZ2V0U3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGU7XG5leHBvcnRzLm9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlKHJvb3RfMS5yb290KTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG9ic2VydmFibGUgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkb2JzZXJ2YWJsZSA9IGV4cG9ydHMub2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIl19
},{"../util/root":51}],38:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var _Symbol = root_1.root.Symbol;
exports.rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ4U3Vic2NyaWJlci5qcyJdLCJuYW1lcyI6WyJyb290XzEiLCJyZXF1aXJlIiwiU3ltYm9sIiwicm9vdCIsImV4cG9ydHMiLCJyeFN1YnNjcmliZXIiLCJmb3IiLCIkJHJ4U3Vic2NyaWJlciJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsU0FBU0MsUUFBUSxjQUFSLENBQWI7QUFDQSxJQUFJQyxVQUFTRixPQUFPRyxJQUFQLENBQVlELE1BQXpCO0FBQ0FFLFFBQVFDLFlBQVIsR0FBd0IsT0FBT0gsT0FBUCxLQUFrQixVQUFsQixJQUFnQyxPQUFPQSxRQUFPSSxHQUFkLEtBQXNCLFVBQXZELEdBQ25CSixRQUFPSSxHQUFQLENBQVcsY0FBWCxDQURtQixHQUNVLGdCQURqQztBQUVBOzs7QUFHQUYsUUFBUUcsY0FBUixHQUF5QkgsUUFBUUMsWUFBakM7QUFDQSIsImZpbGUiOiJyeFN1YnNjcmliZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBTeW1ib2wgPSByb290XzEucm9vdC5TeW1ib2w7XG5leHBvcnRzLnJ4U3Vic2NyaWJlciA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSA/XG4gICAgU3ltYm9sLmZvcigncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXInO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcnhTdWJzY3JpYmVyIGluc3RlYWRcbiAqL1xuZXhwb3J0cy4kJHJ4U3Vic2NyaWJlciA9IGV4cG9ydHMucnhTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnhTdWJzY3JpYmVyLmpzLm1hcCJdfQ==
},{"../util/root":51}],39:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImQiLCJiIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIk9iamVjdFVuc3Vic2NyaWJlZEVycm9yIiwiX3N1cGVyIiwiZXJyIiwiY2FsbCIsIm5hbWUiLCJzdGFjayIsIm1lc3NhZ2UiLCJFcnJvciIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFlBQWEsYUFBUSxVQUFLQSxTQUFkLElBQTRCLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUlDLENBQVQsSUFBY0QsQ0FBZDtBQUFpQixZQUFJQSxFQUFFRSxjQUFGLENBQWlCRCxDQUFqQixDQUFKLEVBQXlCRixFQUFFRSxDQUFGLElBQU9ELEVBQUVDLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVNFLEVBQVQsR0FBYztBQUFFLGFBQUtDLFdBQUwsR0FBbUJMLENBQW5CO0FBQXVCO0FBQ3ZDQSxNQUFFTSxTQUFGLEdBQWNMLE1BQU0sSUFBTixHQUFhTSxPQUFPQyxNQUFQLENBQWNQLENBQWQsQ0FBYixJQUFpQ0csR0FBR0UsU0FBSCxHQUFlTCxFQUFFSyxTQUFqQixFQUE0QixJQUFJRixFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0E7Ozs7Ozs7OztBQVNBLElBQUlLLDBCQUEyQixVQUFVQyxNQUFWLEVBQWtCO0FBQzdDWCxjQUFVVSx1QkFBVixFQUFtQ0MsTUFBbkM7QUFDQSxhQUFTRCx1QkFBVCxHQUFtQztBQUMvQixZQUFJRSxNQUFNRCxPQUFPRSxJQUFQLENBQVksSUFBWixFQUFrQixxQkFBbEIsQ0FBVjtBQUNBLGFBQUtDLElBQUwsR0FBWUYsSUFBSUUsSUFBSixHQUFXLHlCQUF2QjtBQUNBLGFBQUtDLEtBQUwsR0FBYUgsSUFBSUcsS0FBakI7QUFDQSxhQUFLQyxPQUFMLEdBQWVKLElBQUlJLE9BQW5CO0FBQ0g7QUFDRCxXQUFPTix1QkFBUDtBQUNILENBVDhCLENBUzdCTyxLQVQ2QixDQUEvQjtBQVVBQyxRQUFRUix1QkFBUixHQUFrQ0EsdUJBQWxDO0FBQ0EiLCJmaWxlIjoiT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgaW52YWxpZCBiZWNhdXNlIHRoZSBvYmplY3QgaGFzIGJlZW5cbiAqIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBTdWJqZWN0fVxuICogQHNlZSB7QGxpbmsgQmVoYXZpb3JTdWJqZWN0fVxuICpcbiAqIEBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvclxuICovXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RVbnN1YnNjcmliZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdvYmplY3QgdW5zdWJzY3JpYmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzLm1hcCJdfQ==
},{}],40:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function get() {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }();
}
exports.minimalSetImpl = minimalSetImpl;
exports.Set = root_1.root.Set || minimalSetImpl();
//# sourceMappingURL=Set.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNldC5qcyJdLCJuYW1lcyI6WyJyb290XzEiLCJyZXF1aXJlIiwibWluaW1hbFNldEltcGwiLCJNaW5pbWFsU2V0IiwiX3ZhbHVlcyIsInByb3RvdHlwZSIsImFkZCIsInZhbHVlIiwiaGFzIiwicHVzaCIsImluZGV4T2YiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImxlbmd0aCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJjbGVhciIsImV4cG9ydHMiLCJTZXQiLCJyb290Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTQyxRQUFRLFFBQVIsQ0FBYjtBQUNBLFNBQVNDLGNBQVQsR0FBMEI7QUFDdEI7QUFDQTtBQUNBLFdBQVEsWUFBWTtBQUNoQixpQkFBU0MsVUFBVCxHQUFzQjtBQUNsQixpQkFBS0MsT0FBTCxHQUFlLEVBQWY7QUFDSDtBQUNERCxtQkFBV0UsU0FBWCxDQUFxQkMsR0FBckIsR0FBMkIsVUFBVUMsS0FBVixFQUFpQjtBQUN4QyxnQkFBSSxDQUFDLEtBQUtDLEdBQUwsQ0FBU0QsS0FBVCxDQUFMLEVBQXNCO0FBQ2xCLHFCQUFLSCxPQUFMLENBQWFLLElBQWIsQ0FBa0JGLEtBQWxCO0FBQ0g7QUFDSixTQUpEO0FBS0FKLG1CQUFXRSxTQUFYLENBQXFCRyxHQUFyQixHQUEyQixVQUFVRCxLQUFWLEVBQWlCO0FBQ3hDLG1CQUFPLEtBQUtILE9BQUwsQ0FBYU0sT0FBYixDQUFxQkgsS0FBckIsTUFBZ0MsQ0FBQyxDQUF4QztBQUNILFNBRkQ7QUFHQUksZUFBT0MsY0FBUCxDQUFzQlQsV0FBV0UsU0FBakMsRUFBNEMsTUFBNUMsRUFBb0Q7QUFDaERRLGlCQUFLLGVBQVk7QUFDYix1QkFBTyxLQUFLVCxPQUFMLENBQWFVLE1BQXBCO0FBQ0gsYUFIK0M7QUFJaERDLHdCQUFZLElBSm9DO0FBS2hEQywwQkFBYztBQUxrQyxTQUFwRDtBQU9BYixtQkFBV0UsU0FBWCxDQUFxQlksS0FBckIsR0FBNkIsWUFBWTtBQUNyQyxpQkFBS2IsT0FBTCxDQUFhVSxNQUFiLEdBQXNCLENBQXRCO0FBQ0gsU0FGRDtBQUdBLGVBQU9YLFVBQVA7QUFDSCxLQXZCTyxFQUFSO0FBd0JIO0FBQ0RlLFFBQVFoQixjQUFSLEdBQXlCQSxjQUF6QjtBQUNBZ0IsUUFBUUMsR0FBUixHQUFjbkIsT0FBT29CLElBQVAsQ0FBWUQsR0FBWixJQUFtQmpCLGdCQUFqQztBQUNBIiwiZmlsZSI6IlNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuZnVuY3Rpb24gbWluaW1hbFNldEltcGwoKSB7XG4gICAgLy8gVEhJUyBJUyBOT1QgYSBmdWxsIGltcGwgb2YgU2V0LCB0aGlzIGlzIGp1c3QgdGhlIG1pbmltdW1cbiAgICAvLyBiaXRzIG9mIGZ1bmN0aW9uYWxpdHkgd2UgbmVlZCBmb3IgdGhpcyBsaWJyYXJ5LlxuICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5pbWFsU2V0KCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pbmltYWxTZXQucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbmltYWxTZXQ7XG4gICAgfSgpKTtcbn1cbmV4cG9ydHMubWluaW1hbFNldEltcGwgPSBtaW5pbWFsU2V0SW1wbDtcbmV4cG9ydHMuU2V0ID0gcm9vdF8xLnJvb3QuU2V0IHx8IG1pbmltYWxTZXRJbXBsKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXQuanMubWFwIl19
},{"./root":51}],41:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlVuc3Vic2NyaXB0aW9uRXJyb3IuanMiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZCIsImIiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiVW5zdWJzY3JpcHRpb25FcnJvciIsIl9zdXBlciIsImVycm9ycyIsImNhbGwiLCJlcnIiLCJFcnJvciIsImxlbmd0aCIsIm1hcCIsImkiLCJ0b1N0cmluZyIsImpvaW4iLCJuYW1lIiwic3RhY2siLCJtZXNzYWdlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsWUFBYSxhQUFRLFVBQUtBLFNBQWQsSUFBNEIsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSUMsQ0FBVCxJQUFjRCxDQUFkO0FBQWlCLFlBQUlBLEVBQUVFLGNBQUYsQ0FBaUJELENBQWpCLENBQUosRUFBeUJGLEVBQUVFLENBQUYsSUFBT0QsRUFBRUMsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBU0UsRUFBVCxHQUFjO0FBQUUsYUFBS0MsV0FBTCxHQUFtQkwsQ0FBbkI7QUFBdUI7QUFDdkNBLE1BQUVNLFNBQUYsR0FBY0wsTUFBTSxJQUFOLEdBQWFNLE9BQU9DLE1BQVAsQ0FBY1AsQ0FBZCxDQUFiLElBQWlDRyxHQUFHRSxTQUFILEdBQWVMLEVBQUVLLFNBQWpCLEVBQTRCLElBQUlGLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQTs7OztBQUlBLElBQUlLLHNCQUF1QixVQUFVQyxNQUFWLEVBQWtCO0FBQ3pDWCxjQUFVVSxtQkFBVixFQUErQkMsTUFBL0I7QUFDQSxhQUFTRCxtQkFBVCxDQUE2QkUsTUFBN0IsRUFBcUM7QUFDakNELGVBQU9FLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBS0QsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsWUFBSUUsTUFBTUMsTUFBTUYsSUFBTixDQUFXLElBQVgsRUFBaUJELFNBQ3ZCQSxPQUFPSSxNQUFQLEdBQWdCLDZDQUFoQixHQUFnRUosT0FBT0ssR0FBUCxDQUFXLFVBQVVILEdBQVYsRUFBZUksQ0FBZixFQUFrQjtBQUFFLG1CQUFTQSxJQUFJLENBQUwsR0FBVSxJQUFWLEdBQWlCSixJQUFJSyxRQUFKLEVBQXpCO0FBQTJDLFNBQTFFLEVBQTRFQyxJQUE1RSxDQUFpRixNQUFqRixDQUR6QyxHQUNvSSxFQURySixDQUFWO0FBRUEsYUFBS0MsSUFBTCxHQUFZUCxJQUFJTyxJQUFKLEdBQVcscUJBQXZCO0FBQ0EsYUFBS0MsS0FBTCxHQUFhUixJQUFJUSxLQUFqQjtBQUNBLGFBQUtDLE9BQUwsR0FBZVQsSUFBSVMsT0FBbkI7QUFDSDtBQUNELFdBQU9iLG1CQUFQO0FBQ0gsQ0FaMEIsQ0FZekJLLEtBWnlCLENBQTNCO0FBYUFTLFFBQVFkLG1CQUFSLEdBQThCQSxtQkFBOUI7QUFDQSIsImZpbGUiOiJVbnN1YnNjcmlwdGlvbkVycm9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiXX0=
},{}],42:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object

exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVycm9yT2JqZWN0LmpzIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJlcnJvck9iamVjdCIsImUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBQ0FBLFFBQVFDLFdBQVIsR0FBc0IsRUFBRUMsR0FBRyxFQUFMLEVBQXRCO0FBQ0EiLCJmaWxlIjoiZXJyb3JPYmplY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcCJdfQ==
},{}],43:[function(require,module,exports){
"use strict";

exports.isArray = Array.isArray || function (x) {
  return x && typeof x.length === 'number';
};
//# sourceMappingURL=isArray.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlzQXJyYXkuanMiXSwibmFtZXMiOlsiZXhwb3J0cyIsImlzQXJyYXkiLCJBcnJheSIsIngiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBQSxRQUFRQyxPQUFSLEdBQWtCQyxNQUFNRCxPQUFOLElBQWtCLFVBQVVFLENBQVYsRUFBYTtBQUFFLFNBQU9BLEtBQUssT0FBT0EsRUFBRUMsTUFBVCxLQUFvQixRQUFoQztBQUEyQyxDQUE5RjtBQUNBIiwiZmlsZSI6ImlzQXJyYXkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheS5qcy5tYXAiXX0=
},{}],44:[function(require,module,exports){
"use strict";

exports.isArrayLike = function (x) {
  return x && typeof x.length === 'number';
};
//# sourceMappingURL=isArrayLike.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlzQXJyYXlMaWtlLmpzIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJpc0FycmF5TGlrZSIsIngiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBQSxRQUFRQyxXQUFSLEdBQXVCLFVBQVVDLENBQVYsRUFBYTtBQUFFLFNBQU9BLEtBQUssT0FBT0EsRUFBRUMsTUFBVCxLQUFvQixRQUFoQztBQUEyQyxDQUFqRjtBQUNBIiwiZmlsZSI6ImlzQXJyYXlMaWtlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwIl19
},{}],45:[function(require,module,exports){
"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlzRnVuY3Rpb24uanMiXSwibmFtZXMiOlsiaXNGdW5jdGlvbiIsIngiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxTQUFTQSxVQUFULENBQW9CQyxDQUFwQixFQUF1QjtBQUNuQixXQUFPLE9BQU9BLENBQVAsS0FBYSxVQUFwQjtBQUNIO0FBQ0RDLFFBQVFGLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0EiLCJmaWxlIjoiaXNGdW5jdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIl19
},{}],46:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(x) {
    return x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlzT2JqZWN0LmpzIl0sIm5hbWVzIjpbImlzT2JqZWN0IiwieCIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBQ0EsU0FBU0EsUUFBVCxDQUFrQkMsQ0FBbEIsRUFBcUI7QUFDakIsV0FBT0EsS0FBSyxJQUFMLElBQWEsUUFBT0EsQ0FBUCx5Q0FBT0EsQ0FBUCxPQUFhLFFBQWpDO0FBQ0g7QUFDREMsUUFBUUYsUUFBUixHQUFtQkEsUUFBbkI7QUFDQSIsImZpbGUiOiJpc09iamVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwIl19
},{}],47:[function(require,module,exports){
"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlzUHJvbWlzZS5qcyJdLCJuYW1lcyI6WyJpc1Byb21pc2UiLCJ2YWx1ZSIsInN1YnNjcmliZSIsInRoZW4iLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxTQUFTQSxTQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUN0QixXQUFPQSxTQUFTLE9BQU9BLE1BQU1DLFNBQWIsS0FBMkIsVUFBcEMsSUFBa0QsT0FBT0QsTUFBTUUsSUFBYixLQUFzQixVQUEvRTtBQUNIO0FBQ0RDLFFBQVFKLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0EiLCJmaWxlIjoiaXNQcm9taXNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNQcm9taXNlLmpzLm1hcCJdfQ==
},{}],48:[function(require,module,exports){
"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlzU2NoZWR1bGVyLmpzIl0sIm5hbWVzIjpbImlzU2NoZWR1bGVyIiwidmFsdWUiLCJzY2hlZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLFNBQVNBLFdBQVQsQ0FBcUJDLEtBQXJCLEVBQTRCO0FBQ3hCLFdBQU9BLFNBQVMsT0FBT0EsTUFBTUMsUUFBYixLQUEwQixVQUExQztBQUNIO0FBQ0RDLFFBQVFILFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0EiLCJmaWxlIjoiaXNTY2hlZHVsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNTY2hlZHVsZXIgPSBpc1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcCJdfQ==
},{}],49:[function(require,module,exports){
"use strict";
/* tslint:disable:no-empty */

function noop() {}
exports.noop = noop;
//# sourceMappingURL=noop.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vb3AuanMiXSwibmFtZXMiOlsibm9vcCIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBQ0EsU0FBU0EsSUFBVCxHQUFnQixDQUFHO0FBQ25CQyxRQUFRRCxJQUFSLEdBQWVBLElBQWY7QUFDQSIsImZpbGUiOiJub29wLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1lbXB0eSAqL1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZXhwb3J0cy5ub29wID0gbm9vcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vb3AuanMubWFwIl19
},{}],50:[function(require,module,exports){
"use strict";

var noop_1 = require('./noop');
/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) {
            return fn(prev);
        }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBpcGUuanMiXSwibmFtZXMiOlsibm9vcF8xIiwicmVxdWlyZSIsInBpcGUiLCJmbnMiLCJfaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInBpcGVGcm9tQXJyYXkiLCJleHBvcnRzIiwibm9vcCIsInBpcGVkIiwiaW5wdXQiLCJyZWR1Y2UiLCJwcmV2IiwiZm4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFNBQVNDLFFBQVEsUUFBUixDQUFiO0FBQ0E7QUFDQSxTQUFTQyxJQUFULEdBQWdCO0FBQ1osUUFBSUMsTUFBTSxFQUFWO0FBQ0EsU0FBSyxJQUFJQyxLQUFLLENBQWQsRUFBaUJBLEtBQUtDLFVBQVVDLE1BQWhDLEVBQXdDRixJQUF4QyxFQUE4QztBQUMxQ0QsWUFBSUMsS0FBSyxDQUFULElBQWNDLFVBQVVELEVBQVYsQ0FBZDtBQUNIO0FBQ0QsV0FBT0csY0FBY0osR0FBZCxDQUFQO0FBQ0g7QUFDREssUUFBUU4sSUFBUixHQUFlQSxJQUFmO0FBQ0E7QUFDQSxTQUFTSyxhQUFULENBQXVCSixHQUF2QixFQUE0QjtBQUN4QixRQUFJLENBQUNBLEdBQUwsRUFBVTtBQUNOLGVBQU9ILE9BQU9TLElBQWQ7QUFDSDtBQUNELFFBQUlOLElBQUlHLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNsQixlQUFPSCxJQUFJLENBQUosQ0FBUDtBQUNIO0FBQ0QsV0FBTyxTQUFTTyxLQUFULENBQWVDLEtBQWYsRUFBc0I7QUFDekIsZUFBT1IsSUFBSVMsTUFBSixDQUFXLFVBQVVDLElBQVYsRUFBZ0JDLEVBQWhCLEVBQW9CO0FBQUUsbUJBQU9BLEdBQUdELElBQUgsQ0FBUDtBQUFrQixTQUFuRCxFQUFxREYsS0FBckQsQ0FBUDtBQUNILEtBRkQ7QUFHSDtBQUNESCxRQUFRRCxhQUFSLEdBQXdCQSxhQUF4QjtBQUNBIiwiZmlsZSI6InBpcGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBub29wXzEgPSByZXF1aXJlKCcuL25vb3AnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5mdW5jdGlvbiBwaXBlKCkge1xuICAgIHZhciBmbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmbnNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBwaXBlRnJvbUFycmF5KGZucyk7XG59XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBwaXBlRnJvbUFycmF5KGZucykge1xuICAgIGlmICghZm5zKSB7XG4gICAgICAgIHJldHVybiBub29wXzEubm9vcDtcbiAgICB9XG4gICAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZuc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBmbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBmbikgeyByZXR1cm4gZm4ocHJldik7IH0sIGlucHV0KTtcbiAgICB9O1xufVxuZXhwb3J0cy5waXBlRnJvbUFycmF5ID0gcGlwZUZyb21BcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGUuanMubWFwIl19
},{"./noop":49}],51:[function(require,module,exports){
(function (global){
"use strict";
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.

var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();
//# sourceMappingURL=root.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJvb3QuanMiXSwibmFtZXMiOlsiX193aW5kb3ciLCJ3aW5kb3ciLCJfX3NlbGYiLCJzZWxmIiwiV29ya2VyR2xvYmFsU2NvcGUiLCJfX2dsb2JhbCIsImdsb2JhbCIsIl9yb290IiwiZXhwb3J0cyIsInJvb3QiLCJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsV0FBVyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFoRDtBQUNBLElBQUlDLFNBQVMsT0FBT0MsSUFBUCxLQUFnQixXQUFoQixJQUErQixPQUFPQyxpQkFBUCxLQUE2QixXQUE1RCxJQUNURCxnQkFBZ0JDLGlCQURQLElBQzRCRCxJQUR6QztBQUVBLElBQUlFLFdBQVcsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBaEQ7QUFDQSxJQUFJQyxRQUFRUCxZQUFZSyxRQUFaLElBQXdCSCxNQUFwQztBQUNBTSxRQUFRQyxJQUFSLEdBQWVGLEtBQWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7QUFDVCxRQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNSLGNBQU0sSUFBSUcsS0FBSixDQUFVLCtEQUFWLENBQU47QUFDSDtBQUNKLENBSkQ7QUFLQSIsImZpbGUiOiJyb290LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb21tb25KUyAvIE5vZGUgaGF2ZSBnbG9iYWwgY29udGV4dCBleHBvc2VkIGFzIFwiZ2xvYmFsXCIgdmFyaWFibGUuXG4vLyBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgdGhlIHdob2xlIG5vZGUuZC50cyB0aGlzIHRoaXMgY29tcGlsYXRpb24gdW5pdCBzbyB3ZSdsbCBqdXN0IGZha2Vcbi8vIHRoZSBnbG9iYWwgXCJnbG9iYWxcIiB2YXIgZm9yIG5vdy5cbnZhciBfX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbnZhciBfX3NlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJiBzZWxmO1xudmFyIF9fZ2xvYmFsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsO1xudmFyIF9yb290ID0gX193aW5kb3cgfHwgX19nbG9iYWwgfHwgX19zZWxmO1xuZXhwb3J0cy5yb290ID0gX3Jvb3Q7XG4vLyBXb3JrYXJvdW5kIENsb3N1cmUgQ29tcGlsZXIgcmVzdHJpY3Rpb246IFRoZSBib2R5IG9mIGEgZ29vZy5tb2R1bGUgY2Fubm90IHVzZSB0aHJvdy5cbi8vIFRoaXMgaXMgbmVlZGVkIHdoZW4gdXNlZCB3aXRoIGFuZ3VsYXIvdHNpY2tsZSB3aGljaCBpbnNlcnRzIGEgZ29vZy5tb2R1bGUgc3RhdGVtZW50LlxuLy8gV3JhcCBpbiBJSUZFXG4oZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG4gICAgfVxufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb3QuanMubWFwIl19
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],52:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN1YnNjcmliZVRvUmVzdWx0LmpzIl0sIm5hbWVzIjpbInJvb3RfMSIsInJlcXVpcmUiLCJpc0FycmF5TGlrZV8xIiwiaXNQcm9taXNlXzEiLCJpc09iamVjdF8xIiwiT2JzZXJ2YWJsZV8xIiwiaXRlcmF0b3JfMSIsIklubmVyU3Vic2NyaWJlcl8xIiwib2JzZXJ2YWJsZV8xIiwic3Vic2NyaWJlVG9SZXN1bHQiLCJvdXRlclN1YnNjcmliZXIiLCJyZXN1bHQiLCJvdXRlclZhbHVlIiwib3V0ZXJJbmRleCIsImRlc3RpbmF0aW9uIiwiSW5uZXJTdWJzY3JpYmVyIiwiY2xvc2VkIiwiT2JzZXJ2YWJsZSIsIl9pc1NjYWxhciIsIm5leHQiLCJ2YWx1ZSIsImNvbXBsZXRlIiwic3luY0Vycm9yVGhyb3dhYmxlIiwic3Vic2NyaWJlIiwiaXNBcnJheUxpa2UiLCJpIiwibGVuIiwibGVuZ3RoIiwiaXNQcm9taXNlIiwidGhlbiIsImVyciIsImVycm9yIiwicm9vdCIsInNldFRpbWVvdXQiLCJpdGVyYXRvciIsIml0ZW0iLCJkb25lIiwib2JzZXJ2YWJsZSIsIm9icyIsIlR5cGVFcnJvciIsImlzT2JqZWN0IiwibXNnIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsU0FBU0MsUUFBUSxRQUFSLENBQWI7QUFDQSxJQUFJQyxnQkFBZ0JELFFBQVEsZUFBUixDQUFwQjtBQUNBLElBQUlFLGNBQWNGLFFBQVEsYUFBUixDQUFsQjtBQUNBLElBQUlHLGFBQWFILFFBQVEsWUFBUixDQUFqQjtBQUNBLElBQUlJLGVBQWVKLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUlLLGFBQWFMLFFBQVEsb0JBQVIsQ0FBakI7QUFDQSxJQUFJTSxvQkFBb0JOLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJTyxlQUFlUCxRQUFRLHNCQUFSLENBQW5CO0FBQ0EsU0FBU1EsaUJBQVQsQ0FBMkJDLGVBQTNCLEVBQTRDQyxNQUE1QyxFQUFvREMsVUFBcEQsRUFBZ0VD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b0QsTUFBTUEsTUFBTixHQUFlLEdBQS9FO0FBQ0EsWUFBSThCLE1BQU8sa0JBQWtCckIsS0FBbEIsR0FBMEIsK0JBQTNCLEdBQ0osOERBRE47QUFFQU4sb0JBQVlpQixLQUFaLENBQWtCLElBQUlRLFNBQUosQ0FBY0UsR0FBZCxDQUFsQjtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7QUFDREMsUUFBUWpDLGlCQUFSLEdBQTRCQSxpQkFBNUI7QUFDQSIsImZpbGUiOiJzdWJzY3JpYmVUb1Jlc3VsdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIGlzQXJyYXlMaWtlXzEgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG52YXIgaXNQcm9taXNlXzEgPSByZXF1aXJlKCcuL2lzUHJvbWlzZScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbnZhciBJbm5lclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL0lubmVyU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG5mdW5jdGlvbiBzdWJzY3JpYmVUb1Jlc3VsdChvdXRlclN1YnNjcmliZXIsIHJlc3VsdCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IG5ldyBJbm5lclN1YnNjcmliZXJfMS5Jbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KTtcbiAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuICYmICFkZXN0aW5hdGlvbi5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpOyB9KVxuICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXzEuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHJlc3VsdFtpdGVyYXRvcl8xLml0ZXJhdG9yXSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgb2JzID0gcmVzdWx0W29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSgpO1xuICAgICAgICBpZiAodHlwZW9mIG9icy5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIG9iamVjdCBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IFN5bWJvbC5vYnNlcnZhYmxlJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUobmV3IElubmVyU3Vic2NyaWJlcl8xLklubmVyU3Vic2NyaWJlcihvdXRlclN1YnNjcmliZXIsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXNPYmplY3RfMS5pc09iamVjdChyZXN1bHQpID8gJ2FuIGludmFsaWQgb2JqZWN0JyA6IFwiJ1wiICsgcmVzdWx0ICsgXCInXCI7XG4gICAgICAgIHZhciBtc2cgPSAoXCJZb3UgcHJvdmlkZWQgXCIgKyB2YWx1ZSArIFwiIHdoZXJlIGEgc3RyZWFtIHdhcyBleHBlY3RlZC5cIilcbiAgICAgICAgICAgICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IobXNnKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5zdWJzY3JpYmVUb1Jlc3VsdCA9IHN1YnNjcmliZVRvUmVzdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlVG9SZXN1bHQuanMubWFwIl19
},{"../InnerSubscriber":2,"../Observable":4,"../symbol/iterator":36,"../symbol/observable":37,"./isArrayLike":44,"./isObject":46,"./isPromise":47,"./root":51}],53:[function(require,module,exports){
"use strict";

var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRvU3Vic2NyaWJlci5qcyJdLCJuYW1lcyI6WyJTdWJzY3JpYmVyXzEiLCJyZXF1aXJlIiwicnhTdWJzY3JpYmVyXzEiLCJPYnNlcnZlcl8xIiwidG9TdWJzY3JpYmVyIiwibmV4dE9yT2JzZXJ2ZXIiLCJlcnJvciIsImNvbXBsZXRlIiwiU3Vic2NyaWJlciIsInJ4U3Vic2NyaWJlciIsImVtcHR5IiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsZUFBZUMsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSUMsaUJBQWlCRCxRQUFRLHdCQUFSLENBQXJCO0FBQ0EsSUFBSUUsYUFBYUYsUUFBUSxhQUFSLENBQWpCO0FBQ0EsU0FBU0csWUFBVCxDQUFzQkMsY0FBdEIsRUFBc0NDLEtBQXRDLEVBQTZDQyxRQUE3QyxFQUF1RDtBQUNuRCxRQUFJRixjQUFKLEVBQW9CO0FBQ2hCLFlBQUlBLDBCQUEwQkwsYUFBYVEsVUFBM0MsRUFBdUQ7QUFDbkQsbUJBQU9ILGNBQVA7QUFDSDtBQUNELFlBQUlBLGVBQWVILGVBQWVPLFlBQTlCLENBQUosRUFBaUQ7QUFDN0MsbUJBQU9KLGVBQWVILGVBQWVPLFlBQTlCLEdBQVA7QUFDSDtBQUNKO0FBQ0QsUUFBSSxDQUFDSixjQUFELElBQW1CLENBQUNDLEtBQXBCLElBQTZCLENBQUNDLFFBQWxDLEVBQTRDO0FBQ3hDLGVBQU8sSUFBSVAsYUFBYVEsVUFBakIsQ0FBNEJMLFdBQVdPLEtBQXZDLENBQVA7QUFDSDtBQUNELFdBQU8sSUFBSVYsYUFBYVEsVUFBakIsQ0FBNEJILGNBQTVCLEVBQTRDQyxLQUE1QyxFQUFtREMsUUFBbkQsQ0FBUDtBQUNIO0FBQ0RJLFFBQVFQLFlBQVIsR0FBdUJBLFlBQXZCO0FBQ0EiLCJmaWxlIjoidG9TdWJzY3JpYmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZlcicpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihPYnNlcnZlcl8xLmVtcHR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCJdfQ==
},{"../Observer":5,"../Subscriber":9,"../symbol/rxSubscriber":38}],54:[function(require,module,exports){
"use strict";

var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRyeUNhdGNoLmpzIl0sIm5hbWVzIjpbImVycm9yT2JqZWN0XzEiLCJyZXF1aXJlIiwidHJ5Q2F0Y2hUYXJnZXQiLCJ0cnlDYXRjaGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJlIiwiZXJyb3JPYmplY3QiLCJ0cnlDYXRjaCIsImZuIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsSUFBSUEsZ0JBQWdCQyxRQUFRLGVBQVIsQ0FBcEI7QUFDQSxJQUFJQyxjQUFKO0FBQ0EsU0FBU0MsVUFBVCxHQUFzQjtBQUNsQixRQUFJO0FBQ0EsZUFBT0QsZUFBZUUsS0FBZixDQUFxQixJQUFyQixFQUEyQkMsU0FBM0IsQ0FBUDtBQUNILEtBRkQsQ0FHQSxPQUFPQyxDQUFQLEVBQVU7QUFDTk4sc0JBQWNPLFdBQWQsQ0FBMEJELENBQTFCLEdBQThCQSxDQUE5QjtBQUNBLGVBQU9OLGNBQWNPLFdBQXJCO0FBQ0g7QUFDSjtBQUNELFNBQVNDLFFBQVQsQ0FBa0JDLEVBQWxCLEVBQXNCO0FBQ2xCUCxxQkFBaUJPLEVBQWpCO0FBQ0EsV0FBT04sVUFBUDtBQUNIO0FBQ0RPLFFBQVFGLFFBQVIsR0FBbUJBLFFBQW5CO0FBQ0E7QUFDQSIsImZpbGUiOiJ0cnlDYXRjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL2Vycm9yT2JqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnlDYXRjaC5qcy5tYXAiXX0=
},{"./errorObject":42}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Observable = require('rxjs/Observable');

var _AjaxObservable = require('rxjs/observable/dom/AjaxObservable');

require('rxjs/add/operator/map');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/mergeMap');

require('rxjs/add/operator/distinct');

require('rxjs/add/observable/from');

require('rxjs/add/observable/fromPromise');

var _dexie = require('dexie');

var _dexie2 = _interopRequireDefault(_dexie);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Common database helper functions.
 */
var DBHelper = function () {
    function DBHelper() {
        _classCallCheck(this, DBHelper);
    }

    _createClass(DBHelper, null, [{
        key: 'createIndexedDB',


        /**
         * Returns indexedDB managed by Dexie
         * @param name
         * @static
         * @return {Dexie}
         */
        value: function createIndexedDB(name) {
            return new _dexie2.default(name);
        }

        /**
         * Creates indexedDB table
         * @param {Dexie} DB Database
         * @param {Object} stores Stores and object
         * @static
         * @return {Dexie.Version<Number>} database
         */

    }, {
        key: 'createIndexedStores',
        value: function createIndexedStores(DB, stores) {

            return DB.version(DBHelper.DATABASE_VERSION).stores(stores);
        }

        /**
         * Deletes an indexed database
         * @param {Dexie} DB
         * @static
         * @return {Promise<void>}
         */

    }, {
        key: 'deleteIndexedDB',
        value: function deleteIndexedDB(DB) {
            return DB.delete();
        }

        /**
         * Executes indexedDB settings and if set, Dexie.on watcher
         * @param {Dexie} DB
         * @static
         * @return {Promise<Dexie>}
         */

    }, {
        key: 'initIndexedDB',
        value: function initIndexedDB(DB) {
            return DB.open();
        }

        /**
         * Registers listener for an indexedDB event
         * @param {Dexie} DB
         * @param {String} type
         * @param {Function} fn
         * @static
         * @return {void}
         */

    }, {
        key: 'addIDBEventListener',
        value: function addIDBEventListener(DB, type, fn) {
            DB.on(type, fn);
        }

        /**
         * Executes function if indexedDB is not empty
         * @param {Dexie} DB
         * @static
         * @param {String} storeName
         */

    }, {
        key: 'ifIndexedDBEmpty',
        value: function ifIndexedDBEmpty(DB, storeName) {
            return new Promise(function (resolve, reject) {
                DBHelper.addIDBEventListener(DB, 'ready', function () {
                    return DB[storeName].count(function (count) {
                        if (count === 0) {
                            return resolve();
                        } else {
                            return reject('DB not empty');
                        }
                    });
                });
            });
        }

        /**
         * Executes an callback when having access to indexed table records
         * @param {Dexie} DB
         * @param {Function} callback
         * @static
         * @return {Dexie.Promise}
         */

    }, {
        key: 'indexedTableOpen',
        value: function indexedTableOpen(DB, callback) {
            return DB.transaction('rw', DBHelper.DATABASE_NAME, function () {
                return callback();
            });
        }

        /**
         * Fetch all restaurants.
         * @static
         * @return {Observable}
         */

    }, {
        key: 'fetchRestaurants',
        value: function fetchRestaurants() {
            return _AjaxObservable.AjaxObservable.create.getJSON(DBHelper.API_URL).mergeMap(function (x) {
                return _Observable.Observable.from(x);
            });
        }

        /**
         *
         * @param {Dexie} DB
         * @param {Array} query arguments for indexedDB query id/
         * @return {Promise<any>}
         */

    }, {
        key: 'entryExists',
        value: function entryExists(DB, query) {
            return new Promise(function (resolve, reject) {
                DB.transaction('rw', DBHelper.DATABASE_NAME, function () {
                    var _DB$DBHelper$DATABASE;

                    (_DB$DBHelper$DATABASE = DB[DBHelper.DATABASE_NAME]).get.apply(_DB$DBHelper$DATABASE, _toConsumableArray(query)).then(function (result) {
                        return resolve(result);
                    }).catch(function (err) {
                        reject(err);
                    });
                });
            });
        }

        /**
         * Checks if API have changed
         * @return {Promise<void>}
         */

    }, {
        key: 'needsUpdate',
        value: function needsUpdate() {
            return new Promise(function (resolve, reject) {
                var http = new XMLHttpRequest();
                http.open('HEAD', url);
                http.onreadystatechange = function () {
                    if (this.readyState === this.DONE) {
                        this.status !== 304 && this.status !== 404 && resolve();
                    } else {
                        reject();
                    }
                };
                http.send();
            });
        }

        /**
         * Fetch a restaurant by its ID.
         * @param {Number} id
         * @param {Function} callback
         * @static
         * @return {Subscription}
         */

    }, {
        key: 'fetchRestaurantById',
        value: function fetchRestaurantById(id, callback) {
            return _AjaxObservable.AjaxObservable.create.getJSON('' + DBHelper.API_URL + id).subscribe(function (restaurants) {
                callback(null, restaurants);
            }, function (error) {
                callback('Got error ' + error + ' fetching restaurant ID: {' + id + '} from remote', null);
            });
        }

        /**
         * Fetch restaurants by a cuisine type with proper error handling.
         * @param {Observable} restaurants$
         * @param {String} cuisine
         * @param {Function} callback
         * @static
         * @return {Subscription}
         */

    }, {
        key: 'fetchRestaurantByCuisine',
        value: function fetchRestaurantByCuisine(restaurants$, cuisine, callback) {
            return restaurants$.filter(function (r) {
                return r.cuisine_type === cuisine;
            }).subscribe(function (c) {
                return callback(null, c);
            }, function (error) {
                return callback(error, null);
            });
        }

        /**
         * Fetch restaurants by a neighborhood with proper error handling.
         * @param {Observable} restaurants$
         * @param {String} neighborhood
         * @param {Function} callback
         * @static
         * @return {Subscription}
         */

    }, {
        key: 'fetchRestaurantByNeighborhood',
        value: function fetchRestaurantByNeighborhood(restaurants$, neighborhood, callback) {
            return restaurants$.filter(function (r) {
                return r.neighborhood === neighborhood;
            }).subscribe(function (n) {
                return callback(null, n);
            }, function (error) {
                return callback(error, null);
            });
        }

        /**
         * Fetch restaurants by a cuisine and a neighborhood with proper error handling.
         * @param {Observable} restaurants$
         * @param {String} cuisine
         * @param {String} neighborhood
         * @static
         * @return {Observable}
         */

    }, {
        key: 'fetchRestaurantByCuisineAndNeighborhood',
        value: function fetchRestaurantByCuisineAndNeighborhood(restaurants$, cuisine, neighborhood) {
            return restaurants$.filter(function (r) {
                return (cuisine !== 'all' && r.cuisine_type === cuisine || cuisine === 'all') && (neighborhood !== 'all' && r.neighborhood === neighborhood || neighborhood === 'all');
            });
        }

        /**
         * Fetch all neighborhoods with proper error handling.
         * @param {Observable} restaurants$
         * @static
         * @return {Observable<*>}
         */

    }, {
        key: 'fetchNeighborhoods',
        value: function fetchNeighborhoods(restaurants$) {
            return restaurants$.map(function (r) {
                return r.neighborhood;
            }).distinct();
        }

        /**
         * Fetch all cuisines with proper error handling.
         * @param {Observable} restaurants$
         * @static
         * @return {Subscription}
         */

    }, {
        key: 'fetchCuisines',
        value: function fetchCuisines(restaurants$) {
            return restaurants$.map(function (r) {
                return r.cuisine_type;
            }).distinct();
        }

        /**
         * Restaurant page URL.
         * @param {Object} restaurant
         * @static
         * @return {String}
         */


        /**
         * Restaurant image URL.
         * @param {Object} restaurant
         * @static
         * @return {String}
         */

    }, {
        key: 'mapMarkerForRestaurant',


        /**
         * Map marker for a restaurant.
         * @param {Object} restaurant
         * @param {google.maps.Map} map
         * @static
         * @return {google.maps.Marker}
         */
        value: function mapMarkerForRestaurant(restaurant, map) {
            return new google.maps.Marker({
                position: restaurant.latlng,
                title: restaurant.name,
                url: DBHelper.urlForRestaurant(restaurant),
                map: map,
                animation: google.maps.Animation.DROP
            });
        }
    }, {
        key: 'API_URL',


        /**
         * Database URL.
         * @description restaurants.json file location on your server.
         * @static
         * @return {String}
         */
        get: function get() {
            return '/restaurants/';
        }

        /**
         * Database Name.
         * @description Indexed database name
         * @static
         * @return {String}
         */

    }, {
        key: 'DATABASE_NAME',
        get: function get() {
            return 'restaurants';
        }

        /**
         * Returns current database number set by developer
         * @static
         * @return {number}
         */

    }, {
        key: 'DATABASE_VERSION',
        get: function get() {
            return 1;
        }
    }]);

    return DBHelper;
}();

DBHelper.urlForRestaurant = function (restaurant) {
    return './review/' + restaurant.id;
};

DBHelper.imageUrlForRestaurant = function (restaurant) {
    return '/img/' + restaurant.photograph;
};

exports.default = DBHelper;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRiaGVscGVyLmpzIl0sIm5hbWVzIjpbIkRCSGVscGVyIiwibmFtZSIsIkRCIiwic3RvcmVzIiwidmVyc2lvbiIsIkRBVEFCQVNFX1ZFUlNJT04iLCJkZWxldGUiLCJvcGVuIiwidHlwZSIsImZuIiwib24iLCJzdG9yZU5hbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZElEQkV2ZW50TGlzdGVuZXIiLCJjb3VudCIsImNhbGxiYWNrIiwidHJhbnNhY3Rpb24iLCJEQVRBQkFTRV9OQU1FIiwiY3JlYXRlIiwiZ2V0SlNPTiIsIkFQSV9VUkwiLCJtZXJnZU1hcCIsImZyb20iLCJ4IiwicXVlcnkiLCJnZXQiLCJ0aGVuIiwicmVzdWx0IiwiY2F0Y2giLCJlcnIiLCJodHRwIiwiWE1MSHR0cFJlcXVlc3QiLCJ1cmwiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInN0YXR1cyIsInNlbmQiLCJpZCIsInN1YnNjcmliZSIsInJlc3RhdXJhbnRzIiwiZXJyb3IiLCJyZXN0YXVyYW50cyQiLCJjdWlzaW5lIiwiZmlsdGVyIiwiciIsImN1aXNpbmVfdHlwZSIsImMiLCJuZWlnaGJvcmhvb2QiLCJuIiwibWFwIiwiZGlzdGluY3QiLCJyZXN0YXVyYW50IiwiZ29vZ2xlIiwibWFwcyIsIk1hcmtlciIsInBvc2l0aW9uIiwibGF0bG5nIiwidGl0bGUiLCJ1cmxGb3JSZXN0YXVyYW50IiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwiRFJPUCIsImltYWdlVXJsRm9yUmVzdGF1cmFudCIsInBob3RvZ3JhcGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQTs7O0lBR01BLFE7Ozs7Ozs7OztBQStCRjs7Ozs7O3dDQU11QkMsSSxFQUFNO0FBQ3pCLG1CQUFPLG9CQUFVQSxJQUFWLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7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QSxDOztrQkF1QnBCbEUsUSIsImZpbGUiOiJkYmhlbHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7QWpheE9ic2VydmFibGV9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9kb20vQWpheE9ic2VydmFibGUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZSc7XG5pbXBvcnQgRGV4aWUgZnJvbSAnZGV4aWUnO1xuXG4vKipcbiAqIENvbW1vbiBkYXRhYmFzZSBoZWxwZXIgZnVuY3Rpb25zLlxuICovXG5jbGFzcyBEQkhlbHBlciB7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhYmFzZSBVUkwuXG4gICAgICogQGRlc2NyaXB0aW9uIHJlc3RhdXJhbnRzLmpzb24gZmlsZSBsb2NhdGlvbiBvbiB5b3VyIHNlcnZlci5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQVBJX1VSTCgpIHtcbiAgICAgICAgcmV0dXJuICcvcmVzdGF1cmFudHMvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhYmFzZSBOYW1lLlxuICAgICAqIEBkZXNjcmlwdGlvbiBJbmRleGVkIGRhdGFiYXNlIG5hbWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgREFUQUJBU0VfTkFNRSgpIHtcbiAgICAgICAgcmV0dXJuICdyZXN0YXVyYW50cyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IGRhdGFiYXNlIG51bWJlciBzZXQgYnkgZGV2ZWxvcGVyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IERBVEFCQVNFX1ZFUlNJT04oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5kZXhlZERCIG1hbmFnZWQgYnkgRGV4aWVcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtEZXhpZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5kZXhlZERCKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5kZXhlZERCIHRhYmxlXG4gICAgICogQHBhcmFtIHtEZXhpZX0gREIgRGF0YWJhc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RvcmVzIFN0b3JlcyBhbmQgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge0RleGllLlZlcnNpb248TnVtYmVyPn0gZGF0YWJhc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5kZXhlZFN0b3JlcyhEQiwgc3RvcmVzKSB7XG5cbiAgICAgICAgcmV0dXJuIERCLnZlcnNpb24oREJIZWxwZXIuREFUQUJBU0VfVkVSU0lPTikuc3RvcmVzKHN0b3Jlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBpbmRleGVkIGRhdGFiYXNlXG4gICAgICogQHBhcmFtIHtEZXhpZX0gREJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlSW5kZXhlZERCKERCKSB7XG4gICAgICAgIHJldHVybiBEQi5kZWxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBpbmRleGVkREIgc2V0dGluZ3MgYW5kIGlmIHNldCwgRGV4aWUub24gd2F0Y2hlclxuICAgICAqIEBwYXJhbSB7RGV4aWV9IERCXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8RGV4aWU+fVxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0SW5kZXhlZERCKERCKSB7XG4gICAgICAgIHJldHVybiBEQi5vcGVuKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGxpc3RlbmVyIGZvciBhbiBpbmRleGVkREIgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0RleGllfSBEQlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSURCRXZlbnRMaXN0ZW5lcihEQiwgdHlwZSwgZm4pIHtcbiAgICAgICAgREIub24odHlwZSwgZm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGZ1bmN0aW9uIGlmIGluZGV4ZWREQiBpcyBub3QgZW1wdHlcbiAgICAgKiBAcGFyYW0ge0RleGllfSBEQlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVOYW1lXG4gICAgICovXG4gICAgc3RhdGljIGlmSW5kZXhlZERCRW1wdHkoREIsIHN0b3JlTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERCSGVscGVyLmFkZElEQkV2ZW50TGlzdGVuZXIoREIsICdyZWFkeScsICgpID0+IERCW3N0b3JlTmFtZV0uY291bnQoKGNvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnREIgbm90IGVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYW4gY2FsbGJhY2sgd2hlbiBoYXZpbmcgYWNjZXNzIHRvIGluZGV4ZWQgdGFibGUgcmVjb3Jkc1xuICAgICAqIEBwYXJhbSB7RGV4aWV9IERCXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7RGV4aWUuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5kZXhlZFRhYmxlT3BlbihEQiwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIERCLnRyYW5zYWN0aW9uKCdydycsIERCSGVscGVyLkRBVEFCQVNFX05BTUUsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoIGFsbCByZXN0YXVyYW50cy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmV0Y2hSZXN0YXVyYW50cygpIHtcbiAgICAgICAgcmV0dXJuIEFqYXhPYnNlcnZhYmxlLmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SlNPTihEQkhlbHBlci5BUElfVVJMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWVyZ2VNYXAoeCA9PiBPYnNlcnZhYmxlLmZyb20oeCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RleGllfSBEQlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHF1ZXJ5IGFyZ3VtZW50cyBmb3IgaW5kZXhlZERCIHF1ZXJ5IGlkL1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZW50cnlFeGlzdHMoREIsIHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBEQi50cmFuc2FjdGlvbigncncnLCBEQkhlbHBlci5EQVRBQkFTRV9OQU1FLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgREJbREJIZWxwZXIuREFUQUJBU0VfTkFNRV1cbiAgICAgICAgICAgICAgICAgICAgLmdldCguLi5xdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4gcmVzb2x2ZShyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge3JlamVjdChlcnIpfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIEFQSSBoYXZlIGNoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBuZWVkc1VwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICBodHRwLm9wZW4oJ0hFQUQnLCB1cmwpO1xuICAgICAgICAgICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnN0YXR1cyAhPT0gMzA0ICYmIHRoaXMuc3RhdHVzICE9PSA0MDQpICYmIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHR0cC5zZW5kKCk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSByZXN0YXVyYW50IGJ5IGl0cyBJRC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259XG4gICAgICovXG4gICAgc3RhdGljIGZldGNoUmVzdGF1cmFudEJ5SWQoaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBBamF4T2JzZXJ2YWJsZS5jcmVhdGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SlNPTihgJHtEQkhlbHBlci5BUElfVVJMfSR7aWR9YClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXN0YXVyYW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdGF1cmFudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soYEdvdCBlcnJvciAke2Vycm9yfSBmZXRjaGluZyByZXN0YXVyYW50IElEOiB7JHtpZH19IGZyb20gcmVtb3RlYCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoIHJlc3RhdXJhbnRzIGJ5IGEgY3Vpc2luZSB0eXBlIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcmVzdGF1cmFudHMkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1aXNpbmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259XG4gICAgICovXG4gICAgc3RhdGljIGZldGNoUmVzdGF1cmFudEJ5Q3Vpc2luZShyZXN0YXVyYW50cyQsIGN1aXNpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiByZXN0YXVyYW50cyRcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiByLmN1aXNpbmVfdHlwZSA9PT0gY3Vpc2luZSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgKGMpID0+IGNhbGxiYWNrKG51bGwsIGMpLFxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4gY2FsbGJhY2soZXJyb3IsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoIHJlc3RhdXJhbnRzIGJ5IGEgbmVpZ2hib3Job29kIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gcmVzdGF1cmFudHMkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5laWdoYm9yaG9vZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmV0Y2hSZXN0YXVyYW50QnlOZWlnaGJvcmhvb2QocmVzdGF1cmFudHMkLCBuZWlnaGJvcmhvb2QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiByZXN0YXVyYW50cyRcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiByLm5laWdoYm9yaG9vZCA9PT0gbmVpZ2hib3Job29kKVxuICAgICAgICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAobikgPT4gY2FsbGJhY2sobnVsbCwgbiksXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiBjYWxsYmFjayhlcnJvciwgbnVsbClcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggcmVzdGF1cmFudHMgYnkgYSBjdWlzaW5lIGFuZCBhIG5laWdoYm9yaG9vZCB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZy5cbiAgICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHJlc3RhdXJhbnRzJFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdWlzaW5lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5laWdoYm9yaG9vZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfVxuICAgICAqL1xuICAgIHN0YXRpYyBmZXRjaFJlc3RhdXJhbnRCeUN1aXNpbmVBbmROZWlnaGJvcmhvb2QocmVzdGF1cmFudHMkLCBjdWlzaW5lLCBuZWlnaGJvcmhvb2QpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RhdXJhbnRzJFxuICAgICAgICAgICAgLmZpbHRlcigocikgPT4ge3JldHVybiAoY3Vpc2luZSAhPT0gJ2FsbCcgJiYgci5jdWlzaW5lX3R5cGUgPT09IGN1aXNpbmUgfHwgY3Vpc2luZSA9PT0gJ2FsbCcpXG4gICAgICAgICAgICAgICAgJiYgKG5laWdoYm9yaG9vZCAhPT0gJ2FsbCcgJiYgci5uZWlnaGJvcmhvb2QgPT09IG5laWdoYm9yaG9vZCB8fCBuZWlnaGJvcmhvb2QgPT09ICdhbGwnKX1cbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIG5laWdoYm9yaG9vZHMgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmcuXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlfSByZXN0YXVyYW50cyRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTwqPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmV0Y2hOZWlnaGJvcmhvb2RzKHJlc3RhdXJhbnRzJCkge1xuICAgICAgICByZXR1cm4gcmVzdGF1cmFudHMkXG4gICAgICAgICAgICAubWFwKHIgPT4gci5uZWlnaGJvcmhvb2QpXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoIGFsbCBjdWlzaW5lcyB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZy5cbiAgICAgKiBAcGFyYW0ge09ic2VydmFibGV9IHJlc3RhdXJhbnRzJFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259XG4gICAgICovXG4gICAgc3RhdGljIGZldGNoQ3Vpc2luZXMocmVzdGF1cmFudHMkKSB7XG4gICAgICAgIHJldHVybiByZXN0YXVyYW50cyRcbiAgICAgICAgICAgIC5tYXAociA9PiByLmN1aXNpbmVfdHlwZSlcbiAgICAgICAgICAgIC5kaXN0aW5jdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdGF1cmFudCBwYWdlIFVSTC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdGF1cmFudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVybEZvclJlc3RhdXJhbnQgPSAocmVzdGF1cmFudCkgPT4gKGAuL3Jldmlldy8ke3Jlc3RhdXJhbnQuaWR9YCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0YXVyYW50IGltYWdlIFVSTC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdGF1cmFudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGltYWdlVXJsRm9yUmVzdGF1cmFudCA9IChyZXN0YXVyYW50KSA9PiAoYC9pbWcvJHtyZXN0YXVyYW50LnBob3RvZ3JhcGh9YCk7XG5cbiAgICAvKipcbiAgICAgKiBNYXAgbWFya2VyIGZvciBhIHJlc3RhdXJhbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlc3RhdXJhbnRcbiAgICAgKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcH0gbWFwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm4ge2dvb2dsZS5tYXBzLk1hcmtlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWFwTWFya2VyRm9yUmVzdGF1cmFudChyZXN0YXVyYW50LCBtYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5NYXJrZXIoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHJlc3RhdXJhbnQubGF0bG5nLFxuICAgICAgICAgICAgICAgIHRpdGxlOiByZXN0YXVyYW50Lm5hbWUsXG4gICAgICAgICAgICAgICAgdXJsOiBEQkhlbHBlci51cmxGb3JSZXN0YXVyYW50KHJlc3RhdXJhbnQpLFxuICAgICAgICAgICAgICAgIG1hcDogbWFwLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogZ29vZ2xlLm1hcHMuQW5pbWF0aW9uLkRST1BcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgREJIZWxwZXI7XG4iXX0=
},{"dexie":1,"rxjs/Observable":4,"rxjs/add/observable/from":11,"rxjs/add/observable/fromPromise":12,"rxjs/add/operator/distinct":13,"rxjs/add/operator/filter":14,"rxjs/add/operator/map":15,"rxjs/add/operator/mergeMap":16,"rxjs/observable/dom/AjaxObservable":24}],56:[function(require,module,exports){
"use strict";

var _main = require("./main");

var _main2 = _interopRequireDefault(_main);

var _restaurant_info = require("./restaurant_info");

var _restaurant_info2 = _interopRequireDefault(_restaurant_info);

var _dbhelper = require("./dbhelper");

var _dbhelper2 = _interopRequireDefault(_dbhelper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var neighborhoodsSelect = document.getElementById('neighborhoods-select');
  var cuisinesSelect = document.getElementById('cuisines-select');
  /**
   * Parses current route
   * @return {RegExpMatchArray | null | string[]}
   */
  var routeChecker = function routeChecker() {
    var patt = /([\w_.]+)/g;
    return location.pathname.match(patt) || ['/'];
  };
  /**
   *
   * @param {ServiceWorker} worker
   * @return {void}
   */
  var sw_update_ready = function sw_update_ready(worker) {
    if (confirm('Update is ready. Refresh now?')) {
      worker.postMessage({
        action: 'skipWaiting'
      });
    }
  };
  /**
   *
   * @param {ServiceWorker} worker
   */
  var track_installing = function track_installing(worker) {
    return worker.addEventListener('statechange', function () {
      if (worker.state === 'installed') {
        return sw_update_ready(worker);
      }
    });
  };
  /**
   * Registration of ServiceWorker
   * @return {*}
   */
  var initSW = function initSW() {
    if (navigator.serviceWorker) {
      navigator.serviceWorker.register('/sw.js').then(function (reg) {
        if (!navigator.serviceWorker.controller) {
          return;
        } else if (reg.installing) {
          console.log('Service worker installing');
          track_installing(reg.installing);
        } else if (reg.waiting) {
          console.log('Service worker installed');
        } else if (reg.active) {
          console.log("Service worker active at scope: " + reg.scope);
        }
        return reg.addEventListener('updatefound', function () {
          return track_installing(reg.installing);
        });
      }).catch(function (err) {
        return console.error('ServiceWorker registration failed with error: ' + err);
      });
    }
  };
  /**
   * Initialize Google map, called from HTML.
   * @param {Object} context
   * @param {String} type
   * @return {function}
   */
  var setInitMap = function setInitMap(context, type) {
    switch (type) {
      case '/':
        return self.initMap = function () {
          var loc = {
            lat: 40.722216,
            lng: -73.987501
          };
          context.setState({
            map: new google.maps.Map(document.getElementById('map'), {
              zoom: 12,
              center: loc,
              scrollwheel: false
            })
          });
          R.fetchNeighborhoods();
          R.fetchCuisines();
        };
      case 'review':
        return self.initMap = function () {
          return context.fetchRestaurantFromURL(function (error, restaurant) {
            if (error) {
              // Got an error!
              console.error(error);
            } else {
              context.setState({
                map: new google.maps.Map(document.getElementById('map'), {
                  zoom: 16,
                  center: restaurant.latlng,
                  scrollwheel: false
                })
              });
              context.fillBreadcrumb();
              _dbhelper2.default.mapMarkerForRestaurant(context.state.restaurant, context.state.map);
            }
          });
        };
    }
  };

  switch (routeChecker()[0]) {
    case '/':
      var _R = new _main2.default();
      window.R = _R;
      setInitMap(_R, '/');

      cuisinesSelect.addEventListener('change', function () {
        _R.updateRestaurants();
      });
      neighborhoodsSelect.addEventListener('change', function () {
        _R.updateRestaurants();
      });
      break;
    case 'review':
      var Rv = new _restaurant_info2.default();
      window.Rv = Rv;
      setInitMap(Rv, 'review');
      break;
  }

  initSW(); //init service worker
}).call(undefined); //ensure application runs in right context
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZha2VfNGE0OGYwNTkuanMiXSwibmFtZXMiOlsibmVpZ2hib3Job29kc1NlbGVjdCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjdWlzaW5lc1NlbGVjdCIsInJvdXRlQ2hlY2tlciIsInBhdHQiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwibWF0Y2giLCJzd191cGRhdGVfcmVhZHkiLCJ3b3JrZXIiLCJjb25maXJtIiwicG9zdE1lc3NhZ2UiLCJhY3Rpb24iLCJ0cmFja19pbnN0YWxsaW5nIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0YXRlIiwiaW5pdFNXIiwibmF2aWdhdG9yIiwic2VydmljZVdvcmtlciIsInJlZ2lzdGVyIiwidGhlbiIsInJlZyIsImNvbnRyb2xsZXIiLCJpbnN0YWxsaW5nIiwiY29uc29sZSIsImxvZyIsIndhaXRpbmciLCJhY3RpdmUiLCJzY29wZSIsImNhdGNoIiwiZXJyIiwiZXJyb3IiLCJzZXRJbml0TWFwIiwiY29udGV4dCIsInR5cGUiLCJzZWxmIiwiaW5pdE1hcCIsImxvYyIsImxhdCIsImxuZyIsInNldFN0YXRlIiwibWFwIiwiZ29vZ2xlIiwibWFwcyIsIk1hcCIsInpvb20iLCJjZW50ZXIiLCJzY3JvbGx3aGVlbCIsIlIiLCJmZXRjaE5laWdoYm9yaG9vZHMiLCJmZXRjaEN1aXNpbmVzIiwiZmV0Y2hSZXN0YXVyYW50RnJvbVVSTCIsInJlc3RhdXJhbnQiLCJsYXRsbmciLCJmaWxsQnJlYWRjcnVtYiIsIm1hcE1hcmtlckZvclJlc3RhdXJhbnQiLCJ3aW5kb3ciLCJ1cGRhdGVSZXN0YXVyYW50cyIsIlJ2IiwiY2FsbCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLENBQUMsWUFBWTtBQUNYLE1BQU1BLHNCQUFzQkMsU0FBU0MsY0FBVCxDQUF3QixzQkFBeEIsQ0FBNUI7QUFDQSxNQUFNQyxpQkFBaUJGLFNBQVNDLGNBQVQsQ0FBd0IsaUJBQXhCLENBQXZCO0FBQ0E7Ozs7QUFJ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Q0g1QyxTQUFTQyxjQUFULENBQXdCLEtBQXhCLENBREcsRUFFSDtBQUNFNEMsd0JBQU0sRUFEUjtBQUVFQywwQkFBUU0sV0FBV0MsTUFGckI7QUFHRU4sK0JBQWE7QUFIZixpQkFGRztBQURQLGVBREY7QUFZQWQsc0JBQVFxQixjQUFSO0FBQ0EsaUNBQVNDLHNCQUFULENBQWdDdEIsUUFBUWxCLEtBQVIsQ0FBY3FDLFVBQTlDLEVBQTBEbkIsUUFBUWxCLEtBQVIsQ0FBYzBCLEdBQXhFO0FBQ0Q7QUFDRixXQXBCeUIsQ0FBTjtBQUFBLFNBQXRCO0FBdkJKO0FBNkNELEdBOUNEOztBQWlEQSxVQUFRdEMsZUFBZSxDQUFmLENBQVI7QUFDRSxTQUFLLEdBQUw7QUFDRSxVQUFNNkMsS0FBSSxvQkFBVjtBQUNBUSxhQUFPUixDQUFQLEdBQVdBLEVBQVg7QUFDQWhCLGlCQUFXZ0IsRUFBWCxFQUFjLEdBQWQ7O0FBRUE5QyxxQkFBZVksZ0JBQWYsQ0FBZ0MsUUFBaEMsRUFBMEMsWUFBTTtBQUM5Q2tDLFdBQUVTLGlCQUFGO0FBQ0QsT0FGRDtBQUdBMUQsMEJBQW9CZSxnQkFBcEIsQ0FBcUMsUUFBckMsRUFBK0MsWUFBTTtBQUNuRGtDLFdBQUVTLGlCQUFGO0FBQ0QsT0FGRDtBQUdBO0FBQ0YsU0FBSyxRQUFMO0FBQ0UsVUFBTUMsS0FBSywrQkFBWDtBQUNBRixhQUFPRSxFQUFQLEdBQVlBLEVBQVo7QUFDQTFCLGlCQUFXMEIsRUFBWCxFQUFlLFFBQWY7QUFDQTtBQWpCSjs7QUFvQkExQyxXQXpJVyxDQXlJRDtBQUVYLENBM0lELEVBMklHMkMsSUEzSUgsWSxDQTJJZSIsImZpbGUiOiJmYWtlXzRhNDhmMDU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlc3RhdXJhbnQgZnJvbSAnLi9tYWluJztcbmltcG9ydCBSZXZpZXcgZnJvbSBcIi4vcmVzdGF1cmFudF9pbmZvXCI7XG5pbXBvcnQgREJIZWxwZXIgZnJvbSBcIi4vZGJoZWxwZXJcIjtcblxuKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbmVpZ2hib3Job29kc1NlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZWlnaGJvcmhvb2RzLXNlbGVjdCcpO1xuICBjb25zdCBjdWlzaW5lc1NlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdWlzaW5lcy1zZWxlY3QnKTtcbiAgLyoqXG4gICAqIFBhcnNlcyBjdXJyZW50IHJvdXRlXG4gICAqIEByZXR1cm4ge1JlZ0V4cE1hdGNoQXJyYXkgfCBudWxsIHwgc3RyaW5nW119XG4gICAqL1xuICBjb25zdCByb3V0ZUNoZWNrZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgcGF0dCA9IC8oW1xcd18uXSspL2c7XG4gICAgcmV0dXJuIGxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKHBhdHQpIHx8IFsnLyddO1xuICB9O1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlV29ya2VyfSB3b3JrZXJcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNvbnN0IHN3X3VwZGF0ZV9yZWFkeSA9IGZ1bmN0aW9uICh3b3JrZXIpIHtcbiAgICBpZiAoY29uZmlybSgnVXBkYXRlIGlzIHJlYWR5LiBSZWZyZXNoIG5vdz8nKSkge1xuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgYWN0aW9uOiAnc2tpcFdhaXRpbmcnXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlV29ya2VyfSB3b3JrZXJcbiAgICovXG4gIGNvbnN0IHRyYWNrX2luc3RhbGxpbmcgPSAod29ya2VyKSA9PiB7XG4gICAgcmV0dXJuIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmICh3b3JrZXIuc3RhdGUgPT09ICdpbnN0YWxsZWQnKSB7XG4gICAgICAgIHJldHVybiBzd191cGRhdGVfcmVhZHkod29ya2VyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFJlZ2lzdHJhdGlvbiBvZiBTZXJ2aWNlV29ya2VyXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBjb25zdCBpbml0U1cgPSAoKSA9PiB7XG4gICAgaWYgKG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyKSB7XG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcignL3N3LmpzJykudGhlbigocmVnKSA9PiB7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChyZWcuaW5zdGFsbGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWNlIHdvcmtlciBpbnN0YWxsaW5nJyk7XG4gICAgICAgICAgdHJhY2tfaW5zdGFsbGluZyhyZWcuaW5zdGFsbGluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnLndhaXRpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2VydmljZSB3b3JrZXIgaW5zdGFsbGVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnLmFjdGl2ZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTZXJ2aWNlIHdvcmtlciBhY3RpdmUgYXQgc2NvcGU6ICR7cmVnLnNjb3BlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWcuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZm91bmQnLCAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrX2luc3RhbGxpbmcocmVnLmluc3RhbGxpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1NlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9O1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBHb29nbGUgbWFwLCBjYWxsZWQgZnJvbSBIVE1MLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIGNvbnN0IHNldEluaXRNYXAgPSAoY29udGV4dCwgdHlwZSkgPT4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIHJldHVybiBzZWxmLmluaXRNYXAgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IGxvYyA9IHtcbiAgICAgICAgICAgIGxhdDogNDAuNzIyMjE2LFxuICAgICAgICAgICAgbG5nOiAtNzMuOTg3NTAxXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb250ZXh0LnNldFN0YXRlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXA6IG5ldyBnb29nbGUubWFwcy5NYXAoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcCcpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHpvb206IDEyLFxuICAgICAgICAgICAgICAgICAgY2VudGVyOiBsb2MsXG4gICAgICAgICAgICAgICAgICBzY3JvbGx3aGVlbDogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIFIuZmV0Y2hOZWlnaGJvcmhvb2RzKCk7XG4gICAgICAgICAgUi5mZXRjaEN1aXNpbmVzKCk7XG4gICAgICAgIH07XG4gICAgICBjYXNlICdyZXZpZXcnOlxuICAgICAgICByZXR1cm4gc2VsZi5pbml0TWFwID0gKCkgPT4gY29udGV4dC5mZXRjaFJlc3RhdXJhbnRGcm9tVVJMKFxuICAgICAgICAgIChlcnJvciwgcmVzdGF1cmFudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7IC8vIEdvdCBhbiBlcnJvciFcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0LnNldFN0YXRlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG1hcDogbmV3IGdvb2dsZS5tYXBzLk1hcChcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcCcpLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgem9vbTogMTYsXG4gICAgICAgICAgICAgICAgICAgICAgY2VudGVyOiByZXN0YXVyYW50LmxhdGxuZyxcbiAgICAgICAgICAgICAgICAgICAgICBzY3JvbGx3aGVlbDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGV4dC5maWxsQnJlYWRjcnVtYigpO1xuICAgICAgICAgICAgICBEQkhlbHBlci5tYXBNYXJrZXJGb3JSZXN0YXVyYW50KGNvbnRleHQuc3RhdGUucmVzdGF1cmFudCwgY29udGV4dC5zdGF0ZS5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuXG4gIHN3aXRjaCAocm91dGVDaGVja2VyKClbMF0pIHtcbiAgICBjYXNlICcvJzpcbiAgICAgIGNvbnN0IFIgPSBuZXcgUmVzdGF1cmFudCgpO1xuICAgICAgd2luZG93LlIgPSBSO1xuICAgICAgc2V0SW5pdE1hcChSLCAnLycpO1xuXG4gICAgICBjdWlzaW5lc1NlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIFIudXBkYXRlUmVzdGF1cmFudHMoKTtcbiAgICAgIH0pO1xuICAgICAgbmVpZ2hib3Job29kc1NlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIFIudXBkYXRlUmVzdGF1cmFudHMoKTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmV2aWV3JzpcbiAgICAgIGNvbnN0IFJ2ID0gbmV3IFJldmlldygpO1xuICAgICAgd2luZG93LlJ2ID0gUnY7XG4gICAgICBzZXRJbml0TWFwKFJ2LCAncmV2aWV3Jyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGluaXRTVygpOyAvL2luaXQgc2VydmljZSB3b3JrZXJcblxufSkuY2FsbCh0aGlzKTsgLy9lbnN1cmUgYXBwbGljYXRpb24gcnVucyBpbiByaWdodCBjb250ZXh0XG4iXX0=
},{"./dbhelper":55,"./main":57,"./restaurant_info":58}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createResponsiveImg = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _dbhelper = require('./dbhelper');

var _dbhelper2 = _interopRequireDefault(_dbhelper);

var _Observable = require('rxjs/Observable');

var _Subject = require('rxjs/Subject');

require('rxjs/add/operator/map');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class Restaurant
 */
var Restaurant = function Restaurant() {
  var _this = this;

  _classCallCheck(this, Restaurant);

  this.state = {
    restaurants: null,
    neighborhoods: [],
    cuisines: [],
    map: null,
    markers: [],
    inexedDB: false
  };

  this.setState = function (patch) {
    return _this.state = _extends({}, _this.state, patch);
  };

  this.fetchNeighborhoods = function () {
    _this.state.neighborhoods = [];
    var fetchN = function fetchN(r) {
      _this.state.neighborhoods = [];
      return _dbhelper2.default.fetchNeighborhoods(r).subscribe(function (neighborhoods) {
        _this.state.neighborhoods.push(neighborhoods);
        _this.fillNeighborhoodsHTML(neighborhoods);
      }, function (error) {
        return console.error(error);
      });
    };

    if (_this.state.restaurants && _this.state.restaurants.length !== 0) {
      fetchN(_this.state.restaurants);
    } else {
      fetchN(_this.setRestaurants());
    }
  };

  this.fillNeighborhoodsHTML = function (neighborhood) {
    var select = document.getElementById('neighborhoods-select');

    var option = document.createElement('option');
    option.innerHTML = neighborhood;
    option.value = neighborhood;
    try {
      select.append(option);
    } catch (e) {
      select.innerHTML += option.outerHTML;
    }
    return option;
  };

  this.fetchCuisines = function () {
    _this.state.cuisines = [];
    _dbhelper2.default.fetchCuisines(_this.state.restaurants).subscribe(function (cuisine) {
      _this.state.cuisines.push(cuisine);
      _this.fillCuisinesHTML(cuisine);
    }, function (error) {
      return console.error(error);
    });
  };

  this.fillCuisinesHTML = function (cuisine) {
    var select = document.getElementById('cuisines-select');

    var option = document.createElement('option');
    option.innerHTML = cuisine;
    option.value = cuisine;
    try {
      select.append(option);
    } catch (e) {
      select.innerHTML += option.outerHTML;
    }
    return option;
  };

  this.setRestaurants = function () {
    _this.state.restaurants = new _Subject.Subject();
    var DB = _dbhelper2.default.createIndexedDB(_dbhelper2.default.DATABASE_NAME);
    _dbhelper2.default.createIndexedStores(DB, { restaurants: 'id++,name,neighborhood,cuisine_type' });
    _this.resetRestaurants();
    return _dbhelper2.default.fetchRestaurants().map(function (restaurant) {
      _this.fillRestaurantsHTML(restaurant);
      _this.state.restaurants.next(restaurant);
      DB[_dbhelper2.default.DATABASE_NAME].put(restaurant).then(function () {
        _this.state.inexedDB = true;
      }).catch(console.error);
      return restaurant;
    }, function (error) {
      return console.error(error);
    });
  };

  this.updateRestaurants = function () {
    var cSelect = document.getElementById('cuisines-select');
    var nSelect = document.getElementById('neighborhoods-select');

    var cIndex = cSelect.selectedIndex;
    var nIndex = nSelect.selectedIndex;

    var cuisine = cSelect[cIndex].value;
    var neighborhood = nSelect[nIndex].value;

    // Remove all restaurants
    _this.resetRestaurants();
    _dbhelper2.default.fetchRestaurantByCuisineAndNeighborhood(_dbhelper2.default.fetchRestaurants(), cuisine, neighborhood).subscribe(function (r) {
      console.log(r);
      _this.fillRestaurantsHTML(r);
    }, function (error) {
      return console.error(error);
    });
  };

  this.resetRestaurants = function () {
    var ul = document.getElementById('restaurants-list');
    ul.innerHTML = '';
    // Remove all map markers
    _this.state.markers = _this.state.markers ? _this.state.markers : [];
    _this.state.markers.forEach(function (m) {
      return m.setMap(null);
    });
  };

  this.fillRestaurantsHTML = function (restaurant) {
    var ul = document.getElementById('restaurants-list');

    try {
      ul.append(_this.createRestaurantHTML(restaurant));
    } catch (e) {
      ul.innerHTML += _this.createRestaurantHTML(restaurant).outerHTML; // support for MS Edge
    }

    _this.addMarkersToMap(restaurant);
  };

  this.createRestaurantHTML = function (restaurant) {
    var container = document.createElement('div');
    var randomId = 'n' + String(Math.random()).split('.')[1];
    container.innerHTML = ('<li role="banner" aria-labelledby="' + randomId + '">\n<div id="' + randomId + '">\n' + Restaurant.createResponsiveImg(_dbhelper2.default.imageUrlForRestaurant(restaurant), 'Image of ' + restaurant.name + ' restaurant') + '\n<h2 role="heading">' + restaurant.name + '</h2>\n<p>' + restaurant.neighborhood + '</p>\n<p>' + restaurant.address + '</p>\n</div>\n<a role="link" href="' + _dbhelper2.default.urlForRestaurant(restaurant) + '">View Details</a></li>').replace(/>\s+</, '><'); //just in case browser will render unwanted space
    return container.firstChild;
  };

  this.addMarkersToMap = function (restaurant) {
    var marker = _dbhelper2.default.mapMarkerForRestaurant(restaurant, _this.state.map);
    google.maps.event.addListener(marker, 'click', function () {
      window.location.href = marker.url;
    });
    _this.state.markers.push(marker);
  };
}
/**
 * Sets state of Restaurant class
 * @param {Object} patch - Patch object
 * @return {{restaurants: null, neighborhoods: Array, cuisines: Array, map: null, markers: Array, inexedDB: boolean}}
 */


/**
 * Fetch all neighborhoods and set their HTML.
 * @return {Subscription}
 */


/**
 * Set neighborhoods HTML.
 * @param {String} neighborhood
 * @return {HTMLOptionElement}
 */


/**
 * Fetch all cuisines and set their HTML.
 * @return {void}
 */


/**
 * Set cuisines HTML.
 * @param {String} cuisine
 * @return {HTMLOptionElement}
 */


/**
 * When fetched or update restaurants this sets state.restaurants to collection of restaurants
 * @return {Observable}
 */


/**
 * Update page and map for current restaurants.
 * @return {void}
 */


/**
 * Clear current restaurants, their HTML and remove their map markers.
 * @return {void}
 */


/**
 * Create all restaurants HTML and add them to the webpage.
 * @return {void}
 */


/**
 * Generates responsive image HTML
 * @param url {string}
 * @param alt {string}
 * @return {string}
 */


/**
 * Create restaurant HTML.
 * @param restaurant {Object}
 * @return {Node}
 */


/**
 * Add markers for current restaurants to the map.
 * @param {Object} restaurant
 * @return {Function}
 */
;

Restaurant.createResponsiveImg = function (url, alt) {
  var parsedURL = url.split('.');
  var urlWithoutExt = parsedURL[parsedURL.length - 1];
  return '<picture class="restaurant-img">\n  <source media="(max-width: 719px)"\n    srcset=".' + urlWithoutExt + '-100-1x.jpg 1x, .' + urlWithoutExt + '-100-2x.jpg 2x, .' + urlWithoutExt + '-100-3x.jpg 3x">\n  <source  media="(min-width: 720px)"\n    srcset=".' + url + '.jpg 1x">\n  <img class="restaurant-img" src=".' + url + '.jpg" alt="' + alt + '">\n</picture>';
};

exports.default = Restaurant;
var createResponsiveImg = exports.createResponsiveImg = Restaurant.createResponsiveImg;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsiUmVzdGF1cmFudCIsInN0YXRlIiwicmVzdGF1cmFudHMiLCJuZWlnaGJvcmhvb2RzIiwiY3Vpc2luZXMiLCJtYXAiLCJtYXJrZXJzIiwiaW5leGVkREIiLCJzZXRTdGF0ZSIsInBhdGNoIiwiZmV0Y2hOZWlnaGJvcmhvb2RzIiwiZmV0Y2hOIiwiciIsInN1YnNjcmliZSIsInB1c2giLCJmaWxsTmVpZ2hib3Job29kc0hUTUwiLCJlcnJvciIsImNvbnNvbGUiLCJsZW5ndGgiLCJzZXRSZXN0YXVyYW50cyIsIm5laWdoYm9yaG9vZCIsInNlbGVjdCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJvcHRpb24iLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwidmFsdWUiLCJhcHBlbmQiLCJlIiwib3V0ZXJIVE1MIiwiZmV0Y2hDdWlzaW5lcyIsImN1aXNpbmUiLCJmaWxsQ3Vpc2luZXNIVE1MIiwiREIiLCJjcmVhdGVJbmRleGVkREIiLCJEQVRBQkFTRV9OQU1FIiwiY3JlYXRlSW5kZXhlZFN0b3JlcyIsInJlc2V0UmVzdGF1cmFudHMiLCJmZXRjaFJlc3RhdXJhbnRzIiwicmVzdGF1cmFudCIsImZpbGxSZXN0YXVyYW50c0hUTUwiLCJuZXh0IiwicHV0IiwidGhlbiIsImNhdGNoIiwidXBkYXRlUmVzdGF1cmFudHMiLCJjU2VsZWN0IiwiblNlbGVjdCIsImNJbmRleCIsInNlbGVjdGVkSW5kZXgiLCJuSW5kZXgiLCJmZXRjaFJlc3RhdXJhbnRCeUN1aXNpbmVBbmROZWlnaGJvcmhvb2QiLCJsb2ciLCJ1bCIsImZvckVhY2giLCJtIiwic2V0TWFwIiwiY3JlYXRlUmVzdGF1cmFudEhUTUwiLCJhZGRNYXJrZXJzVG9NYXAiLCJjb250YWluZXIiLCJyYW5kb21JZCIsIlN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzcGxpdCIsImNyZWF0ZVJlc3BvbnNpdmVJbWciLCJpbWFnZVVybEZvclJlc3RhdXJhbnQiLCJuYW1lIiwiYWRkcmVzcyIsInVybEZvclJlc3RhdXJhbnQiLCJyZXBsYWNlIiwiZmlyc3RDaGlsZCIsIm1hcmtlciIsIm1hcE1hcmtlckZvclJlc3RhdXJhbnQiLCJnb29nbGUiLCJtYXBzIiwiZXZlbnQiLCJhZGRMaXN0ZW5lciIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsInVybCIsImFsdCIsInBhcnNlZFVSTCIsInVybFdpdGhvdXRFeHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBOzs7SUFHTUEsVTs7Ozs7T0FFSkMsSyxHQUFRO0FBQ05DLGlCQUFhLElBRFA7QUFFTkMsbUJBQWUsRUFGVDtBQUdOQyxjQUFVLEVBSEo7QUFJTkMsU0FBSyxJQUpDO0FBS05DLGFBQVMsRUFMSDtBQU1OQyxjQUFVO0FBTkosRzs7T0FhUkMsUSxHQUFXLFVBQUNDLEtBQUQsRUFBVztBQUNwQixXQUFPLE1BQUtSLEtBQUwsZ0JBQ0YsTUFBS0EsS0FESCxFQUVGUSxLQUZFLENBQVA7QUFJRCxHOztPQU1EQyxrQixHQUFxQixZQUFNO0FBQ3pCLFVBQUtULEtBQUwsQ0FBV0UsYUFBWCxHQUEyQixFQUEzQjtBQUNBLFFBQU1RLFNBQVMsU0FBVEEsTUFBUyxDQUFDQyxDQUFELEVBQU87QUFDcEIsWUFBS1gsS0FBTCxDQUFXRSxhQUFYLEdBQTJCLEVBQTNCO0FBQ0EsYUFBTyxtQkFDSk8sa0JBREksQ0FDZUUsQ0FEZixFQUVKQyxTQUZJLENBR0gsVUFBQ1YsYUFBRCxFQUFtQjtBQUNqQixjQUFLRixLQUFMLENBQVdFLGFBQVgsQ0FBeUJXLElBQXpCLENBQThCWCxhQUE5QjtBQUNBLGNBQUtZLHFCQUFMLENBQTJCWixhQUEzQjtBQUNELE9BTkUsRUFPSCxVQUFDYSxLQUFEO0FBQUEsZUFBV0MsUUFBUUQsS0FBUixDQUFjQSxLQUFkLENBQVg7QUFBQSxPQVBHLENBQVA7QUFTRCxLQVhEOztBQWFBLFFBQUksTUFBS2YsS0FBTCxDQUFXQyxXQUFYLElBQTBCLE1BQUtELEtB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QjJELE1BQXhCO0FBQ0QsRzs7QUE5TkQ7Ozs7Ozs7QUFZQTs7Ozs7O0FBMEJBOzs7Ozs7O0FBbUJBOzs7Ozs7QUFnQkE7Ozs7Ozs7QUFtQkE7Ozs7OztBQTBCQTs7Ozs7O0FBMEJBOzs7Ozs7QUFZQTs7Ozs7O0FBZ0JBOzs7Ozs7OztBQW1CQTs7Ozs7OztBQW9CQTs7Ozs7OztBQTdOSXpFLFUsQ0E0TEdrRSxtQixHQUFzQixVQUFDZ0IsR0FBRCxFQUFNQyxHQUFOLEVBQWM7QUFDekMsTUFBTUMsWUFBWUYsSUFBSWpCLEtBQUosQ0FBVSxHQUFWLENBQWxCO0FBQ0EsTUFBTW9CLGdCQUFnQkQsVUFBVUEsVUFBVWxFLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBdEI7QUFDQSxtR0FFV21FLGFBRlgseUJBRTRDQSxhQUY1Qyx5QkFFNkVBLGFBRjdFLDhFQUlXSCxHQUpYLHVEQUtrQ0EsR0FMbEMsbUJBS21EQyxHQUxuRDtBQVFELEM7O2tCQXFDWW5GLFU7QUFDUixJQUFNa0Usb0RBQXNCbEUsV0FBV2tFLG1CQUF2QyIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERCSGVscGVyIGZyb20gJy4vZGJoZWxwZXInO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuXG4vKipcbiAqIEBjbGFzcyBSZXN0YXVyYW50XG4gKi9cbmNsYXNzIFJlc3RhdXJhbnQge1xuXG4gIHN0YXRlID0ge1xuICAgIHJlc3RhdXJhbnRzOiBudWxsLFxuICAgIG5laWdoYm9yaG9vZHM6IFtdLFxuICAgIGN1aXNpbmVzOiBbXSxcbiAgICBtYXA6IG51bGwsXG4gICAgbWFya2VyczogW10sXG4gICAgaW5leGVkREI6IGZhbHNlLFxuICB9O1xuICAvKipcbiAgICogU2V0cyBzdGF0ZSBvZiBSZXN0YXVyYW50IGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaCAtIFBhdGNoIG9iamVjdFxuICAgKiBAcmV0dXJuIHt7cmVzdGF1cmFudHM6IG51bGwsIG5laWdoYm9yaG9vZHM6IEFycmF5LCBjdWlzaW5lczogQXJyYXksIG1hcDogbnVsbCwgbWFya2VyczogQXJyYXksIGluZXhlZERCOiBib29sZWFufX1cbiAgICovXG4gIHNldFN0YXRlID0gKHBhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgLi4ucGF0Y2gsXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgbmVpZ2hib3Job29kcyBhbmQgc2V0IHRoZWlyIEhUTUwuXG4gICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICovXG4gIGZldGNoTmVpZ2hib3Job29kcyA9ICgpID0+IHtcbiAgICB0aGlzLnN0YXRlLm5laWdoYm9yaG9vZHMgPSBbXTtcbiAgICBjb25zdCBmZXRjaE4gPSAocikgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5uZWlnaGJvcmhvb2RzID0gW107XG4gICAgICByZXR1cm4gREJIZWxwZXJcbiAgICAgICAgLmZldGNoTmVpZ2hib3Job29kcyhyKVxuICAgICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAgIChuZWlnaGJvcmhvb2RzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm5laWdoYm9yaG9vZHMucHVzaChuZWlnaGJvcmhvb2RzKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbE5laWdoYm9yaG9vZHNIVE1MKG5laWdoYm9yaG9vZHMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycm9yKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5yZXN0YXVyYW50cyAmJiB0aGlzLnN0YXRlLnJlc3RhdXJhbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZmV0Y2hOKHRoaXMuc3RhdGUucmVzdGF1cmFudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZXRjaE4odGhpcy5zZXRSZXN0YXVyYW50cygpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBuZWlnaGJvcmhvb2RzIEhUTUwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuZWlnaGJvcmhvb2RcbiAgICogQHJldHVybiB7SFRNTE9wdGlvbkVsZW1lbnR9XG4gICAqL1xuICBmaWxsTmVpZ2hib3Job29kc0hUTUwgPSAobmVpZ2hib3Job29kKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25laWdoYm9yaG9vZHMtc2VsZWN0Jyk7XG5cbiAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHRpb24uaW5uZXJIVE1MID0gbmVpZ2hib3Job29kO1xuICAgIG9wdGlvbi52YWx1ZSA9IG5laWdoYm9yaG9vZDtcbiAgICB0cnkge1xuICAgICAgc2VsZWN0LmFwcGVuZChvcHRpb24pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2VsZWN0LmlubmVySFRNTCArPSBvcHRpb24ub3V0ZXJIVE1MO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgY3Vpc2luZXMgYW5kIHNldCB0aGVpciBIVE1MLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZmV0Y2hDdWlzaW5lcyA9ICgpID0+IHtcbiAgICB0aGlzLnN0YXRlLmN1aXNpbmVzID0gW107XG4gICAgREJIZWxwZXIuZmV0Y2hDdWlzaW5lcyh0aGlzLnN0YXRlLnJlc3RhdXJhbnRzKVxuICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgKGN1aXNpbmUpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmN1aXNpbmVzLnB1c2goY3Vpc2luZSk7XG4gICAgICAgICAgdGhpcy5maWxsQ3Vpc2luZXNIVE1MKGN1aXNpbmUpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY3Vpc2luZXMgSFRNTC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1aXNpbmVcbiAgICogQHJldHVybiB7SFRNTE9wdGlvbkVsZW1lbnR9XG4gICAqL1xuICBmaWxsQ3Vpc2luZXNIVE1MID0gKGN1aXNpbmUpID0+IHtcbiAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3Vpc2luZXMtc2VsZWN0Jyk7XG5cbiAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHRpb24uaW5uZXJIVE1MID0gY3Vpc2luZTtcbiAgICBvcHRpb24udmFsdWUgPSBjdWlzaW5lO1xuICAgIHRyeSB7XG4gICAgICBzZWxlY3QuYXBwZW5kKG9wdGlvbilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZWxlY3QuaW5uZXJIVE1MICs9IG9wdGlvbi5vdXRlckhUTUw7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZmV0Y2hlZCBvciB1cGRhdGUgcmVzdGF1cmFudHMgdGhpcyBzZXRzIHN0YXRlLnJlc3RhdXJhbnRzIHRvIGNvbGxlY3Rpb24gb2YgcmVzdGF1cmFudHNcbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX1cbiAgICovXG4gIHNldFJlc3RhdXJhbnRzID0gKCkgPT4ge1xuICAgIHRoaXMuc3RhdGUucmVzdGF1cmFudHMgPSBuZXcgU3ViamVjdCgpO1xuICAgIGNvbnN0IERCID0gREJIZWxwZXIuY3JlYXRlSW5kZXhlZERCKERCSGVscGVyLkRBVEFCQVNFX05BTUUpO1xuICAgIERCSGVscGVyLmNyZWF0ZUluZGV4ZWRTdG9yZXMoREIsIHtyZXN0YXVyYW50czogJ2lkKyssbmFtZSxuZWlnaGJvcmhvb2QsY3Vpc2luZV90eXBlJ30pO1xuICAgIHRoaXMucmVzZXRSZXN0YXVyYW50cygpO1xuICAgIHJldHVybiBEQkhlbHBlci5mZXRjaFJlc3RhdXJhbnRzKClcbiAgICAgIC5tYXAoXG4gICAgICAgIChyZXN0YXVyYW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5maWxsUmVzdGF1cmFudHNIVE1MKHJlc3RhdXJhbnQpO1xuICAgICAgICAgIHRoaXMuc3RhdGUucmVzdGF1cmFudHMubmV4dChyZXN0YXVyYW50KTtcbiAgICAgICAgICBEQltEQkhlbHBlci5EQVRBQkFTRV9OQU1FXS5wdXQocmVzdGF1cmFudClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbmV4ZWREQiA9IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHJlc3RhdXJhbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4gY29uc29sZS5lcnJvcihlcnJvcilcbiAgICAgICk7XG5cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHBhZ2UgYW5kIG1hcCBmb3IgY3VycmVudCByZXN0YXVyYW50cy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHVwZGF0ZVJlc3RhdXJhbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3Vpc2luZXMtc2VsZWN0Jyk7XG4gICAgY29uc3QgblNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZWlnaGJvcmhvb2RzLXNlbGVjdCcpO1xuXG4gICAgY29uc3QgY0luZGV4ID0gY1NlbGVjdC5zZWxlY3RlZEluZGV4O1xuICAgIGNvbnN0IG5JbmRleCA9IG5TZWxlY3Quc2VsZWN0ZWRJbmRleDtcblxuICAgIGNvbnN0IGN1aXNpbmUgPSBjU2VsZWN0W2NJbmRleF0udmFsdWU7XG4gICAgY29uc3QgbmVpZ2hib3Job29kID0gblNlbGVjdFtuSW5kZXhdLnZhbHVlO1xuXG4gICAgLy8gUmVtb3ZlIGFsbCByZXN0YXVyYW50c1xuICAgIHRoaXMucmVzZXRSZXN0YXVyYW50cygpO1xuICAgIERCSGVscGVyLmZldGNoUmVzdGF1cmFudEJ5Q3Vpc2luZUFuZE5laWdoYm9yaG9vZChEQkhlbHBlci5mZXRjaFJlc3RhdXJhbnRzKCksIGN1aXNpbmUsIG5laWdoYm9yaG9vZClcbiAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgIChyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2cocik7XG4gICAgICAgICAgdGhpcy5maWxsUmVzdGF1cmFudHNIVE1MKHIpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBjdXJyZW50IHJlc3RhdXJhbnRzLCB0aGVpciBIVE1MIGFuZCByZW1vdmUgdGhlaXIgbWFwIG1hcmtlcnMuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICByZXNldFJlc3RhdXJhbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3RhdXJhbnRzLWxpc3QnKTtcbiAgICB1bC5pbm5lckhUTUwgPSAnJztcbiAgICAvLyBSZW1vdmUgYWxsIG1hcCBtYXJrZXJzXG4gICAgdGhpcy5zdGF0ZS5tYXJrZXJzID0gdGhpcy5zdGF0ZS5tYXJrZXJzID8gdGhpcy5zdGF0ZS5tYXJrZXJzIDogW107XG4gICAgdGhpcy5zdGF0ZS5tYXJrZXJzLmZvckVhY2gobSA9PiBtLnNldE1hcChudWxsKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbGwgcmVzdGF1cmFudHMgSFRNTCBhbmQgYWRkIHRoZW0gdG8gdGhlIHdlYnBhZ2UuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBmaWxsUmVzdGF1cmFudHNIVE1MID0gKHJlc3RhdXJhbnQpID0+IHtcbiAgICBjb25zdCB1bCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN0YXVyYW50cy1saXN0Jyk7XG5cbiAgICB0cnkge1xuICAgICAgdWwuYXBwZW5kKHRoaXMuY3JlYXRlUmVzdGF1cmFudEhUTUwocmVzdGF1cmFudCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHVsLmlubmVySFRNTCArPSB0aGlzLmNyZWF0ZVJlc3RhdXJhbnRIVE1MKHJlc3RhdXJhbnQpLm91dGVySFRNTDsgLy8gc3VwcG9ydCBmb3IgTVMgRWRnZVxuICAgIH1cblxuICAgIHRoaXMuYWRkTWFya2Vyc1RvTWFwKHJlc3RhdXJhbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmVzcG9uc2l2ZSBpbWFnZSBIVE1MXG4gICAqIEBwYXJhbSB1cmwge3N0cmluZ31cbiAgICogQHBhcmFtIGFsdCB7c3RyaW5nfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlUmVzcG9uc2l2ZUltZyA9ICh1cmwsIGFsdCkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZFVSTCA9IHVybC5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHVybFdpdGhvdXRFeHQgPSBwYXJzZWRVUkxbcGFyc2VkVVJMLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBgPHBpY3R1cmUgY2xhc3M9XCJyZXN0YXVyYW50LWltZ1wiPlxuICA8c291cmNlIG1lZGlhPVwiKG1heC13aWR0aDogNzE5cHgpXCJcbiAgICBzcmNzZXQ9XCIuJHt1cmxXaXRob3V0RXh0fS0xMDAtMXguanBnIDF4LCAuJHt1cmxXaXRob3V0RXh0fS0xMDAtMnguanBnIDJ4LCAuJHt1cmxXaXRob3V0RXh0fS0xMDAtM3guanBnIDN4XCI+XG4gIDxzb3VyY2UgIG1lZGlhPVwiKG1pbi13aWR0aDogNzIwcHgpXCJcbiAgICBzcmNzZXQ9XCIuJHt1cmx9LmpwZyAxeFwiPlxuICA8aW1nIGNsYXNzPVwicmVzdGF1cmFudC1pbWdcIiBzcmM9XCIuJHt1cmx9LmpwZ1wiIGFsdD1cIiR7YWx0fVwiPlxuPC9waWN0dXJlPmA7XG5cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHJlc3RhdXJhbnQgSFRNTC5cbiAgICogQHBhcmFtIHJlc3RhdXJhbnQge09iamVjdH1cbiAgICogQHJldHVybiB7Tm9kZX1cbiAgICovXG4gIGNyZWF0ZVJlc3RhdXJhbnRIVE1MID0gKHJlc3RhdXJhbnQpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCByYW5kb21JZCA9ICduJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zcGxpdCgnLicpWzFdO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgPGxpIHJvbGU9XCJiYW5uZXJcIiBhcmlhLWxhYmVsbGVkYnk9XCIke3JhbmRvbUlkfVwiPlxuPGRpdiBpZD1cIiR7cmFuZG9tSWR9XCI+XG4ke1Jlc3RhdXJhbnQuY3JlYXRlUmVzcG9uc2l2ZUltZyhEQkhlbHBlci5pbWFnZVVybEZvclJlc3RhdXJhbnQocmVzdGF1cmFudCksIGBJbWFnZSBvZiAke3Jlc3RhdXJhbnQubmFtZX0gcmVzdGF1cmFudGApfVxuPGgyIHJvbGU9XCJoZWFkaW5nXCI+JHtyZXN0YXVyYW50Lm5hbWV9PC9oMj5cbjxwPiR7cmVzdGF1cmFudC5uZWlnaGJvcmhvb2R9PC9wPlxuPHA+JHtyZXN0YXVyYW50LmFkZHJlc3N9PC9wPlxuPC9kaXY+XG48YSByb2xlPVwibGlua1wiIGhyZWY9XCIke0RCSGVscGVyLnVybEZvclJlc3RhdXJhbnQocmVzdGF1cmFudCl9XCI+VmlldyBEZXRhaWxzPC9hPjwvbGk+YFxuICAgICAgLnJlcGxhY2UoLz5cXHMrPC8sICc+PCcpOyAvL2p1c3QgaW4gY2FzZSBicm93c2VyIHdpbGwgcmVuZGVyIHVud2FudGVkIHNwYWNlXG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgbWFya2VycyBmb3IgY3VycmVudCByZXN0YXVyYW50cyB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdGF1cmFudFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIGFkZE1hcmtlcnNUb01hcCA9IChyZXN0YXVyYW50KSA9PiB7XG4gICAgY29uc3QgbWFya2VyID0gREJIZWxwZXIubWFwTWFya2VyRm9yUmVzdGF1cmFudChyZXN0YXVyYW50LCB0aGlzLnN0YXRlLm1hcCk7XG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG1hcmtlci51cmxcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICB9O1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlc3RhdXJhbnQ7XG5leHBvcnQgY29uc3QgY3JlYXRlUmVzcG9uc2l2ZUltZyA9IFJlc3RhdXJhbnQuY3JlYXRlUmVzcG9uc2l2ZUltZztcbiJdfQ==
},{"./dbhelper":55,"rxjs/Observable":4,"rxjs/Subject":7,"rxjs/add/operator/map":15}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _dbhelper = require('./dbhelper');

var _dbhelper2 = _interopRequireDefault(_dbhelper);

var _main = require('./main');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Review = function Review() {
    var _this = this;

    _classCallCheck(this, Review);

    this.state = {
        restaurant: null,
        map: null
    };

    this.setState = function (obj) {
        return _this.state = _extends({}, _this.state, obj);
    };

    this.fetchRestaurantFromURL = function (callback) {
        if (_this.state.restaurant) {
            // restaurant already fetched!
            callback(null, _this.state.restaurant);
            return;
        }
        var id = _this.getParameterByName();
        if (!id) {
            // no id found in URL
            var error = 'No restaurant id in URL';
            callback(error, null);
        } else {
            _dbhelper2.default.fetchRestaurantById(id, function (error, restaurant) {
                _this.state.restaurant = restaurant;
                if (!restaurant) {
                    console.error(error);
                    return;
                }
                _this.fillRestaurantHTML();
                callback(null, restaurant);
            });
        }
    };

    this.fillRestaurantHTML = function () {
        var restaurant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.restaurant;

        var name = document.getElementById('restaurant-name');
        name.innerHTML = restaurant.name;

        var address = document.getElementById('restaurant-address');
        address.innerHTML = restaurant.address;

        var image = document.getElementById('restaurant-img');
        image.outerHTML = (0, _main.createResponsiveImg)(_dbhelper2.default.imageUrlForRestaurant(restaurant), 'Image of ' + restaurant.name + ' restaurant');
        var img = document.getElementsByClassName('restaurant-img')[1];
        img.id = 'restaurant-img';

        var cuisine = document.getElementById('restaurant-cuisine');
        cuisine.innerHTML = restaurant.cuisine_type;
        // fill operating hours
        if (restaurant.operating_hours) {
            _this.fillRestaurantHoursHTML();
        }
        // fill reviews
        _this.fillReviewsHTML();
    };

    this.fillRestaurantHoursHTML = function () {
        var operatingHours = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.restaurant.operating_hours;

        var hours = document.getElementById('restaurant-hours');
        for (var key in operatingHours) {
            var row = document.createElement('tr');

            var day = document.createElement('td');
            day.innerHTML = key;
            row.appendChild(day);

            var time = document.createElement('td');
            time.innerHTML = operatingHours[key];
            row.appendChild(time);

            hours.appendChild(row);
        }
    };

    this.fillReviewsHTML = function () {
        var reviews = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.restaurant.reviews;

        var container = document.getElementById('reviews-container');
        var title = document.createElement('h3');
        title.innerHTML = 'Reviews';
        container.appendChild(title);

        if (!reviews) {
            var noReviews = document.createElement('p');
            noReviews.innerHTML = 'No reviews yet!';
            container.appendChild(noReviews);
            return;
        }
        var ul = document.getElementById('reviews-list');
        reviews.forEach(function (review) {
            ul.appendChild(_this.createReviewHTML(review));
        });
        container.appendChild(ul);
    };

    this.createReviewHTML = function (review) {
        var container = document.createElement('div');
        container.innerHTML = ('<li><p>' + review.name + '</p>\n<p>' + review.date + '</p>\n<p class="review-rating">Rating: ' + review.rating + '</p>\n<p>' + review.comments + '</p></li>').replace(/>\s+</, '><');

        return container.firstChild;
    };

    this.fillBreadcrumb = function () {
        var restaurant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.restaurant;

        var breadcrumb = document.getElementById('breadcrumb');
        var li = document.createElement('li');
        li.innerHTML = restaurant.name;
        breadcrumb.appendChild(li);
    };

    this.getParameterByName = function () {
        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.pathname;

        var results = url.split('/');
        if (!results) {
            return null;
        }
        if (!results[2]) {
            return '';
        }
        return results[2];
    };
}
/**
 * Get current restaurant from page URL.
 * @param callback {function}
 */


/**
 * Create restaurant HTML and add it to the webpage
 * @param restaurant {Object}
 */


/**
 * Create restaurant operating hours HTML table and add it to the webpage.
 * @param operatingHours {Object}
 */


/**
 * Create all reviews HTML and add them to the webpage.
 * @param reviews {array}
 */


/**
 * Create review HTML and add it to the webpage.
 * @param review {Object}
 */


/**
 * Add restaurant name to the breadcrumb navigation menu
 * @param restaurant {Object}
 */


/**
 * Get a parameter by name from page URL.
 * @param url {String=}
 */
;

exports.default = Review;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlc3RhdXJhbnRfaW5mby5qcyJdLCJuYW1lcyI6WyJSZXZpZXciLCJzdGF0ZSIsInJlc3RhdXJhbnQiLCJtYXAiLCJzZXRTdGF0ZSIsIm9iaiIsImZldGNoUmVzdGF1cmFudEZyb21VUkwiLCJjYWxsYmFjayIsImlkIiwiZ2V0UGFyYW1ldGVyQnlOYW1lIiwiZXJyb3IiLCJmZXRjaFJlc3RhdXJhbnRCeUlkIiwiY29uc29sZSIsImZpbGxSZXN0YXVyYW50SFRNTCIsIm5hbWUiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJIVE1MIiwiYWRkcmVzcyIsImltYWdlIiwib3V0ZXJIVE1MIiwiaW1hZ2VVcmxGb3JSZXN0YXVyYW50IiwiaW1nIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImN1aXNpbmUiLCJjdWlzaW5lX3R5cGUiLCJvcGVyYXRpbmdfaG91cnMiLCJmaWxsUmVzdGF1cmFudEhvdXJzSFRNTCIsImZpbGxSZXZpZXdzSFRNTCIsIm9wZXJhdGluZ0hvdXJzIiwiaG91cnMiLCJrZXkiLCJyb3ciLCJjcmVhdGVFbGVtZW50IiwiZGF5IiwiYXBwZW5kQ2hpbGQiLCJ0aW1lIiwicmV2aWV3cyIsImNvbnRhaW5lciIsInRpdGxlIiwibm9SZXZpZXdzIiwidWwiLCJmb3JFYWNoIiwiY3JlYXRlUmV2aWV3SFRNTCIsInJldmlldyIsImRhdGUiLCJyYXRpbmciLCJjb21tZW50cyIsInJlcGxhY2UiLCJmaXJzdENoaWxkIiwiZmlsbEJyZWFkY3J1bWIiLCJicmVhZGNydW1iIiwibGkiLCJ1cmwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwicmVzdWx0cyIsInNwbGl0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztJQUVNQSxNOzs7OztTQUNGQyxLLEdBQVE7QUFDSkMsb0JBQVksSUFEUjtBQUVKQyxhQUFLO0FBRkQsSzs7U0FLUkMsUSxHQUFXLFVBQUNDLEdBQUQsRUFBUztBQUNoQixlQUFPLE1BQUtK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LEdBQWVmLFdBQVdZLElBQTFCO0FBQ0FxQyxtQkFBV2hCLFdBQVgsQ0FBdUJpQixFQUF2QjtBQUNILEs7O1NBTUQzQyxrQixHQUFxQixZQUFrQztBQUFBLFlBQWpDNEMsR0FBaUMsdUVBQTdCQyxPQUFPQyxRQUFQLENBQWdCQyxRQUFhOztBQUNuRCxZQUFNQyxVQUFVSixJQUFJSyxLQUFKLENBQVUsR0FBVixDQUFoQjtBQUNBLFlBQUksQ0FBQ0QsT0FBTCxFQUFjO0FBQ1YsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsWUFBSSxDQUFDQSxRQUFRLENBQVIsQ0FBTCxFQUFpQjtBQUNiLG1CQUFPLEVBQVA7QUFDSDtBQUNELGVBQU9BLFFBQVEsQ0FBUixDQUFQO0FBQ0gsSzs7QUF2SUQ7Ozs7OztBQTBCQTs7Ozs7O0FBMEJBOzs7Ozs7QUFxQkE7Ozs7OztBQXVCQTs7Ozs7O0FBZUE7Ozs7OztBQVdBOzs7Ozs7a0JBaUJXekQsTSIsImZpbGUiOiJyZXN0YXVyYW50X2luZm8uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgREJIZWxwZXIgZnJvbSBcIi4vZGJoZWxwZXJcIjtcclxuaW1wb3J0IHtjcmVhdGVSZXNwb25zaXZlSW1nfSBmcm9tICcuL21haW4nO1xyXG5cclxuY2xhc3MgUmV2aWV3IHtcclxuICAgIHN0YXRlID0ge1xyXG4gICAgICAgIHJlc3RhdXJhbnQ6IG51bGwsXHJcbiAgICAgICAgbWFwOiBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXRTdGF0ZSA9IChvYmopID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZSxcclxuICAgICAgICAgICAgLi4ub2JqLFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBjdXJyZW50IHJlc3RhdXJhbnQgZnJvbSBwYWdlIFVSTC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7ZnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIGZldGNoUmVzdGF1cmFudEZyb21VUkwgPSAoY2FsbGJhY2spID0+IHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZXN0YXVyYW50KSB7IC8vIHJlc3RhdXJhbnQgYWxyZWFkeSBmZXRjaGVkIVxyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0aGlzLnN0YXRlLnJlc3RhdXJhbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRQYXJhbWV0ZXJCeU5hbWUoKTtcclxuICAgICAgICBpZiAoIWlkKSB7IC8vIG5vIGlkIGZvdW5kIGluIFVSTFxyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9ICdObyByZXN0YXVyYW50IGlkIGluIFVSTCc7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBEQkhlbHBlci5mZXRjaFJlc3RhdXJhbnRCeUlkKGlkLCAoZXJyb3IsIHJlc3RhdXJhbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVzdGF1cmFudCA9IHJlc3RhdXJhbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3RhdXJhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZXN0YXVyYW50SFRNTCgpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdGF1cmFudClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSByZXN0YXVyYW50IEhUTUwgYW5kIGFkZCBpdCB0byB0aGUgd2VicGFnZVxyXG4gICAgICogQHBhcmFtIHJlc3RhdXJhbnQge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZmlsbFJlc3RhdXJhbnRIVE1MID0gKHJlc3RhdXJhbnQgPSB0aGlzLnN0YXRlLnJlc3RhdXJhbnQpID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3RhdXJhbnQtbmFtZScpO1xyXG4gICAgICAgIG5hbWUuaW5uZXJIVE1MID0gcmVzdGF1cmFudC5uYW1lO1xyXG5cclxuICAgICAgICBjb25zdCBhZGRyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3RhdXJhbnQtYWRkcmVzcycpO1xyXG4gICAgICAgIGFkZHJlc3MuaW5uZXJIVE1MID0gcmVzdGF1cmFudC5hZGRyZXNzO1xyXG5cclxuICAgICAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN0YXVyYW50LWltZycpO1xyXG4gICAgICAgIGltYWdlLm91dGVySFRNTCA9IGNyZWF0ZVJlc3BvbnNpdmVJbWcoREJIZWxwZXIuaW1hZ2VVcmxGb3JSZXN0YXVyYW50KHJlc3RhdXJhbnQpLCBgSW1hZ2Ugb2YgJHtyZXN0YXVyYW50Lm5hbWV9IHJlc3RhdXJhbnRgKTtcclxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyZXN0YXVyYW50LWltZycpWzFdO1xyXG4gICAgICAgIGltZy5pZCA9ICdyZXN0YXVyYW50LWltZyc7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1aXNpbmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdGF1cmFudC1jdWlzaW5lJyk7XHJcbiAgICAgICAgY3Vpc2luZS5pbm5lckhUTUwgPSByZXN0YXVyYW50LmN1aXNpbmVfdHlwZTtcclxuICAgICAgICAvLyBmaWxsIG9wZXJhdGluZyBob3Vyc1xyXG4gICAgICAgIGlmIChyZXN0YXVyYW50Lm9wZXJhdGluZ19ob3Vycykge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZXN0YXVyYW50SG91cnNIVE1MKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbGwgcmV2aWV3c1xyXG4gICAgICAgIHRoaXMuZmlsbFJldmlld3NIVE1MKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHJlc3RhdXJhbnQgb3BlcmF0aW5nIGhvdXJzIEhUTUwgdGFibGUgYW5kIGFkZCBpdCB0byB0aGUgd2VicGFnZS5cclxuICAgICAqIEBwYXJhbSBvcGVyYXRpbmdIb3VycyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBmaWxsUmVzdGF1cmFudEhvdXJzSFRNTCA9IChvcGVyYXRpbmdIb3VycyA9IHRoaXMuc3RhdGUucmVzdGF1cmFudC5vcGVyYXRpbmdfaG91cnMpID0+IHtcclxuICAgICAgICBjb25zdCBob3VycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN0YXVyYW50LWhvdXJzJyk7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9wZXJhdGluZ0hvdXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICBkYXkuaW5uZXJIVE1MID0ga2V5O1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoZGF5KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICB0aW1lLmlubmVySFRNTCA9IG9wZXJhdGluZ0hvdXJzW2tleV07XHJcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aW1lKTtcclxuXHJcbiAgICAgICAgICAgIGhvdXJzLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbGwgcmV2aWV3cyBIVE1MIGFuZCBhZGQgdGhlbSB0byB0aGUgd2VicGFnZS5cclxuICAgICAqIEBwYXJhbSByZXZpZXdzIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgZmlsbFJldmlld3NIVE1MID0gKHJldmlld3MgPSB0aGlzLnN0YXRlLnJlc3RhdXJhbnQucmV2aWV3cykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXZpZXdzLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcclxuICAgICAgICB0aXRsZS5pbm5lckhUTUwgPSAnUmV2aWV3cyc7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXZpZXdzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vUmV2aWV3cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcclxuICAgICAgICAgICAgbm9SZXZpZXdzLmlubmVySFRNTCA9ICdObyByZXZpZXdzIHlldCEnO1xyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobm9SZXZpZXdzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXZpZXdzLWxpc3QnKTtcclxuICAgICAgICByZXZpZXdzLmZvckVhY2gocmV2aWV3ID0+IHtcclxuICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVSZXZpZXdIVE1MKHJldmlldykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh1bCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHJldmlldyBIVE1MIGFuZCBhZGQgaXQgdG8gdGhlIHdlYnBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcmV2aWV3IHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVJldmlld0hUTUwgPSAocmV2aWV3KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGA8bGk+PHA+JHtyZXZpZXcubmFtZX08L3A+XHJcbjxwPiR7cmV2aWV3LmRhdGV9PC9wPlxyXG48cCBjbGFzcz1cInJldmlldy1yYXRpbmdcIj5SYXRpbmc6ICR7cmV2aWV3LnJhdGluZ308L3A+XHJcbjxwPiR7cmV2aWV3LmNvbW1lbnRzfTwvcD48L2xpPmBcclxuICAgICAgICAgICAgLnJlcGxhY2UoLz5cXHMrPC8sICc+PCcpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHJlc3RhdXJhbnQgbmFtZSB0byB0aGUgYnJlYWRjcnVtYiBuYXZpZ2F0aW9uIG1lbnVcclxuICAgICAqIEBwYXJhbSByZXN0YXVyYW50IHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGZpbGxCcmVhZGNydW1iID0gKHJlc3RhdXJhbnQgPSB0aGlzLnN0YXRlLnJlc3RhdXJhbnQpID0+IHtcclxuICAgICAgICBjb25zdCBicmVhZGNydW1iID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JyZWFkY3J1bWInKTtcclxuICAgICAgICBjb25zdCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XHJcbiAgICAgICAgbGkuaW5uZXJIVE1MID0gcmVzdGF1cmFudC5uYW1lO1xyXG4gICAgICAgIGJyZWFkY3J1bWIuYXBwZW5kQ2hpbGQobGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHBhcmFtZXRlciBieSBuYW1lIGZyb20gcGFnZSBVUkwuXHJcbiAgICAgKiBAcGFyYW0gdXJsIHtTdHJpbmc9fVxyXG4gICAgICovXHJcbiAgICBnZXRQYXJhbWV0ZXJCeU5hbWUgPSAodXJsPXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB1cmwuc3BsaXQoJy8nKTtcclxuICAgICAgICBpZiAoIXJlc3VsdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVzdWx0c1syXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzWzJdO1xyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJldmlldztcclxuIl19
},{"./dbhelper":55,"./main":57}]},{},[56])